*
*	Amiga-specific portions of Moon Patrol
*
* (c) JOTD 2024
*

.include "../src/mpatrol.inc"
.include "custom.i"
.include "exec_lvos.i"
.include "dos_lvos.i"
.include "graphics_lvos.i"

AttnFlags = 0x128
AFB_68010 = 0
AFB_68020 = 1
NO68020 = 1

PREVIOUS_SPRITE_SIZE = 8
BORDERBLANK = 1

* bob backup flags for sprites
BB_SHIP = 1+1
BB_ROLLING_ROCK = 2+1
BB_ROCK = 3+1

Y_MAX = 260

BASE_BPLCON2_VALUE = 0x0024
SCREEN_ADDRESS = 0x8000

* set to 1 to block ground scrolling, see what's
* going on with the game scrolling system
FIX_GROUND_SCROLL = 0


PANEL_MAX_Y = 48
DYNAMIC_COPPER_ROWS = 210-PANEL_MAX_Y   | make sure it's even!!!!
HALF_DYNAMIC_COPPER_ROWS = DYNAMIC_COPPER_ROWS/2
SPRITE_COPPERLIST_CHUNK_SIZE = 64+64+8	| sprite copper (8*2 pointers) + color sprite copper (16 colors) + intreq
SPRITE_Y_SPLIT_LIMIT = 96+PANEL_MAX_Y

* with those, buggy wheels match perfectly the ground!
SPRITE_Y_CORRECTION = -14
SPRITE_X_CORRECTION = 17
* exact match at 
BACKGROUND_X_CORRECTION = 4

SCROLLABLE_TILE_Y_START = 24
SCROLLABLE_STRIP_NB_COLS = 66
NB_BYTES_PER_SCROLLABLE_STRIP_ROW = SCROLLABLE_STRIP_NB_COLS
SCROLLABLE_PLANE_SIZE = SCROLLABLE_STRIP_NB_COLS*8*(32-SCROLLABLE_TILE_Y_START)

SCORE_FILE_SIZE = 0x6

* if the alloc_sprite & update_sprite routines
* are reused, changing those offsets can make
* a quick reuse from game to game as most sprite
* RAMs have 4 bytes per sprite, only the order
* and some bits differ

TARGET_SPRITE_ATTRIBUTES = 1
TARGET_SPRITE_CODE = 2
TARGET_SPRITE_Y = 0
TARGET_SPRITE_X = 3
ACTIVE_BITPLANE_MASK = 4   | for optimized bitplane erase

* fixed title blit
TITLE_NB_COLS = 22
TITLE_NB_ROWS = 12
TITLE_X = 64
TITLE_Y = 80

TITLE_WIDTH = 160
TITLE_HEIGHT = 104
* above tile 7: playfield
PLAYFIELD_TILE_Y_MIN = 7
* above Y tile = 14, no need to cookie cut chars as mountains
* aren't drawn above this limit (at least not when chars are drawn there
* for instance "Moon" of the "Moon Patrol" title doesn't superimpose with mountains
COOKIE_CUT_TILE_Y_MIN = 14

	.ifdef	RELEASE
OPT_ENABLE_PROFILING = 0         | DO NOT CHANGE THIS
OPT_ENABLE_LOGGING = 0           | DO NOT CHANGE THIS
ONE_TICK = 1
	.else
OPT_ENABLE_LOGGING = 0
OPT_ENABLE_PROFILING = 0
* set to higher values than 1 to speed game up
ONE_TICK = 1


	.endif
	

OPT_ENABLE_DOUBLE_BUFFERING = 1

_custom = 0xDFF000

OPT_ENABLE_MULTIPLEXED_SPRITES = 1

NB_PLAYFIELD_PLANES = 4
TOTAL_NB_COLORS = 1<<NB_PLAYFIELD_PLANES
NB_BYTES_PER_ROW = 40
NB_LINES = 256
NB_PLAYFIELD_LINES = NB_LINES

BG_SCREEN_PLANE_SIZE = NB_BYTES_PER_ROW*NB_PLAYFIELD_LINES
BG_SCREEN_SIZE =  BG_SCREEN_PLANE_SIZE*NB_PLAYFIELD_PLANES
FG_SCREEN_PLANE_SIZE = BG_SCREEN_PLANE_SIZE
FG_SCREEN_SIZE =  FG_SCREEN_PLANE_SIZE*NB_PLAYFIELD_PLANES

NB_HOST_SPRITES = 8
* hardware can take 64 sprites but game only shadows
* 48 of them (E100-E1BF) rest is zero, which makes
* it (slightly) simpler for us
NB_TARGET_SPRITES = 48

SPRITE_X = 0
SPRITE_Y = 1
SPRITE_CODE = 2
SPRITE_CLUT = 3
SPRITE_SIZEOF = 4


| write current PC value to some address
.macro LOGPC	address
	.ifndef	RELEASE
     bsr    .next_\@
.next_\@:
      addq.l    #6,(a7) | skip this & next instruction
      move.l    (a7)+,0x\address
	.endif
.endm

.macro	WAIT_BLIT
	move.w	#0x8400,(dmacon,a5)		| blitter high priority
wait\@:
	BTST	#6,(dmaconr,a5)
	BNE.S	wait\@
	move.w	#0x0400,(dmacon,a5)		| blitter normal priority
.endm

.macro MUL_TABLE value,len
mul\value\()_table:
	.set    mulv,0
	.rept	\len
	dc.w	mulv
	.set	mulv,mulv+\value
	.endr
.endm


* debug macro that colors the screen until LMB pressed
.macro 	blitz_bypass
	move.w	d0,-(a7)
	clr.w	d0
loop\@:
	move.w	d0,_custom+color
	btst	#6,0xbfe001
	beq.b	out\@
	addq.w	#1,d0
	bra.b	loop\@
out\@:
	move.w	(a7)+,d0
	nop
.endm

* same thing but if LMB is pressed when entering, macro waits for release)
.macro blitz
w\@:
	btst	#6,0xbfe001
	beq.b	w\@
	blitz_bypass
.endm

start:
	move.l	a7,old_stack
	bra	_user
    
	

* exports

	  .global _user
		.global _player_start
		.global _demo_end

* osd layer		
		.global osd_disable_interrupts
		.global osd_enable_interrupts
		.global osd_ack_vblank_interrupt
		.global osd_break		| for debug	
		.global osd_blitz		| for debug
		.global osd_w_videoram_no_update
		.global osd_w_videoram
		.global osd_w_colorram
		.global osd_r_videoram
		.global osd_update_sprites
		.global osd_read_dsw_1
		.global osd_read_dsw_2
		.global osd_read_in_1
		.global osd_read_in_0
		.global osd_read_in_2
		.global osd_read_inputs
		.global osd_read_high_scores
		.global osd_write_high_scores
		.global	osd_get_random
		.global	osd_wait
		.global	osd_set_ground_scroll_value
		
	
	.include	"ReadJoypad.i"
	.include	"whdload_funcs.i"
		.text


.list

	.ifne	OPT_ENABLE_PROFILING
	* init profiling if enabled
	.include	"profiler.68k"
	.endif

	    
_user:
    * if D0 contains "WHDL"
    * A0 contains resload
        
    cmp.l   #0x05748444c,D0	| WHDL
    bne.b   .standard
	move.b	d1,_keyexit
    move.l a0,_resload

	move.l	a0,a2
	lea	(_tag,pc),a0
	jsr	(resload_Control,a2)
	
    bra		.no_forbid
.standard:
	
    * open dos library, graphics library
    move.l  0x4.W,a6
    lea dosname,a1
    moveq.l #0,d0
    jsr _LVOOpenLibrary(a6)
    move.l  d0,_dosbase
	bsr		load_highscores
    * check if "floppy" file is here
    move.l  _dosbase(pc),a6
    move.l   #floppy_file,d1
    move.l  #1005,d2   | MODE_OLDFILE
    jsr     _LVOOpen(a6)
    move.l  d0,d1
    beq.b   no_floppy
    * "floppy" file found
    jsr     _LVOClose(a6)
    * wait 2 seconds for floppy drive to switch off
    move.l  #100,d1
    jsr     _LVODelay(a6)
no_floppy:

	lea	read_args_string(pc),a0
	lea	program_args(pc),a1
	move.l	#program_args_end-program_args,d0
	lsr.l	#2,d0		| number of longs
	

	bsr	get_args_BCPL

0:	
	lea		program_args,a0

	move.l	(A0)+,D0	| INVINCIBLE/S
	beq.b	1f
	or.l	#1,cheat_flags
	st.b	cheat_used
1:
	move.l	(A0)+,D0	| INFLIVES/S
	beq.b	2f
	or.l	#2,cheat_flags
	st.b	cheat_used
2:
	move.l	(A0)+,D0	| INFTIME/S
	beq.b	2f
	or.l	#4,cheat_flags
	st.b	cheat_used
2:
	move.l	(A0)+,D0	| SECTORSELECT/S
	beq.b	2f
	or.l	#8,cheat_flags
	st.b	cheat_used
2:
	move.l	(A0)+,D0	| CHEATKEYS/S
	beq.b	2f
	* cheat isn't used as long as no cheat key is used
	or.l	#0x10,cheat_flags
2:

	move.l	(A0)+,D0	| SKILL/S
	beq.b	2f
	bsr		bcpl_string_to_int
	move.l	d0,dip_switch_start_course
2:
	move.l	(A0)+,D0	| STARTLIVES/S
	beq.b	2f
	bsr		bcpl_string_to_int
	subq.b	#1,d0
	bmi.b	2f
	move.l	d0,dip_switch_start_lives
	bra.b	3f
2:
	move.l	#2,dip_switch_start_lives		| 3 lives default
3:
	lea		_custom,a5
	lea		debug_copperlist,a0
	move.l	a0,cop1lc(a5)

	


    
    
	

.startup:

* no multitask
    tst.l   _resload
    bne.b   .no_forbid
	
	move.l	4.W,A6
	lea graphicsname,a1
    moveq.l #0,d0
    jsr _LVOOpenLibrary(a6)
    move.l  d0,_gfxbase
    move.l	d0,a6
	move.l	38(a6),old_syscoplist
	move.l	34(A6),old_actiview		| gb_ActiView

	sub.l	a1,a1
	jsr	_LVOLoadView(a6)
	jsr	_LVOWaitTOF(a6)
	jsr	_LVOWaitTOF(a6)
	
    *move.l  _gfxbase(pc),a4
    *move.l StartList(a4),gfxbase_copperlist

	
    move.l  4,a6
    jsr _LVOForbid(a6)

    
	sub.l	A1,A1
	jsr	_LVOFindTask(a6)		| find ourselves
	move.l	D0,A0
	move.l	#-1,184(A0)	| pr_WindowPtr: no more system requesters (insert volume, write protected...)

.no_forbid:
	* align bitplanes
	lea		fg_screen_buffer_1,a0
	bsr		align_8
	move.l	a0,fg_screen_data_1
	move.l	a0,fg_drawed_screen_ptr
	move.l	a0,fg_displayed_screen_ptr
	
	lea		bg_screen_buffer_1,a0
	bsr		align_8
	move.l	a0,bg_drawed_screen_ptr
	
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	lea		fg_screen_buffer_2,a0
	bsr		align_8
	move.l	a0,fg_screen_data_2
	move.l	a0,fg_displayed_screen_ptr
	.endif
	

	move.l	dip_switch_start_course(pc),d0
	move.b	d0,start_level_flag
	
	move.b	dip_switch_start_lives+3(pc),d1
	bne.b	1f
	moveq	#1,d1	| 3 lives is default
1:
	addq	#1,d1
	* DSW 0 = 2 lives
	lea		lives_table(pc),a0
	move.b	(a0,d1.w),dip_switches_1
	
	
	move.l	misc_options,d1
	btst	#0,d1
	*sne		hard_bags_flag
	btst	#1,d1
	beq.b	0f
	bset	#5,d0
0:
	btst	#2,d1
	beq.b	0f
	bset	#6,d0
0:
	.ifndef	RELEASE
	btst	#31,d1
	sne		break_at_startup_flag
	.endif
	
	move.b	d0,dip_switches_2


	

	move.l	cheat_flags,d0
	btst	#0,d0
	beq.b	0f
	bset	#6,dip_switches_2
0:
	btst	#1,d0
	sne		infinite_lives_flag
	btst	#2,d0
	sne		infinite_time_flag

	move.l	cheat_flags,d0
	btst	#3,d0
	beq.b	0f
	bset	#5,dip_switches_2
0:
	
	jsr	 _detect_controller_types 
	clr.b	controller_joypad_0
	clr.b	controller_joypad_1

	jra		demo_game

lives_table:
	.byte	3,2,1,1,0
	.align	2

* so memory is 8-aligned (not trusting .align directives)
align_8:
	add.w	#0x10,a0
	move.l	a0,d0
	and.b	#0xF8,d0
	move.l	d0,a0
	rts
	
* < D0: bcpl string (with leading size byte)
* < A1: dest C string
bcpl_arg_string_copy:
    movem.l D0-D2/A0-A1,-(a7)
	lsl.l	#2,d0
	moveq.l	#0,d2
    move.l  d0,a0
	move.b	(a0)+,d2	| size
	beq.b	1f
	subq	#1,d2
0:
	move.b	(a0)+,(a1)+
	dbf		d2,0b
1:
    movem.l (a7)+,D0-D2/A0-A1
    rts


bcpl_string_to_int:
    movem.l A0/A1,-(a7)
    lea temp_filename_buffer(pc),a1
    bsr bcpl_arg_string_copy
    * convert to integer
    move.l  a1,a0
    * < A0: pointer on C string
    * > D0: value
    * > D1: -1 if ok, position of the string if error
    bsr parse_integer
    movem.l  (a7)+,a0/a1
	rts
	
* parse integer from string
* < A0: pointer on C string
* > D0: value
* > D1: -1 if ok, position of the string if error
parse_integer:
    movem.l  d2/d3,-(a7)
    * go to end of string
    moveq.l #-1,d1
.loop1:
    addq.l  #1,d1
    tst.b   (a0,d1.w)
    bne.b   .loop1
    * d1 is the number of chars
    moveq.l #0,d0
    moveq.l #0,d2
    subq.l  #2,d1   | 10th power minus 1
.loop2:
    move.b  (a0)+,d2
    beq.b   .out
    
    cmp.b   #32,d2
    beq.b   .skip
    sub.b   #48,d2
    bcs.b   .error
    cmp.b   #10,d2
    bcc.b   .error
    move.w  d1,d3
    bmi.b   .doadd
.muloop:
    mulu    #10,d2
    dbf d3,.muloop
.doadd:
    add.l   d2,d0
.skip:
    subq.l  #1,d1
    bra.b   .loop2
.out:    
    movem.l  (a7)+,d2/d3
    rts
.error:
    moveq.l #0,d0
    bra.b   .error
	
    * thanks Toni for this 1.3 read argument code
BCPL_RdArgs = 78
	
	* a1 = pointer to result array. Must be LONG aligned!
	* a0 = formatting string. BSTR!
	* d0 = size of result array (number of LONGs)
get_args_BCPL:
	movem.l d2/d3/d4,-(sp)
	move.l d0,d3
	moveq #BCPL_RdArgs,d0
	move.l a0,d1
	lsr.l #2,d1
	move.l a1,d2
	lsr.l #2,d2
	moveq #0,d4
	bsr.s call_bcpl
	movem.l (sp)+,d2/d3/d4
	rts

	* d0 = gv index
	* d1-d4 = bcpl parms

BCPL_STACK = 3000

call_bcpl:
	movem.l d2-d7/a2-a6,-(sp)

	move.l d0,d6
	move.l d1,d5

	move.l 4.w,a6
	move.l	_dosbase(pc),a5


	sub.l a1,a1
	jsr	_LVOFindTask(a6)
	move.l d0,a4

	* allocate BCPL stack
	move.l #BCPL_STACK,d0
	move.l #65536+1,d1
	jsr	_LVOAllocMem(a6)
	move.l d0,d7
	beq.s 0f
	
	movem.l d7/a5/a6,-(sp)

	moveq #0,d0
	move.l d5,d1
	sub.l a0,a0
	move.l d7,a1
	lea 3*4(a1),a1
	move.l 136(a4),a2
	lsl.w #2,d6
	move.l 0(a2,d6.w),a4
	movem.l 46(a5),a5/a6
	jsr (a5) | call bcpl!
	
	movem.l (sp)+,d7/a5/a6

0:
	move.l d7,a1
	move.l #BCPL_STACK,d0
	jsr	_LVOFreeMem(a6)


	movem.l (sp)+,d2-d7/a2-a6
	rts

* change return address from vblank
* D0: return address (0: no change)
osd_set_vblank_return_address:
	move.l	d0,return_address
	rts
	
get_hiscore_name:
    lea normal_hiscorename,a0
	rts
	
load_highscores:
	bsr.b		get_hiscore_name
    move.l  _resload(pc),d0
    bne.b   1f

    move.l  _dosbase(pc),a6
    move.l  a0,d1
    move.l  #1005,d2
    jsr     (_LVOOpen,a6)
    move.l  d0,d1
    beq.b   1f
    move.l  d1,d4
    move.l  #SCORE_FILE_SIZE,d3
    move.l  #high_score_buffer,d2
    jsr (_LVORead,a6)
    move.l  d4,d1
    jsr (_LVOClose,a6)   
	st.b	highscore_loaded
1:
    rts

save_highscores:
	tst.l	_resload
	bne.b	1f
    tst.b   highscore_needs_saving
    beq.b   1f
    move.l  _dosbase(pc),a6
	bsr.b		get_hiscore_name
    move.l  a0,d1
    move.l  #1006,d2
    jsr     (_LVOOpen,a6)
    move.l  d0,d1
    beq.b   1f
    move.l  d1,d4
    move.l  #SCORE_FILE_SIZE,d3
    move.l  #high_score_buffer,d2
    jsr (_LVOWrite,a6)
    move.l  d4,d1
    jsr (_LVOClose,a6)   
1:	
    rts
    
	


demo_game:
		move		#0x4000,_custom+intena						| disable interrupts
		move		#0x7FFF,_custom+intreq						| ack all interrupts
		bsr			platform_init					| amiga-specific init
		
0:	
		jmp			mpatrol_reset					| pass control to the mpatrol core
		
	
* just in case some hardware calls nmi
_nmi:
	move.w	#0x7FFF,_custom+intreq
	move.w	#0x7FFF,_custom+intreq
	rts
	
_vblank:
    movem.l d0-d7/a0-a6,-(a7)
	lea		_custom,a5
	move.w	(intreqr,a5),d0
	btst	#5,d0
	beq.b		1f

	move.l	_joypad_state(pc),d1
	moveq	#1,d0
	jsr	_read_joystick
	move.l	d0,_joypad_state
	
	* CD32 "play" is disabled but it's free to read
	* 3rd button on a Sega 3-button so 3rd button is pause
	btst	#JPB_BTN_PLAY,d0
	beq.b	0f
	btst	#JPB_BTN_PLAY,d1
	bne.b	0f
	bsr		toggle_pause
0:
	* here music doesn't loop. We have to stop it when it ends
	move.w	music_tick,d1
	beq.b	13f
	
	subq	#1,d1

	move.w	d1,music_tick
	bne.b	13f
	jbsr		osd_sound_stop
13:
	
	* ack vbl twice (040/pistorm bug)
	move.w	#0x20,(intreq,a5)
	move.w	#0x20,(intreq,a5)	
	jra	3f
1:
	* has to be copper
	* we're going to ack copper interrupt now
	* do it twice (040/pistorm bug)
	move.w	#0x10,(intreq,a5)
	move.w	#0x10,(intreq,a5)
	
	* set now the green & blue background lines. We used to set them
	* in the mountain blit routine but it conflicts with double buffering
	* we have to store previous values and set them now
	
	tst.b	background_layer_control_E1C5
	beq.b	0f
	* mountains are active: set colors
	bsr		set_mountain_dynamic_colors
0:

	
	tst.b	pause_flag
	bne.b	23f

	subq.w	#1,delay_timer
		

	* declare that we're in interrupt mode so osd_disable_interrupts/osd_enable_interrupts
	* also set SR accordingly
	st.b	interrupt_mode
0:
	jbsr		mpatrol_irq
	* re-set SR to 0x2300, game calls osd_enable_interrupts from here and if
	* something is too slow, then game crashes/trashes display because of re-entering
	* in IRQ! At least with this it just slows down
	*
	* we update the graphics now so it's not possible that mpatrol_irq interrupts
	* itself in the short time of the computations
	move.w	#0x2300,SR
	clr.b	interrupt_mode
	* AGA/AA: fmode=3 allows much faster blitter operation
	* allowing 50 fps without a hitch :)

	bsr		really_update_sprites
	
	.ifne  OPT_ENABLE_DOUBLE_BUFFERING
	jbsr	is_game_over_displayed
	beq.b	23f				| avoid nasty blinking effect when GAME OVER
	bsr		switch_screen_buffers
	.endif
23:
	* don't blit, but update hw sprites as it doesn't cost a lot
	bsr		really_update_hardware_sprites

	* now we check copper interrupt again
	move.w	_custom+intreqr,d0
	btst	#4,d0
	beq.b	3f		| clear: ok
	* copper interrupt has been called, which means that
	* rendering was so slow that we couldn't cope within a frame
	* skip a tick and ack again, we lose one update frame
	addq.b	#ONE_TICK,vb_ticks_count
	move.w	#0x10,_custom+intreq
3:
    movem.l (a7)+,d0-d7/a0-a6
	tst.l	return_address
	beq.b	4f
	move.l	return_address,(2,a7)		| change return address
	clr.l	return_address				| just for this time
4:
    rte
	
	
osd_blitz:
	blitz
	rts
	
osd_break:
	* sends a WinUAE command to enter WinUAE debugger
	.ifndef	RELEASE
	move.l	D0,-(a7)
	pea     0.w
	* Normally it would point to where the result of the command is written, but since the last parameter (first pushed)
	* indicating the number of bytes to write is 0, nothing is written.
	pea     0.w	
	pea     1003f-1002f
	pea     1002f(pc)
	pea     -1.w
	pea     82.w
	jsr     0xf0ff60
	lea     24(sp),sp
	move.l	(a7)+,d0
	.endif
    rts
		
1002: .asciz    "AKS_ENTERDEBUGGER 1"
1003:
        .align	2

	

* < D0: number of 1/60Hz ticks
* can work with interrupts enabled or disabled
osd_wait:
	move.w	d0,delay_timer
	**jbsr	osd_is_vblank_interrupt_enabled
	tst.w	d0
	jne		2f
	* interrupts are disabled: timer isn't going to change
	* wait using vertical blank interrupt request (we don't need it!)
	clr.w	one_out_of_five
0:
	move.w	#0x20,_custom+intreq
	move.w	#0x20,_custom+intreq
1:
	move.w	_custom+intreqr,d0
	btst	#5,d0
	beq.b	1b
	addq.w	#1,one_out_of_five
	cmp.w	#5,one_out_of_five
	bne.b	5f
	subq.w	#1,delay_timer	
	clr.w	one_out_of_five
5:
	subq.w	#1,delay_timer
	beq.b	4f
	bpl.b	0b
4:
	rts
	
2:
	tst.w	delay_timer
	bne.b	2b
	rts

* < Z=1 if title is displayed
is_title_displayed:
	cmp.b	#0xB5,bg_videoram+0x149
	rts


* < Z=1 if game over is displayed
is_game_over_displayed:
	move.l	a1,-(a7)
	lea		bg_videoram,A1
	cmp.b	#0x47,(0x20C,a1)
	movem.l	(a7)+,a1
	rts
	
* < Z=1 if moonbase is displayed (rightmost tile still present)
is_moonbase_displayed:
	move.l	a1,-(a7)
	lea		bg_videoram,A1
	cmp.b	#0x8C,(0x373,a1)
	movem.l	(a7)+,a1
	rts
	
* brutally redraw everything

refresh_tiles:
	move.w	#0x3FF,d2
	moveq	#0,d7
	lea		bg_videoram,a0
	lea		bg_colorram,a1
0:
	move.b	(a0)+,d0
	move.b	(a1)+,d1
	movem.l	a0/a1/d7/d2,-(a7)
	jbsr		update_bg_tile
	movem.l	(a7)+,a0/a1/d7/d2
	addq.w	#1,d7
	dbf		d2,0b
	
	rts
	
clear_background:
	
	tst.b	background_cleared_flag
	beq.b	0f
	* already cleared: don't redo it
	rts
0:
	movem.l	d0-d7/A0-A6,-(a7)
	bsr		reset_dynamic_colors
	
	bsr		really_clear_background
	st		background_cleared_flag
	WAIT_BLIT
	bsr		refresh_tiles
	movem.l	(A7)+,d0-d7/A0-A6
	rts
really_clear_background:	
	lea		_custom,a5
	* compute height
	moveq	#0,d1
	tst.b	previous_blue_layer_y
	beq.b	0f		| no previous Y means no clear!
	move.w	#Y_MAX,d4
	*sub.w	d1,d4
	* now D4 is the full height to clear
	move	#NB_PLAYFIELD_PLANES,d3
	moveq	#34,d2			| width = 32 (all screen width)
	moveq	#0,d0			| X=0 (all screen)
	move.l	fg_drawed_screen_ptr(pc),a1
	movem.l	d0-d4/A2-A6,-(a7)
	jbsr		clear_planes_any_blitter_internal
	movem.l	(A7)+,d0-d4/A2-A6
	move.l	fg_displayed_screen_ptr(pc),a1
	jbsr		clear_planes_any_blitter_internal
	clr.b	previous_blue_layer_y   | only done once!
0:
	

	
	
	rts
	
* < A0: 
update_background:
	move.l	a0,a2		| a2 points to shadow mem E1C0
	* don't update scroll if title displayed and the values are the same as before
	jbsr	is_title_displayed
	beq.b	1f
	jbsr	is_game_over_displayed
	bne.b	0f
	rts
0:

	lea		previous_values(pc),a1
	cmp.b	(a0)+,(a1)+
	beq.b	1f			| force update if ground is not moving
	moveq	#5,d0		| 5 values to compare
0:
	cmp.b	(a0)+,(a1)+
	bne.b	1f			| only update if values have changed
	dbf		d0,0b
	rts
1:
	moveq	#0,d0     | X position of blue layer (0-256)
	moveq	#0,d1     | X position of green layer (0-256)
	moveq	#0,d2     | Y position of blue layer
	moveq	#0,d3     | Y position of green layer
	moveq	#0,d4     | layer control (0: no layers)
	moveq	#0,d5     | X position of ground layer
	
	lea		previous_values(pc),a1
	move.b	(a2)+,d5
	move.b	d5,(a1)+	| ground layer
	move.b	(a2)+,d1	| green layer X
	move.b	d1,(a1)+
	move.b	(a2)+,d0	| blue layer X
	move.b	d0,(a1)+
	move.b	(a2)+,d3    | green layer Y
	beq.b	0f	
	move.b	(a1),previous_green_layer_y
0:
	move.b	d3,(a1)+
	move.b	(a2)+,d2     | blue layer Y
	move.b	d2,(a1)+
	move.b	(a2)+,d4	 | layer control
	move.b	d4,(a1)
	jeq		clear_background	| layer control = 0 + ground was moving: clear
	
	not.b	d0
	not.b	d1
	not.b	d5
	* only display if Y != 0
	tst.b	d2
	jne		0f
	
	tst.b	previous_blue_layer_y
	beq.b	1f

	move.b	d2,previous_blue_layer_y
	* Y just went 0: no more mountains or game playfield (only status text)
	rts
0:
	tst.b	previous_blue_layer_y
	bne.b	2f
	* was previously at 0: screen switch to mountains display
	* we have to re-set bobs palette, and also clear remaining tile shit
	movem.w	d0-d5,-(a7)
	bsr		really_clear_background
	movem.w	(a7)+,d0-d5	
	bsr		load_bobs_palette_in_playfield_copperlist
	jra		23f
2:
	move.b	previous_blue_layer_y,d6
	sub.b	d2,d6
	jpl		22f
	neg.b	d6
22:
	cmp.b	#2,d6
	jcs		23f
	* more diff than 2: brutal Y change: we have to clear the top of screen
	* (happens when player killed after changing terrain height, and last
	* checkpoint is on some other terrain height, rare but happens)
	movem.w	d0-d5,-(a7)
	bsr		really_clear_background
	movem.w	(a7)+,d0-d5
23:
	move.b	d2,previous_blue_layer_y
	jra		blit_scrollable_layers
1:
	rts
	
previous_values:
	ds.b	6
	
previous_blue_layer_y:
	.byte	0
previous_green_layer_y:
	.byte	0
	.align	2
	
* < A0: pointer on sprite shadow zone E100
* length: 256 bytes for 64 max sprites on screen (48 for this game!)
* there seem to be 4 sprite blocks of 0x40 bytes
* in each block, first sprites have priority
* so top priority sprite is the one with offset 0xF0
* last priority sprite is the one with offset 0x3C
* as it's drawn first
* ATM let's not worry about that. Mixing bobs & sprites
* will cause us priority issues anyway

osd_update_sprites:
	* first pre-filter/remove stuff (for instance if too many jeep wheels
	* when exploding
	movem.l	a0-a6/d0-d7,-(a7)

	clr.b	nb_displayed_wheels
	clr.b	nb_displayed_ships
	clr.b	nb_displayed_rocks
	lea		sprite_registers(pc),a1
	lea		hardware_sprite_flag_table,a2
	move.w	#NB_TARGET_SPRITES-1,d7
	moveq	#0,d0
0:
	move.b	(TARGET_SPRITE_Y,a0),d1
	jeq		ignore_sprite
	move.b	(TARGET_SPRITE_CODE,a0),d0
	move.b	(a2,d0.w),d3
	beq.b	2f			| not a hardware sprite, skip
	
* jeep wheels are no longer hw sprites
*	cmp.b	#5,d0
*	bcs.b	1f
*	cmp.b	#9,d0
*	bcc.b	1f
*	* jeep wheel: count how many we have
*	* briefly when the jeep explodes there are 6 wheels
*	* which is too much for the sprite engine to handle
*	* (and it's not visible anyway)
*	move.b	nb_displayed_wheels,d0
*	addq.b	#1,d0
*	move.b	d0,nb_displayed_wheels
*	
*	cmp.b	#4,d0
*	bcc.b	ignore_sprite
*	bra.b	2f
*1:
	* now sprites with bob backups
	cmp.b	#BB_SHIP,d3
	bcs.b	2f				| not a hardware sprite
*	jne	20f
	* count UFOs
	* UFO: if too low, convert to bob to avoid conflict
	not.b	d1		| convert to real coord
	cmp.b	#SPRITE_Y_SPLIT_LIMIT-16,d1
	bcc.b	convert_to_bob		| over this Y, HW sprite conflicts with lower part sprites
	
	* count how many we have
	move.b	nb_displayed_ships,d0
	addq.b	#1,d0
	move.b	d0,nb_displayed_ships
	cmp.b	#NB_HOST_SPRITES+1,d0
	bcc.b	convert_to_bob	| if already 8 sprites, switch to bob copy
*	bra.b	2f
*20:
*	* other case is rolling rocks: no explosions from ufos can happen, no tanks
*	* when they're there so we can use the slots for 4 rocks
*	move.b	nb_displayed_rocks,d0
*	addq.b	#1,d0
*	move.b	d0,nb_displayed_rocks
*	cmp.b	#4+1,d0			| 3 wheels use 4 sprite slots
*	bcc.b	convert_to_bob	| if already 4 rock sprites, switch to bob copy
2:
	move.l	(a0)+,(a1)+		| brutal copy
	dbf		d7,0b
3:
	
	* copy 6 more values (scroll registers)
	move.l	(a0)+,(a1)+
	move.w	(a0)+,(a1)+
	
	movem.l	(a7)+,a0-a6/d0-d7
	rts
	
convert_to_bob:
	* more than 8 ships: convert to sprite, now it's a bob
	* (bob mirror has been conveniently created 128 slots after)
	add.b	#0x80,(TARGET_SPRITE_CODE,a0)
	bra.b	2b
	
ignore_sprite:
	addq.w	#4,a0
	clr.l	(a1)+
	dbf		d7,0b
	bra.b	3b

really_update_hardware_sprites:

	lea		sprite_registers,a0
	st.b	do_upper_part
	bsr		update_hardware_sprites
	.ifne	OPT_ENABLE_MULTIPLEXED_SPRITES
	lea		sprite_registers,a0
	clr.b	do_upper_part
	bsr		update_hardware_sprites
	.endif

	rts
	
is_game_playing:
	btst.b	#7,game_status_bits_E046
	rts
	

really_update_sprites:
	jbsr		really_update_hardware_sprites
	lea		sprite_registers,a0
	bsr		update_bobs
	

	rts
	
	
* SPRITE_Y_SPLIT_LIMIT has to be carefully computed from copper pos
* where second sprite write is done

update_hardware_sprites:
	* clear host sprites
	moveq	#NB_HOST_SPRITES-1,d0

	lea		sprite_table,a4
	lea		host_sprites(pc),a2
0:
	clr.b	(SPRITE_X,a2)	| clear X is enough to know it's free
	st.b	(SPRITE_CLUT,a2) | invalid clut
	addq.w	#SPRITE_SIZEOF,a2
	dbf		d0,0b

	* check active sprites, we'll disable the sprites that aren't active anymore
	moveq	#NB_TARGET_SPRITES-1,d7
1:
	* code = 0 and clut = 0 => disabled
	moveq	#0,d2
	move.b	(TARGET_SPRITE_CODE,a0),d2
	beq.b	2f
	bmi.b	2f			| fake sprite converted to bob => skip
	* check if real/attached sprite
	* this part is needed when mixing sprites & bobs
	* or when using "attached" sprites
	* (my definition of attached sprites differs from
	* the Amiga HW attached sprites which I don't use)
	* here I just save a lot of sprites by displaying
	* one 16x32 sprite instead of 2 16x16 for some objects
	* like for instance the jeep or explosions
	
	* the fact that there's 0 isn't a problem either
	* in this mixed sprite/bob port as it is probably
	* a bob. For games like Bagman & Pengo, there are no
	* bobs, so if a sprite doesn't exist, we have to signal it
	* but not here. Here the filtering has to be done early
	* else we'll allocate a sprite and figure out it's not
	* a sprite, but it will be too late!

	moveq	#0,d3
	move.w	d2,d4
	lsl.w	#4,d4		| times 16
	tst.l	(a4,d4.w)	| test pointer
	bmi.b	2f			| attached: skip
	beq.b	2f			| not a sprite: skip
	
	move.b	(TARGET_SPRITE_Y,a0),d1  | sprite Y
	beq.b	2f			| Y set to 0: not shown
	not.b	d1			| negate Y: get normal Y coord!
	
	.ifne	OPT_ENABLE_MULTIPLEXED_SPRITES
	
	* depending on upper or lower part, filter sprite
	tst.b	do_upper_part
	beq.b	21f
	* higher part
	cmp.b	#SPRITE_Y_SPLIT_LIMIT,d1
	bcc.b	2f		| low sprite: skip
	bra.b	22f
21:
	* lower part
	cmp.b	#SPRITE_Y_SPLIT_LIMIT,d1
	bcs.b	2f		| high sprite: skip
22:
	.endif
	
*	cmp.b	#255,d1
*	beq.b	2f			| Y set to 255: not shown	
	move.b	(TARGET_SPRITE_X,a0),d0  | sprite X

	.ifne	SPRITE_Y_CORRECTION
	add.w	#SPRITE_Y_CORRECTION,d1
	.endif
	.ifne	SPRITE_X_CORRECTION
	add.w	#SPRITE_X_CORRECTION,d0
	.endif


	move.b	(TARGET_SPRITE_ATTRIBUTES,a0),d3
*	btst	#7,d3
* test y-flip (happens, ex hole-making ufos)
*	beq.b	23f
*	blitz
*23:

* < D2: sprite code & flags
* < D3: sprite color (clut index)
* > D6: allocated sprite index

	* sprite active: allocate a sprite in host table
	* it HAS to succeed (in Pengo it did, here I'm less sure)
	bsr		alloc_sprite
2:
	addq.w	#4,a0
	dbf		d7,1b
	
	***********************************************
	* all sprites are allocated: now display them *
	***********************************************
	
	lea		host_sprites(pc),a2		| input structure
	lea		sprites_upper_part,a3				| copperlist
	.ifne	OPT_ENABLE_MULTIPLEXED_SPRITES
	tst.b	do_upper_part
	bne.b	222f
	lea		sprites_lower_part,a3
222:
	.endif
	
	moveq	#0,d6
10:
	moveq	#0,d1
	move.b	(SPRITE_Y,a2),d1		| Y=0 can happen when X != 0
	beq.b	101f
	move.b	(SPRITE_X,a2),d0
	bne.b	20f
101:
	* slot free: replace sprite by blank
	* this doesn't allow that a sprite crosses the SPRITE_Y_SPLIT_LIMIT
	* boundary but in that case we'll switch for a BOB
	* (there are potentially too many UFO ships for sprites anyway)
	lea	blank_sprite_table,a1
	.ifne	OPT_ENABLE_MULTIPLEXED_SPRITES
	tst.b	do_upper_part
	beq.b	11f
	add.w	#8*4,a1		| lower part blanks
11:
	.endif
	move.w	d6,d4
	add.w	d4,d4
	add.w	d4,d4			| times 4 for offset
	move.l	(a1,d4.w),a5	| fetch relevant blank sprite data
	moveq	#0,D0			
	moveq	#0,D1			| position: X,Y=0
	move.w	#16,d3
	jra		220f			| and treat that like a 16-high sprite
20:
	* lookup sprite code
	
	and.w	#0xFF,d0
	moveq	#0,d2
	move.b	(SPRITE_CODE,a2),d2
		
	move.w	d2,d4
	lsl.w	#4,d4
	move.b	(SPRITE_CLUT,a2),d3
	btst	#6,d3		| flip x?
	beq.b	25f
	addq.w	#4,d4		| other sprite
25:
	btst	#7,d3		| flip y?
	beq.b	251f
	addq.w	#8,d4		| other sprite
251:
	move.l	(a4,d4.w),d4	| get pointer
	.ifndef	RELEASE
	bne.b	26f
	* sprite doesn't exist (flip bit set but no flipped image)
	blitz
	move.b	d1,d1
	move.b	d2,d2
	jra		30f
26:
	.endif
	
	move.l	d4,a5
	move.w	d6,d4					| load sprite index
	add.w	d4,d4
	add.w	d4,d4					| sprite index times 4 (pointer index)
	move.l	(a5,d4.W),a5			| get buffer for this sprite index


	move.w	(A5)+,d3
	cmp.w	#16,d3
	bne.b	221f
220:
	bsr		store_sprite_pos_16
	bra.b	223f
221:
	cmp.w	#32,d3
	beq.b	222f
	blitz		| should not happen, values can be 16 or 32 (sanity check!)
222:
	bsr		store_sprite_pos_32
223:

	.ifeq	OPT_ENABLE_MULTIPLEXED_SPRITES
	* just store control word
	move.l	d0,(a5)
	.else
	* multiplexed
	tst.b	do_upper_part
	beq.b	224f
	* store control word
	move.l	d0,(a5)
	* multiplexed: we have to store upper part pic pointer end control word
	* in a buffer to link to it, d4 is the index of sprite * 4 already
	move.l	a5,-(a7)
	* we add 4+64 or 4+128 (32) to skip control word+sprite data
	add.w	d3,d3
	add.w	d3,d3	| 16*4 or 32*4
	addq	#4,d3
	add.w	d3,a5
	* we used to clear previous control word (needed if no lower sprite)
	* but doing so makes lower sprites blink when activated
	* anyway we make lower sprites point on blanks when not used so
	* we can leave that untouched, let the lower sprite write it
	lea		upper_sprite_buffers(pc),a1
	move.l	a5,(a1,d4.w)	| store pointer on control word for lower matching sprite
	move.l	(a7)+,a5
	bra.b	225f
224:
	* sprite lower part: it doesn't work if we store the control word in A5, it's too late
	* as upper sprite has finished rendering and stumbled on 0 control word. We have to set
	* this control word on the upper sprite end control word to enable sprite "chaining"
	* and store sprite buffer without control word in lower part copperlist!
	*
	* big thanks to Ross for the explanation
	*
	* what happens is: sprite DMA stumbles on non-zero control word and waits for the beam to
	* reach the given X/Y pos. In the meantime, we have plenty of time to change sprite pointer
	* so when sprite DMA resumes, the pointer points on the lower sprite data!
	*
	addq	#4,a5			| skip second sprite control word
	lea		upper_sprite_buffers(pc),a1
	move.l	(a1,d4.w),a1
	move.l	d0,(a1)			| store control word in the end of upper sprite data
225:
	.endif
	move.l	a5,d0		| sprite pointer with or without control word
	
	* set colors
	lea		sprite_cluts+2,a6
	moveq	#0,d3
	move.b	(SPRITE_CLUT,a2),d3
	bmi.b	25f			| blank sprite with invalid clut: skip color set!
	and.b	#0xF,d3		| mask color only, ignore flip bits
	lsl.w	#3,d3		| times 8

	add.w	d3,a6
	* check if CLUT doesn't contain only color zero
	* (we may as well cache the values in spare registers)
	move.l	(a6)+,d3
	move.w	(a6)+,d7
*	bne.b	24f
*	tst.l	d3
*	bne.b	24f
*	* all black sprites would hide mpatrol sprites & tiles
*	* we want to hide them instead (no need to change palette)
*	* inherited from pengo, probably not required
*	move.l	#blank_sprite,d0
*	bra.b	25f
*24:
	* d6 is the sprite index: compute/set proper color
	move.w	d6,d5
	bclr	#0,d5
	add.w	d5,d5
	add.w	d5,d5	| times 4*2
	move.w	d5,d2
	add.w	d2,d2
	lea		sprites_upper_cols+6,a5	| sprite palette + 2 (first color skipped)
	.ifne	OPT_ENABLE_MULTIPLEXED_SPRITES
	tst.b	do_upper_part
	bne.b	241f
	lea		sprites_lower_cols+6,a5	| sprite palette + 2 (first color skipped)
241:
	.endif
	
	add.w	d2,a5
	* copy 3 colors from cached registers into sprite color copperlist
	move.w	d3,(4,a5)
	swap	d3
	move.w	d3,(a5)
	move.w	d7,(8,a5)
25:
	add.w	d4,d4		| index times 8
	* set sprite in copperlist
	move.w	d0,(6,a3,d4.w)
	swap	d0
	move.w	d0,(2,a3,d4.w)	
30:
	* next sprite
	lea		(SPRITE_SIZEOF,a2),a2
	addq	#1,d6
	cmp.w	#NB_HOST_SPRITES,d6
	jne	10b	
	rts

update_bobs:

	move.l	bob_previous_drawed_sprites(pc),a4
	lea		hardware_sprite_flag_table,a6
	lea		_custom,a5
	

	* clear previous positions
	moveq	#NB_TARGET_SPRITES-1,d7
1:
	move.w	(2,a4),d1
	beq.b	11f		| y=0: inactive
	move.w	(a4),d0
	and.w	#0x1F0,d0		| align on 16 lower bound
	* clear area where the sprite was
	move.l	fg_drawed_screen_ptr(pc),a1
	move.w	#4,d2
	moveq	#NB_PLAYFIELD_PLANES,d3
	clr.l	(a4)+ 			| ack deletion
	move.w	(a4),d2			| width in bytes (16 pixels: 4 bytes)
	move.w	(2,a4),d4		| height
	clr.l	(a4)+			| ack deletion
	bsr		clear_planes_any_blitter_internal
	bra.b	12f
11:
	addq	#8,a4
12:
	dbf		d7,1b
	
	* now that we have deleted the bobs, we can update the backgrounds
	move.l	a0,-(a7)
	lea		(0xC0,a0),a0		| shadow for x,y background pos
	bsr		update_background
	move.l	(a7)+,a0
	
    lea _custom,A5
	lea		hardware_sprite_flag_table,a2
	move.l	bob_previous_drawed_sprites(pc),a6
	lea		bob_table,a4
	add.w	#(NB_TARGET_SPRITES-1)*4,a0		| start by the end (drawing priority)
	moveq	#NB_TARGET_SPRITES-1,d7
1:
	* code = 0 and clut = 0 => disabled
	moveq	#0,d2
	move.b	(TARGET_SPRITE_CODE,a0),d2
	jeq	2f
	cmp.b	#1,(a2,d2.w)	| is that a hardware sprite without bob backup?
	jeq	2f					| yes: don't bother!s
	
	
	moveq	#0,d1
	moveq	#0,d3
	moveq	#0,d0

	move.w	d2,d4
	lsl.w	#3,d4		| left+right
	btst.b	#6,(TARGET_SPRITE_ATTRIBUTES,a0)
	beq.b	0f
	addq	#4,d4		| right bob
0:
	move.l	(a4,d4.w),d4	| test pointer
	jmi		2f			| legal but skipped
	bne.b	11f
	.ifndef	RELEASE
	* not known/registered: we should log that!
	move.b	(TARGET_SPRITE_ATTRIBUTES,a0),d3
	move.w	#0xF00,0xDFF180
	.endif
	bra.b	2f
11:
	move.b	(TARGET_SPRITE_Y,a0),d1  | sprite Y
	beq.b	2f			| Y set to 0: not shown
	not.b	d1
	
	move.b	(TARGET_SPRITE_X,a0),d0  | sprite X
	.ifne	SPRITE_Y_CORRECTION
	add.w	#SPRITE_Y_CORRECTION,d1
	.endif
	.ifne	SPRITE_X_CORRECTION
	add.w	#SPRITE_X_CORRECTION,d0
	.endif

	move.b	(TARGET_SPRITE_ATTRIBUTES,a0),d3
	* todo yflip
	and.b	#0x0F,d3	| get attributes

	* < D2: sprite code & flags
	* < D3: sprite color (clut index)
	
	add.w	d3,d3
	add.w	d3,d3
	move.l	a0,-(a7)
	move.l	d4,a0
	move.l	(8,a0,d3.w),d4	| bitplane pointer list
	move.w	(a0)+,d3		| height
	move.w	(a0)+,d5		| width
	add.w	(a0)+,d1		| add offset to Y
	addq	#2,a0			| reserved
	bne.b	12f
	* bob is valid but wrong clut
	.ifndef	RELEASE
	* not known/registered: we should log that!
	move.l	(a7),a0
	move.b	(TARGET_SPRITE_CODE,a0),d2
	move.b	(TARGET_SPRITE_ATTRIBUTES,a0),d3
	and.b	#0xF,d3	| get attributes
	move.w	#0xFF0,0xDFF180
	.endif
	move.l	(a7)+,a0
	bra.b	2f
12:
	move.l		fg_drawed_screen_ptr(pc),a1
	* D0 and D1 are already set
	move.l	d4,a0	| plane list (+ mask)
	move.l	(NB_PLAYFIELD_PLANES*4,a0),d2
	beq.b	2f		| mask is zero: blank tile => skip
	move.l	d2,a3
	moveq	#0,d2	| no y-clip
	* note down that this bob will have to be erased
	move.w	d0,(a6)+			| store current sprite attributes to previous ones
	move.w	d1,(a6)+			| store current sprite attributes to previous ones
	move.w	d5,(a6)+			| store width
	move.w	d3,(a6)+			| store height
	
	move.w	d5,d2			| width
	moveq	#0,d5			| Y-offset
	move.w	d3,d4			| height
	moveq	#NB_PLAYFIELD_PLANES,d3		| 4 planes
	bsr		blit_planes_any_internal_cookie_cut
	move.l	(a7)+,a0
	bra.b	3f
2:
	addq.w	#8,a6
3:
	subq.w	#4,a0
	dbf		d7,1b
	
	rts


* < A5: custom
* < D0,D1: x,y
* < A1: plane pointer
* < D2: width in bytes (inc. 2 extra for shifting)
* < D4: blit height
* trashes D0-D6
* > A1: even address where blit was done
clear_plane_any_blitter_internal:
	moveq	#1,d3
* < A5: custom
* < D0,D1: x,y
* < A1: foreground plane pointer (often first plane!)
* < D2: width in bytes (inc. 2 extra for shifting)
* < D3: number of planes to clear
* < D4: blit height
* < D7: mask (disabled, -1 set at start)
* trashes D0-D6
clear_planes_any_blitter_internal:
    * pre-compute the maximum of shit here
	move.w	d1,d6
    beq.b   1f    | optim
	* check if y start + height > Y_MAX
	* (ignores case where y = 0, no risk)
	add.w	d4,d6
	sub.w	#Y_MAX,d6
	bmi.b	0f
	* y start + height > Y_MAX: clip height
	sub.w	d6,d4
	beq.b	10f
	bpl.b	0f
10:
	* null or negative height after clipping: out
	rts
0:
    lea mulNB_BYTES_PER_ROW_table(pc),a2
    add.w   d1,d1
    move.w  (a2,d1.w),d1
1:
    move.l  #0x01000000,d5   | minterm useD & rect clear (0xA) 
    move    d0,d6
    beq.b   2f
    MOVEQ #15,D6
    AND.W D0,D6
    and.w   #0x1F0,d0
    lsr.w   #3,d0
    add.w   d0,d1
    LSL.W #8,D6
    LSL.W #4,D6

    swap    d6
    or.l    d6,d5            | add shift
2:   
    add.w   d1,a1       | plane position (always even)

	move.w #NB_BYTES_PER_ROW,d0
    sub.w   d2,d0       | blit width

    lsl.w   #6,d4
    lsr.w   #1,d2
    add.w   d2,d4       | blit height

    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
    * blitter registers set
	.ifdef	VARIABLE_BLITTER_MASKS_AND_MODS
    move.l  d7,bltafwm(a5)
	.endif
	
	move.l d5,bltcon0(a5)	
    move.w  d0,bltdmod(a5)	|D modulo
	
	subq	#1,d3
	beq.b	4f
	subq	#1,d3
3:
	move.l a1,bltdpt(a5)	|destination top left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	lea		(BG_SCREEN_PLANE_SIZE,a1),a1
	WAIT_BLIT
	dbf		d3,3b
4:
	move.l a1,bltdpt(a5)	|destination top left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	
    rts

* what: blits 16x? data on one plane, cookie cut
* args:
* < A0: pointers on 16x? data
* < A1: plane  (40 rows)
* < A3: source mask for cookie cut (16x16)
* < D0: X
* < D1: Y
* < D2: source y-offset
* < D3: height of data
* trashes: D0-D1
blit_planes_cookie_cut_32x:
    lea _custom,A5
	move.w	d2,d5
	move.w	d3,d4
	moveq	#NB_PLAYFIELD_PLANES,d3		| 4 planes
    moveq  #6,d2       | 32 pixels + 2 shift bytes
	jra		blit_planes_any_internal_cookie_cut
* what: blits 16x? data on one plane, cookie cut
* args:
* < A0: pointers on 16x? data
* < A1: plane  (40 rows)
* < A3: source mask for cookie cut (16x16)
* < D0: X
* < D1: Y
* < D2: source y-offset
* < D3: height of data
* trashes: D0-D1
blit_planes_cookie_cut_16x:
    lea _custom,A5
	move.w	d2,d5
	move.w	d3,d4
	moveq	#NB_PLAYFIELD_PLANES,d3		| 4 planes
    moveq  #4,d2       | 16 pixels + 2 shift bytes
* < A5: custom
* < D0.W,D1.W: x,y
* < A0: source (pointer on array of planes)
* < A1: destination fg plane, also background to mix with cookie cut fg plane
* < A3: source mask for cookie cut
* < D2: width in bytes (inc. 2 extra for shifting)
* < D3: number of planes
* < D4: height. If negative, source is copied with negative modulo (flip)
* < D5: y offset for source planes
* < D7: blit mask (not considered, optim, -1 all through the game)
* blit mask set
* returns: start of destination in A1 (computed from old A1+X,Y)
* trashes: a1
blit_planes_any_internal_cookie_cut:
    movem.l d0-d7/a4,-(a7)
    * pre-compute the maximum of shit here
	tst.w	d4
	bpl.b	1f
	sub.w	d4,d1	| pre-add height to d1
	subq.w	#1,d1	| minus one
1:	
	tst	d1
    beq.b   2f    | optim
    lea		mulNB_BYTES_PER_ROW_table,a4
	.ifdef	NO68020
	add.w	d1,d1
    move.w  (a4,d1.w),d1	| y times 40
	.else
    move.w  (a4,d1.w*2),d1	| y times 40
	.endif
2:
	move.w	d5,-(a7)
	moveq	#0,d5
    move.w  #0x0fca,d5    | B+C-A->D cookie cut   
	swap	d5
    move    d0,d6
    beq.b   4f
    lsr.w   #3,d0
	bclr	#0,d0
    and.w   #0xF,d6
	beq.b	3f
    lsl.l   #8,d6
    lsl.l   #4,d6
    or.w    d6,d5            | add shift to mask (bltcon1)
    swap    d6
    clr.w   d6
    or.l    d6,d5            | add shift
3:   
    add.w   d0,d1
4:
    * make offset even. Blitter will ignore odd address
    * but a 68000 CPU doesn't and since we RETURN A1...
    bclr    #0,d1
    add.w   d1,a1       | plane position (D1 < 0x7FFF, 288*40=0x2D00)
	move.w	#NB_BYTES_PER_ROW,d0
	tst.w	d4
	bpl.b	5f
	neg.w	d0
	neg.w	d4    | make d4 positive again
5:
    sub.w   d2,d0       | blit width
    lsl.w   #6,d4
    lsr.w   #1,d2
    add.w   d2,d4       | blit height
    * always the same settings (ATM)

    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
    * blitter registers set

	clr.w bltamod(a5)		|A modulo=bytes to skip between lines
	clr.w bltbmod(a5)		|B modulo=bytes to skip between lines
	move.l d5,bltcon0(a5)	| sets con0 and con1: full cookie cut 2 sources & 1 mask
	move.l	d5,d7			| save bltcon
	move.w	(a7)+,d5
	
    move.w  d0,bltcmod(a5)	|C modulo
    move.w  d0,bltdmod(a5)	|D modulo
					
	add.w	d5,a3			| apply y offset to mask too (y offset looks wrong)
	subq	#1,d3
	beq.b	7f
	subq	#1,d3
6:
	move.l a3,bltapt(a5)	|source graphic top left corner (mask)
	bsr.b	start_process_1_plane
	
	move.l	a1,bltcpt(a5)	|pristine background top (bottom) left corner
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	lea		(BG_SCREEN_PLANE_SIZE,a1),a1
	WAIT_BLIT
	dbf		d3,6b
7:
	move.l a3,bltapt(a5)	|source graphic top left corner (mask)
	bsr.b	start_process_1_plane
	move.l	a1,bltcpt(a5)	|pristine background top (bottom) left corner
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
    
    movem.l (a7)+,d0-d7/a4
    rts
	
start_process_1_plane:
	move.l (a0)+,d0
	beq.b	60f
	move.l	d0,a4
	add.w	d5,a4		| add Y offset
	bra.b	61f
60:
	* source is 0: just apply mask (less bandwidth lost) and change bltcon
	move.l	#0x0BCA0000,d1
	or.l	d6,d1
	move.l	d1,bltcon0(a5)	| sets con0 and con1: C-A->D cookie cut, B fixed
 	clr.w	bltbdat(a5)	|B word is zero
	rts
61:
	* non-zero: set data source & bltcon
	move.l	d7,bltcon0(a5)	| sets con0 and con1: C-A+B->D cookie cut full
	move.l	a4,bltbpt(a5)	|source graphic top left corner
	rts

* uses green_y_end blue_y_end
set_mountain_dynamic_colors:
	* systematically reset dynamic colors as heights can change
	bsr		reset_background_dynamic_colors
	
	move.w	green_y_end,d6			| Y pos to change color 0 for green
	jeq	10f				| in case it's not set
	
	* set copper color 0 to green (color 4 of bobs palette)
	* at the proper row
	lea		color_line_copper,a0
	* Y minus panel Y max times 16 (3 longwords per line in copperlist + wait)
	lea		bobs_palette(pc),a1

	* the line list is not contiguous, we need to check size and skip sprite chunk
	bsr		shift_d6_copper_y
	

	move.w	#color,(A0,d6.w)
	move.w	(8,a1),(2,a0,d6.w)


	* is tweaked to follow terrain_height_in_tiles_E514
	move.w	#DYNAMIC_COPPER_ROWS-2+32,d6
	moveq	#0,d0
	move.b	terrain_height_in_tiles_E514,d0
	lsl.w	#3,d0		| times 8
	sub.w	d0,d6
	bsr		shift_d6_copper_y
	
	* change a dark red color (why not) by dark green used
	* by space plant base. We put that here but we could even
	* put it a few lines below, as the plant base is lower (lowest
	* object). This saves just enough colors for a 16 color playfield
	* display, if we use HW sprites for some objects (shoehorned!!)
	move.w	plant_color_register,(4,a0,d6.w)
	move.w	plant_color,(6,a0,d6.w)
	move.w	blue_y_end,d7
	lsl.w	#4,d7
	
	cmp.w	#DYNAMIC_COPPER_ROWS*16,d7
	bcc.b	10f
	cmp.w	#HALF_DYNAMIC_COPPER_ROWS*16,d7
	bcs.b	9f
	add.w	#SPRITE_COPPERLIST_CHUNK_SIZE,d7
9:

	

	move.w	#color+32,(A0,d7.w)
	move.w	(6,a1),(2,a0,d7.w)
10:	
	rts
	
clear_credits_remaining_bitmap:
	movem.l	d0-a6,-(a7)
	move.w	#Y_MAX-24,d1
	move.w	#16,d4
	move	#NB_PLAYFIELD_PLANES,d3
	moveq	#10,d2			| width = 10
	move.w	#22*8,d0
	move.l	fg_drawed_screen_ptr(pc),a1
	move.l	fg_drawed_screen_ptr(pc),a1
	movem.l	d0-d4/A2-A6,-(a7)
	jbsr		clear_planes_any_blitter_internal
	movem.l	(A7)+,d0-d4/A2-A6
	move.l	fg_displayed_screen_ptr(pc),a1
	jbsr		clear_planes_any_blitter_internal
	movem.l	(A7)+,d0-a6
	rts
	
blit_blue_mountain_strip:
	lea		blue_mountains,a0
	
	move.w	(a0)+,d4		| source height
	move.w	(a0)+,d5		| number of bytes for the image (height * 66)
	move.w	d4,d7
	add.w	d2,d7			| D7=Y position to set blue color as color 0
	
	add.w	d2,d2
	add.w	(a2,d2.w),a1	| adds Y*40
	move.w	d0,d2
	lsr.w	#3,d2
	bclr	#0,d2
	add.w	d2,a0			| adds X/8 to source (destination X = 0)
    move.l  #0x09f00000,d3    | A->D copy, ascending mode
	* blit height
	lsl.w	#6,d4
	add.w	#20,d4		| size: the whole screen
	* insert shifting in D3 bltcon config
	and.w	#0xF,d0		| shifting 0-15
	not.w	d0
	* apply to bltcon (destination)
    swap    d0
    clr.w   d0
    lsl.l   #8,d0
    lsl.l   #4,d0
    or.l    d0,d3
    * always the same settings


    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
    * blitter registers set

	* plane 0
	move.l d3,bltcon0(a5)	| sets con0 and con1
    move.w  #26,bltamod(a5)	|A modulo: 66 bytes per row - 40 used
    move.w  #0,bltdmod(a5)	|D modulo: 0 full line is drawn
	move.l a0,bltapt(a5)	|source graphic top left corner
	move.l a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	add.w	d5,a0			| next source plane
	
	* while it's blitting, let's erase the line above
	bsr		erase_mountain_line
	
	lea		(BG_SCREEN_PLANE_SIZE,a1),a1

    * now just wait for blitter ready to write all registers
	WAIT_BLIT
	* plane 1
	move.l a0,bltapt(a5)	|source graphic top left corner
	move.l a1,bltdpt(a5)	|destination top (bottom) left corner
	* this blits the pale blue layer of the back mountain
	move.w  d4,bltsize(a5)	|rectangle size, starts blit

	add.w	d5,a0			| next source plane

	* while it's blitting, let's erase the line above
	bsr		erase_mountain_line

	lea		(BG_SCREEN_PLANE_SIZE,a1),a1
    * now just wait for blitter ready to write all registers
	move.l  #0x01000000,d5
	WAIT_BLIT
	* plane 2 (all zeroes with the palette we've chosen)
	* we still have to clear it to remove artifacts from green layer
	* but we still save bandwidth
	move.l  d5,bltcon0(a5)   | minterm useD & rect clear (0xA) 
	move.l a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	rts
	
* blit the blue mountains + green layer
* blue mountains is blit using blitter copy
* green mountains is blit using cookie cut over blue mountains
* data is: 2 bitplanes; no blit pad, width = 512 bytes, height: custom
* palette is shared between both layers
* < D0.W: X position of blue layer (0-256)
* < D1.W: X position of green layer (0-256)
* < D2.W: Y position of blue layer
* < D3.W: Y position of green layer
* < D4.B: 0xFB: green mountains, 0xFC: green city, 0: no layers
* < D5.W: X position of the ground layer
*

	
* it also changes black background to the relevant background (blue or green)
blit_scrollable_layers:
	
	addq.b	#BACKGROUND_X_CORRECTION,d0		| adjust vs MAME
	addq.b	#BACKGROUND_X_CORRECTION,d1		| adjust vs MAME
	
	* background is going to be non-zero
	tst.b		background_cleared_flag
	beq.b	0f
	clr.b		background_cleared_flag
	* scrollable layer just enabled
	* "CREDIT xx" string is still in the bottom right corner
	* remove it
	bsr		clear_credits_remaining_bitmap
0:
	sub.w	#PANEL_MAX_Y+8,d2
	sub.w	#PANEL_MAX_Y+8,d3
	lea		_custom,A5
	move.l	fg_drawed_screen_ptr(pc),a1
	add.w	#(PANEL_MAX_Y+8)*NB_BYTES_PER_ROW,a1
	lea		mulNB_BYTES_PER_ROW_table,a2
	movem.l	d0-d5/a1,-(a7)
	
	***********
	* blue part
	***********
	


	******************
	* green part
	******************
	
	movem.l	(a7),d0-d5/a1
	bsr		get_green_mountains_data
	
	* clear the lower part of the mountain else some dark green remains
	* and it's ugly. We'll optimize as most of the time blue mountain erases
	* green mountain top, but at lowest level it can't erase all
	

	
	move.w	d3,d2	| same as blue now
	move.w	d1,d0

	move.w	(a0)+,d4		| source height
	move.w	d4,d6
	add.w	d3,d6			| Y pos to change color 0 for green
	move.w	d6,green_y_end		| save green Y end
	move.w	d7,blue_y_end		| save blue Y end

	
	move.w	(a0)+,d5		| number of bytes for the plane (height * 66)

	
	add.w	d2,d2
	add.w	(a2,d2.w),a1	| adds Y*40
	move.w	d0,d2
	lsr.w	#3,d2
	bclr	#0,d2
	add.w	d2,a0			| adds X/16 to source (destination X = 0)
	move.l	#0x09f00000,d3		| brutal copy

	* blit height
	lsl.w	#6,d4
	add.w	#20,d4		| size: the whole screen
	* insert shifting in D3 bltcon config
	and.w	#0xF,d0		| shifting 0-15
	not.w	d0
	* apply to bltcon (destination & mask)
    swap    d0
    clr.w   d0
    lsl.l   #8,d0
    lsl.l   #4,d0
    or.l    d0,d3
	swap	d3
	or.l	d0,d3
	swap	d3
	
    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
    * blitter registers set

	* plane 0
	move.l d3,bltcon0(a5)	| sets con0 and con1
    move.w  #26,bltamod(a5)	|A (mask) modulo: 66 bytes per row - 40 used
    move.w  #26,bltbmod(a5)	|B (data) modulo: 66 bytes per row - 40 used
    move.w  #0,bltcmod(a5)	|D modulo: 0 full line is drawn
    move.w  #0,bltdmod(a5)	|D modulo: 0 full line is drawn

	move.l a0,bltapt(a5)	|source graphic top left corner (mask)
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	add.w	d5,a0			| next source plane
	lea		(BG_SCREEN_PLANE_SIZE,a1),a1

    * now just wait for blitter ready to write all registers
	WAIT_BLIT
	* plane 1
	move.l a0,bltapt(a5)	|source graphic top left corner
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit

	add.w	d5,a0			| next source plane
	lea		(BG_SCREEN_PLANE_SIZE,a1),a1
    * now just wait for blitter ready to write all registers
	WAIT_BLIT
	* plane 2
	move.l a0,bltapt(a5)	|source graphic top left corner
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit

	movem.l	(a7)+,d0-d5/a1

	
	
	* hack: if title "moon patrol" is shown on screen, we have to redraw it
	* as the mountains share the same layer and have clobbered it partially
	jbsr		is_title_displayed
	jne	0f
	lea		title_bitmap,a0
	move.l	fg_drawed_screen_ptr,a1
	add.w	#TITLE_X/8+(TITLE_Y*NB_BYTES_PER_ROW),a1	| fixed position
	
    move.l  #0x0fca0000,d3    | B+C-A->D cookie cut, no shift
	move.w	#(TITLE_WIDTH/8)*TITLE_HEIGHT,d5	| plane size
	* compute mask
	move.l	a0,a3
	move.w	d5,d4
	lsl.w	#2,d4
	add.w	d4,a3		| plus 4 bitplanes
	* blit height + width, hardcoded
	move.w	#TITLE_HEIGHT*64+TITLE_WIDTH/16,d4
    * always the same settings
	move.l	#0x09f00000,d6
    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    * blitter registers set

	* planes 0-2
	move.l d3,bltcon0(a5)	| sets con0 and con1
    move.w  #0,bltamod(a5)	|A (mask) modulo: object data is contiguous
    move.w  #0,bltbmod(a5)	|B (data) modulo: object data is contiguous
    move.w  #NB_BYTES_PER_ROW-TITLE_WIDTH/8,bltcmod(a5)	|C modulo
    move.w  #NB_BYTES_PER_ROW-TITLE_WIDTH/8,bltdmod(a5)	|D modulo
	move.w	#NB_PLAYFIELD_PLANES-2,d3
1:
	move.l a3,bltapt(a5)	|source graphic top left corner (mask)
	move.l a0,bltbpt(a5)	|source graphic top left corner
	move.l	a1,bltcpt(a5)	|pristine background top (bottom) left corner
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	add.w	d5,a0			| next source plane
	lea		(BG_SCREEN_PLANE_SIZE,a1),a1

    * now just wait for blitter ready to write all registers
	WAIT_BLIT
	dbf		d3,1b
	
	* last plane, no need to wait, no need for cookie cut
	move.l  d6,bltcon0(a5)    | A->D copy, ascending mode
	move.l 	a0,bltapt(a5)	|source graphic top left corner (could be omitted!)
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit

0:
	rts

get_green_mountains_data:
	lea		green_mountains,a0
	*btst.b	#0,d4
	*bne.b	0f
	* probably 0xFC (there are invalid/impossible combinations)
	*lea		green_city,a0
0:
	rts
	
shift_d6_copper_y:
	lsl.w	#4,d6		| times 16
	cmp.w	#DYNAMIC_COPPER_ROWS*16,d6
	bcc.b	10f
	cmp.w	#HALF_DYNAMIC_COPPER_ROWS*16,d6
	bcs.b	9f
	add.w	#SPRITE_COPPERLIST_CHUNK_SIZE,d6
9:
	rts
10:
	moveq	#0,d6
	rts
	
erase_mountain_line:
	sub.w	#NB_BYTES_PER_ROW,a1
	move.w	#NB_BYTES_PER_ROW/4-1,d0
0:
	clr.l	(a1)+
	dbf		d0,0b
	rts
	
* < D0: sprite X
* < D1: sprite Y
* < D2: sprite code & flags
* < D3: sprite color (clut index, no flip information)
* > D6: allocated sprite index
alloc_sprite:
	* first pass: find a free sprite next to a sprite with
	* same clut
	lea		host_sprites(pc),a2
	moveq	#0,d6
0:
	cmp.b	(SPRITE_CLUT,a2),d3
	bne.b	10f
	* allocated (else would be -1/invalid) + same clut
	* check even/odd index
	btst	#0,d6
	beq.b	1f
	* odd: check if previous entry is free
	tst.b	(SPRITE_X-SPRITE_SIZEOF,a2)
	beq.b	8f
	tst.b	(SPRITE_Y-SPRITE_SIZEOF,a2)
	bne.b	10f
8:
	* previous entry is free, same clut: we can use that
	* entry, no color conflict
	lea		(-SPRITE_SIZEOF,a2),a2
9:
	move.b	d0,(a2)+		| X
	move.b	d1,(a2)+		| Y
	move.b	d2,(a2)+		| code
	move.b	d3,(a2)+		| clut (no flip information)
	rts						| done
1:
	* even: check if next entry is free
	tst.b	(SPRITE_X+SPRITE_SIZEOF,a2)
	beq.b	2f
	tst.b	(SPRITE_Y+SPRITE_SIZEOF,a2)
	bne.b	10f
2:
	* next entry is free, same clut: we can use that
	* entry, no color conflict
	lea		(SPRITE_SIZEOF,a2),a2
	bra.b	9b
10:
	* next entry
	addq.w	#SPRITE_SIZEOF,a2
	addq	#1,d6
	cmp.w	#NB_HOST_SPRITES,d6
	bne.b	0b
	* second pass if first pass failed (could not match
	* a pair with one occupied slot with compatible clut,
	* which happens when there are very few sprites
	* displayed): we have to find 2 consecutive free slots

	lea		host_sprites(pc),a2
	moveq	#0,d6
11:
	* we consider that a sprite is not allocated
	* if one of the coordinates is zero (real game
	* doesn't care and sets X to 255, and Y to 0 at times
	tst.b	(SPRITE_Y,a2)
	beq.b	12f
	tst.b	(SPRITE_X,a2)
	bne.b	20f
12:
	* not allocated: test odd sprite
	tst.b	(SPRITE_Y+SPRITE_SIZEOF,a2)
	jeq	9b
	tst.b	(SPRITE_X+SPRITE_SIZEOF,a2)
	jeq	9b		| ok, both slots are free, allocate the first one
20:
	* next sprite pair
	lea		(2*SPRITE_SIZEOF,a2),a2
	addq	#2,d6
	cmp.w	#NB_HOST_SPRITES,d6
	bne.b	11b
	
	* third pass: last chance/emergency: there ARE free slots
	* but maybe too many different cluts so we can't find a suitable slot.
	* In that case, pick the first free slot
	*
	lea		host_sprites(pc),a2
	moveq	#0,d6
21:
	tst.b	(SPRITE_X,a2)
	beq.b	9b		| ok, a slot is free, allocate it
	tst.b	(SPRITE_Y,a2)
	beq.b	9b		| ok, a slot is free, allocate it
30:
	* next sprite
	lea		(SPRITE_SIZEOF,a2),a2
	addq	#1,d6
	cmp.w	#NB_HOST_SPRITES,d6
	bne.b	21b
	* just cannot happen
	* if we reach that point there's a big problem, break if dev mode
	* hopefully if we save buffer in A1 we can reproduce the issue at will!
	.ifndef	RELEASE
	lea			sprite_allocation_error,a0
	lea		sprite_registers,a1
	lea		host_sprites(pc),a2
	
	jbsr	osd_break
	.endif
	* in release mode, just discard this sprite, maybe we'll get away with it!
	rts
	

	
	
	
	
	.ifndef		RELEASE
test_sprites:
.byte  0xad,0x07,0x42,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	|	0x0000
.byte  0x7d,0x01,0x4d,0x49,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	|	0x0010
.byte  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	|	0x0020
.byte  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	|	0x0030
.byte  0x00,0x00,0x00,0x00,0xad,0x07,0x42,0x54,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	|	0x0040
.byte  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	|	0x0050
.byte  0xad,0x07,0x42,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	|	0x0060
.byte  0x7d,0x01,0x4d,0x49,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	|	0x0070
.byte  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	|	0x0080
.byte  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x26,0x04,0x00,0x90	|	0x0090
.byte  0x26,0x01,0x00,0x7d,0x20,0x00,0x06,0x47,0x21,0x00,0x05,0x50,0x1e,0x00,0x07,0x5d	|	0x00a0
.byte  0x31,0x00,0x01,0x46,0x21,0x00,0x03,0x46,0x31,0x00,0x02,0x56,0x21,0x00,0x04,0x56	|	0x00b0
.byte  0x72,0x8b,0xc6,0x94,0x72,0xfb,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x02,0x00,0x18	|	0x00c0
.byte  0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xdf,0x83,0x00,0x05,0x05,0x02	|	0x00d0
.byte  0x00,0xbc,0x8d,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	|	0x00e0
.byte  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00	|	0x00f0
	.endif
	
bob_previous_positions_1:
	ds.b	NB_TARGET_SPRITES*PREVIOUS_SPRITE_SIZE
bob_previous_drawed_sprites:
	.long	bob_previous_positions_1
bob_previous_displayed_sprites:
	.ifeq	OPT_ENABLE_DOUBLE_BUFFERING
	.long	bob_previous_positions_1
	.else
	.long	bob_previous_positions_2	
bob_previous_positions_2:
	ds.b	NB_TARGET_SPRITES*PREVIOUS_SPRITE_SIZE	
	.endif

sprite_registers:
	ds.l	NB_TARGET_SPRITES+2		| we need more room for background scroll regs
	
	

switch_screen_buffers:

	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	* let's switch screen buffers, background (chars)
	* toggle fg planes (double buffering)
	* also toggle previous sprite positions
	lea		fg_drawed_screen_ptr(pc),a0
	lea		bob_previous_positions_1(pc),a2
	lea		bob_previous_positions_2(pc),a3
	move.l	fg_screen_data_1,a1
	move.l	fg_screen_data_2,a5
	* also switch previous state memory
	cmp.l	(a0),a1
	bne.b	2f
	* screen data 1 is displayed screen
	* set it to drawn screen
	exg		a1,a5
	exg		a2,a3
2:
	move.l	a1,(a0)
	move.l	a5,fg_displayed_screen_ptr
	move.l	a2,bob_previous_drawed_sprites
	jbsr		set_bg_bitplanes
	jbsr		set_fg_bitplanes
	.endif
	
	rts
	
store_system:
	tst.l	_resload
	beq.b	0f
	rts
0:
	* system copper
	
	move.l	4.W,a6
	move.w	AttnFlags(a6),d0
	btst	#AFB_68010,d0
	beq.b	1f
	lea	get_vbr,a5

	jsr		_LVOSupervisor(a6)
	move.l	d0,system_vbr
1:
	

	lea	_custom,a6
	move.w	intenar(a6),old_intena
	move.w	dmaconr(a6),old_dmacon
	lea		old_sysvectors,a0
	move.l	system_vbr(pc),a1
	move.l	(0x64,a1),(a0)+
	move.l	(0x68,a1),(a0)+
	move.l	(0x6c,a1),(a0)+
	move.l	(0x70,a1),(a0)+
	move.l	(0x74,a1),(a0)+
	move.l	(0x78,a1),(a0)+
	move.l	(0x7C,a1),(a0)+
	rts

restore_system:
	lea	_custom,a6
	jsr		_mt_remove_cia

	move.w	#0x4000,intena(a6)	| ints off
	lea		old_sysvectors,a0
	move.l	system_vbr(pc),a1
	move.l	(a0)+,(0x64,a1)
	move.l	(a0)+,(0x68,a1)
	move.l	(a0)+,(0x6c,a1)
	move.l	(a0)+,(0x70,a1)
	move.l	(a0)+,(0x74,a1)
	move.l	(a0)+,(0x78,a1)
	move.l	(a0)+,(0x7C,a1)


	bclr	#6,0xbfee01


	lea	_custom,a6
	move.w	old_intena,d0			| get old val
	and.w	#0x3fff,d0
	eor.w	#0x3fff,d0
	move.w	d0,intena(a6)		| clr bits
	eor.w	#0x3fff,d0
	or.w	#0xc000,d0		
	move.w	d0,intena(a6)		| set bits and main

	move.w	old_dmacon,d0			| get old val
	and.w	#0x3fff,d0
	eor.w	#0x3fff,d0

***		and.w	#0xfff0,d0		| preserve sound dma for now

	move.w	d0,dmacon(a6)		| clr bits



	eor.w	#0x3fff,d0
	or.w	#0xc000,d0		
	move.w	d0,dmacon(a6)		| set bits and main

	move.l	old_syscoplist,cop1lc(a6)
	move.l	_gfxbase,a6
	move.b	gb_ChipRevBits0(a6),chiprevbits+3
	move.l	old_actiview,a1
	jsr	_LVOLoadView(a6)


	moveq	#0,d0
	rts

quit_to_os:
	tst.l	_resload
	bne.b	0f
	bsr		restore_system
	* set SR to 0 from here, so we return to OS with SR=0
	* (else it kills the system pretty quickly)
	* it works as quit_to_os is called from an interrupt
	move.w	#0,SR
	move.l	old_stack(pc),a7
	bsr		save_highscores
	moveq	#0,d0
	rts
0:
	pea	  TDREASON_OK
	move.l	_resload(pc),-(a7)
	addq.l	#resload_Abort,(a7)
	rts

* set sprite pointers on chipmem zone, with sprites all
* pointing to blank

init_sprite_bank:
	move.w	#sprpt,d0
	move.w	#NB_HOST_SPRITES-1,d2		| 7
0:
	move.l	(a1)+,d1
	move.w	d0,(a0)+
	swap	d1
	move.w	d1,(a0)+
	swap	d1
	addq	#2,d0
	move.w	d0,(a0)+
	move.w	d1,(a0)+
	
	addq	#2,d0
	dbf		d2,0b
	rts
	
platform_init:
	bsr		store_system
	

	lea		_custom,a5
	move.w	#0x7FFF,dmacon(a5)
	move.w	#0x7FFF,intena(a5)
	* set blitter parameters once and for all
    move.l  #-1,bltafwm(a5)
	
	* restrict borders: we don't see bobs on the borders!
    move.w #0x1C99,diwstrt(a5)
	*         VVHH
    move.w #0x2289,diwstop(a5)
	* try to hide color 0 on the border (except on OCS)
    move.w #0x0611,bplcon0(a5) | 8 bitplanes, dual playfield, borderblank
    move.w #BASE_BPLCON2_VALUE,bplcon2(a5)
	* AGA-compatible ECS default values
	*move.w	#0x32,bplcon4(a5)	| odd sprites palette start at color 48, even at 32
	move.w	#0x22,bplcon4(a5)	| sprites palette start at color 32, keep coupling for now
    move.w #3,fmode(a5)
    move.w #0x0030,ddfstrt(a5)
    move.w #0x00C8,ddfstop(a5)
    move.w	#-8,d0

    move.w #0,bplcon1(a5)
    move.w d0,bpl1mod(a5)
    move.w d0,bpl2mod(a5)

	* set sprite registers in copperlist for the upper part
	lea		sprites_upper_part,a0
	lea		blank_sprite_table,a1
	bsr		init_sprite_bank
	.ifne	OPT_ENABLE_MULTIPLEXED_SPRITES
	* lower part!
	lea		blank_sprite_table+4*8,a1
	lea		sprites_lower_part,a0
	bsr		init_sprite_bank
	.endif
	
	
	bsr		set_fg_bitplanes
	
	bsr		load_palette_in_copperlist
	
	

	
	* set copperlist
	move.l	#copperlist,cop1lc(a5)

	* wait 300 lines
	move.w	#100,d0
	bsr	beamdelay
	move.w	#100,d0
	bsr	beamdelay
	move.w	#100,d0
	bsr	beamdelay
	
    * init sprite, bitplane, whatever dma

    move.w #0x83E0,dmacon(a5)
    *move.w #0x20,dmacon(a5)

	* install keyboard and vblank/copper handler
	pea		level2_interrupt(pc)
	move.l	system_vbr(pc),a1
	move.l	(a7)+,(0x68,a1)
	pea		_vblank(pc)
	move.l	(a7)+,(0x6C,a1)
	pea		_nmi(pc)
	move.l	(a7)+,(0x7C,a1)

	* soundfx lib
	lea		_custom,a6
	lea		blank_sound,a0
	move.l	a0,(0xA0,a6)
	move.l	a0,(0xB0,a6)
	move.l	a0,(0xC0,a6)
	move.l	a0,(0xD0,a6)
	move.l	system_vbr(pc),a0
	moveq	#1,d0	| PAL
	jsr		_mt_install_cia

	.ifne	OPT_ENABLE_PROFILING
	* init profiling if enabled
	lea		0x180000,a0
	move.l	#0x20000,d0
	lea		0x100,a1
	bsr		init_fixed_address
	bsr		install_profiler_vbl_hook
	.endif

	
    rts
	
load_palette_in_copperlist:
	movem.l	d0-d1/a0-a1,-(a7)
	lea		tiles_palette(pc),a0

	move.w	#TOTAL_NB_COLORS,d0
	lea		panel_tiles_colors,a1
	bsr		load_palette
	movem.l	(a7)+,d0-d1/a0-a1
	* pass through
load_bobs_palette_in_playfield_copperlist:
	movem.l	d0-d1/a0-a1,-(a7)
	move.w	#TOTAL_NB_COLORS,d0
	lea		bobs_palette(pc),a0
	lea		playfield_colors,a1
	bsr		load_palette
	movem.l	(a7)+,d0-d1/a0-a1
	
	
	rts
	


	

* < A0: palette
* < A1: copperlist
* < D0: number of colors to load	
load_palette:
	subq.w	#1,d0
	beq.b	2f
1:
	addq.w	#2,a1
	move.w	(a0)+,(a1)+
	dbf		d0,1b
2:
	rts
	

osd_is_vblank_interrupt_enabled:
	move.w	_custom+intenar,d0
	btst	#5,d0			| check vblank interrupt
	rts
	


* 60Hz VBLANK interrupt (also keyboard)
osd_enable_interrupts:
	tst.b	interrupt_mode
	beq.b	0f
	* clear SR from interrupt mode, so enable interrupts really
	* works from the game (which calls enable interrupts from interrupt)
	move.w	#0x2000,SR
0:
	move.w	#0xC038,_custom+intena
	rts
	
osd_disable_interrupts:
	tst.b	interrupt_mode
	beq.b	0f
	* if interrupts are disabled again from interrupt, re-set SR
	move.w	#0x2700,SR
0:
	move.w	#0x0030,_custom+intena
	rts



	


* < D4: sprite properties
*     Y code+attrs clut X
* > D0,D1: X,Y.B
* > D5: clut index
* > D6: sprite index + attributes
* 
decode_sprite_data:
	move.b	d4,d1	| sprite X (aka Y on amiga)
	lsr.l	#8,d4
	move.b	d4,d5	| clut index
	lsr.l	#8,d4
	move.b	d4,d6	| sprite index
	lsr.l	#8,d4	
	move.b	d4,d0	| sprite Y (aka X on amiga)
	rts

* same was osd_w_videoram but without screen update
* because we know that osd_w_colorram follows
osd_w_videoram_no_update:
    .ifeq OPT_DISABLE_BG_LAYER
	movem.l	d0-d7/a0-a3,-(a7)

	sub.w	#SCREEN_ADDRESS,d7
	bcs.b	0f
	.ifndef	RELEASE
	cmp.w	#0x400,d7
	bcs.b	1f
0:
	* should not happen
	lea		write_videoram_out_of_range_error(pc),a0
	jbsr	osd_break
	nop	
	bra.b	0f
	.endif
1:
	lea		bg_videoram,a1
	add.w	d7,a1
	
	move.b	(a1),latest_overwritten_tile_code
	move.b	d0,(a1)	| update logical grid

	movem.l	(a7)+,d0-d7/a0-a3
    .endif | OPT_DISABLE_BG_LAYER
	rts

	
* d7=screen address (preserved), d0=tile (preserved)
* d7 starts at 0x8000 ends at 0x83FF
* should preserve all registers

osd_w_videoram:
    .ifeq OPT_DISABLE_BG_LAYER
	movem.l	d0-d7/a0-a3,-(a7)
	

	sub.w	#SCREEN_ADDRESS,d7
	bcs.b	0f
	.ifndef	RELEASE
	cmp.w	#0x400,d7
	bcs.b	1f
0:
	* should not happen
	lea		write_videoram_out_of_range_error(pc),a0
	jbsr	osd_break
	nop	
	bra.b	0f
	.endif
1:
	lea		bg_videoram,a1
	add.w	d7,a1
	
	cmp.b	(a1),d0
	beq.b	0f		| already the proper value
3:
	move.b	(a1),latest_overwritten_tile_code
	move.b	d0,(a1)	| update logical grid
	lea		bg_colorram,a1
	move.b	(a1,d7.W),d1
	

	jbsr		update_bg_tile
0:
	movem.l	(a7)+,d0-d7/a0-a3
    .endif | OPT_DISABLE_BG_LAYER
	rts

* d7=screen address (preserved), d0=attribute (preserved)
* d7 starts at 0x8400 ends at 0x8800
* should preserve all registers

osd_w_colorram:
    .ifeq OPT_DISABLE_BG_LAYER
	movem.l	d0-d7/a0-a3,-(a7)
	sub.w	#SCREEN_ADDRESS+0x400,d7
	bcs.b	0f
	.ifndef	RELEASE
	cmp.w	#0x400,d7
	bcs.b	1f
0:
	* should not happen
	lea		write_colorram_out_of_range_error(pc),a0
	jbsr	osd_break
	nop	
	bra.b	0f
	.endif
1:
	lea		bg_colorram,a1
	add.w	d7,a1
	cmp.b	(a1),d0
	beq.b	0f		| already the proper value
	

	move.b	d0,(a1)	| update logical grid
	move.b	d0,d1
	lea		bg_videoram,a1
	move.b	(a1,d7.W),d0
	
	jbsr		update_bg_tile
0:
	movem.l	(a7)+,d0-d7/a0-a3
    .endif | OPT_DISABLE_BG_LAYER
	rts


* d7: screen offset
* d0: tile code
* d1: attribute
*
* very straightforward linear tile layout 32v (30 visible) x 32h tiles
* thanks to landscape unrotated display for once!

update_bg_tile:
	and.w	#0xFF,d0	| mask up to 255
	and.w	#0xFF,d1	| mask up to 255

	.ifne	OPT_ENABLE_LOGGING
	* when logging is enabled, play a while
	* and break. Get the address in 0x100 then do
	* S used_cluts <address at $100> $10000
	* then run the compute_used_cluts.py program again
	
	lea		tile_log_table,a0
	move.l	a0,0x100
	movem.w	d0-d1,-(a7)
	and.l	#0xFFFF,d0
	lsl.l	#8,d0
	add.w	d1,d0
	st.b	(a0,d0.l)
	movem.w	(a7)+,d0-d1
	.endif
	
	* is it upper part of bank ?
	btst	#7,D1
	beq.b	0f
	* second part of tiles ("moon patrol" title...)
	add.w	#0x100,d0
0:


	* color tile
	cmp.w	#22,d1
	bcs.b	111f
	moveq	#0,d1		| wrong but default
111:
	move.w	d7,d3
	lsr.w	#5,d3		| this is Y (tile)
	
	tst		d0
	bne.b	112f
	cmp.w	#PLAYFIELD_TILE_Y_MIN,d3	
	bcs.b	112f
	* playfield: some hacks are necessary for the clearing
	* character with some cluts (1: blue,0xC: pink)
	tst		d0
	bne.b	112f
	cmp.b	#1,d1
	seq		d1
	jeq		112f
	cmp.b	#0xC,d1
	seq		d1
112:

	move.w	d7,d6
	
	and.w	#0x1F,d7	| this is X (tile)
	addq.w	#2,d7

	lea		mulNB_BYTES_PER_ROW_table(pc),a0

	moveq	#NB_PLAYFIELD_PLANES-1,d4		| 4 bitplanes for the panel
	cmp.w	#PANEL_MAX_Y/8,d3
	bcs.b	23f
	* always wait for blitter operation before writing to chip with CPU
	WAIT_BLIT
23:
	* do special stuff for tiles that go into scrollable strip
	cmp.w	#0x100,d0
	bcc.b	230f
	cmp.w	#0x68,d0
	jcc	update_scrollable_bottom
	
	* for 0 char we have to decide according to Y tile
	tst.b	d0
	bne.b	230f
	cmp.w	#SCROLLABLE_TILE_Y_START,d3
	bcc		update_scrollable_bottom
230:
	move.w	#BG_SCREEN_PLANE_SIZE,d5
	
	move.l	bg_drawed_screen_ptr(pc),a1
	
	* D3 = Y

	add.w	d3,d3
	move.w	(a0,d3.w),d3
	lsl.w	#3,d3		| times 8
	add.w	d3,d7
	add.w	d7,a1
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	add.w	d7,a2
	.endif

	* optimization when a well-known
	* empty character is passed (standard charset)
	tst.b	d1
	bne.b	23f
	tst.w	d0	| empty character
	jeq	11f
	cmp.w	#0x20,d0
	jeq	11f		| space
23:
	move.b	d0,d2		| store character

	lea		character_table,a0
	add.w	d0,d0
	add.w	d0,d0
	move.l	(a0,d0.w),d0
	jeq	2f
	move.l	d0,a0		| pointer on clut table
	* now we use d1 (attribute)
	add.w	d1,d1
	add.w	(a0,d1.w),a0
	cmp.l	d0,a0
	jeq		12f		| should not happen

	* special case for vertical shots. We managed to put the color in the 4th
	* plane so it doesn't interact with the mountain background which only use 3
	* the color change a bit and it's yellow instead of white but it's already
	* a miracle that it displays properly given the constraints
	and.b	#0xF8,d2
	cmp.b	#0x60,d2
	jeq		copy_third_plane

	
	* just copy
4:
	.set	offset,0
	.rept	8
	move.b	(a0)+,(offset,a1)

	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	add.w	d5,a1
	dbf		d4,4b
0:
	rts

	
	


	
	* clear tile

11:
	move.b	latest_overwritten_tile_code,d0
	and.b	#0xF8,d0
	cmp.b	#0x60,d0
	jeq	erase_third_plane
111:
	.set	offset,0
	.rept	8
	clr.b	(offset,a1)
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	add.w	d5,a1
	dbf		d4,111b
2:
	rts

12:
	* clut/tile combo not declared as used
	**blitz
	rts

copy_third_plane:
	.set	offset,0
	move.w	d5,d0
	add.w	d5,d5
	add.w	d0,d5
	add.w	d5,a1		| add D5 3 times
	addq	#8,a0		| non-zero shot bitplane (first bitplane is empty)
	.set	offset,0
	.rept	8
	move.b	(a0)+,(offset,a1)

	.set	offset,offset+NB_BYTES_PER_ROW
	.endr


0:
	rts
	
erase_third_plane:
	.set	offset,0
	add.w	d5,a1
	add.w	d5,a1
	add.w	d5,a1
	.rept	8
	clr.b	(offset,a1)
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr

	rts

latest_overwritten_tile_code:
	dc.w	0


update_scrollable_bottom:
	lea		mulNB_BYTES_PER_SCROLLABLE_STRIP_ROW_table(pc),a0
	lea		bg_scrollable_strip,a1		| backbuffer
	* D3 = Y
	move.w	#SCROLLABLE_PLANE_SIZE,d5

	* recenter on 0
	sub.w	#SCROLLABLE_TILE_Y_START,d3
	add.w	d3,d3
	move.w	(a0,d3.w),d3
	lsl.w	#3,d3		| times 8
	add.w	d3,a1
	add.w	d7,a1

	tst.b	d1
	bne.b	23f
	tst.w	d0	| empty character
	jeq	11f
23:
	* optimization when a well-known
	* uniform character is passed (standard charset)
	*cmp.b	#0xF3,d0	| uniform ground
	
	
	lea		character_table,a0
	add.w	d0,d0
	add.w	d0,d0
	move.l	(a0,d0.w),d0
	jeq	2f
	move.l	d0,a0		| pointer on clut table
	* now we use d1 (attribute)
	add.w	d1,d1
	add.w	(a0,d1.w),a0
	cmp.l	d0,a0
	jeq		12f		| should not happen

	
	* just copy
4:
	cmp.w	#SCROLLABLE_STRIP_NB_COLS-2,d7
	bcc		42f		| single copy
41:
	.set	offset,0
	.rept	8
	move.b	(a0)+,d0
	move.b	d0,(offset,a1)	
	move.b	d0,(offset+32,a1)		| mirror
	.set	offset,offset+NB_BYTES_PER_SCROLLABLE_STRIP_ROW
	.endr
	add.w	d5,a1
	dbf		d4,41b
0:
	rts
42:
	.set	offset,0
	.rept	8
	move.b	(a0)+,d0
	move.b	d0,(offset,a1)	
	.set	offset,offset+NB_BYTES_PER_SCROLLABLE_STRIP_ROW
	.endr
	add.w	d5,a1
	dbf		d4,42b
	rts

* clear tile(s)
11:
	cmp.w	#SCROLLABLE_STRIP_NB_COLS-2,d7
	bcc		112f		| single clear
	* mirror
111:
	.set	offset,0
	.rept	8
	clr.b	(offset,a1)
	clr.b	(offset+32,a1)
	.set	offset,offset+NB_BYTES_PER_SCROLLABLE_STRIP_ROW
	.endr
	add.w	d5,a1
	dbf		d4,111b
2:
	rts
	* no mirror
112:
	.set	offset,0
	.rept	8
	clr.b	(offset,a1)
	.set	offset,offset+NB_BYTES_PER_SCROLLABLE_STRIP_ROW
	.endr
	add.w	d5,a1
	dbf		d4,12b
	rts
	
12:
	* clut/tile combo not declared as used
	**blitz
	rts
			
store_sprite_pos_16:
	move.l	a1,-(a7)
	lea		HW_SpriteYTable_16,a1
	bsr		store_sprite_pos
	move.l	(a7)+,a1
	rts
store_sprite_pos_32:
	move.l	a1,-(a7)
	lea		HW_SpriteYTable_32,a1
	bsr		store_sprite_pos
	move.l	(a7)+,a1
	rts
	
* < d0.w: x
* < d1.w: y
* < a1: sprite pos table (depending on height)
* > d0.L: control word
store_sprite_pos:
    move.l  a0,-(a7)

    lea	HW_SpriteXTable(pc),a0
	
	.ifdef	NO68020
    add.w	d0,d0
    add.w	d0,d0
    move.l	(a0,d0.w),d0
	move.w	d1,-(a7)
    add.w	d1,d1
    add.w	d1,d1
    or.l	(a1,d1.w),d0
	move.w	(a7)+,d1
	.else
    move.l	(a0,d0.w*4),d0
    or.l	(a1,d1.w*4),d0	
	.endc
    move.l  (a7)+,a0
    rts
	
HW_SpriteXTable:
	.set	reptn,0
	.rept 320
	.set	x,reptn+0x80
	.set reptn,reptn+1
    .byte  0,x>>1,0,x&1
  .endr

	.macro DEF_HW_SPRITE_Y_TABLE	height
HW_SpriteYTable_\height:
  .set	reptn,0
  .rept 288
	.set	ys,reptn+0x1c
	.set	ye,ys+\height
    .byte  ys&255, 0, ye&255, ((ys>>6)&4)+((ye>>7)&2)
	.set	reptn,reptn+1
  .endr
	.endm


	DEF_HW_SPRITE_Y_TABLE	16
	DEF_HW_SPRITE_Y_TABLE	32



* set_bg_bitplanes
* what: sets bitplanes in copperlist

set_bg_bitplanes:
    move.l	bg_drawed_screen_ptr(pc),a0
    moveq #4-1,d1
	move.l	a0,d0
    lea	panel_bitplanes+2,a0
	moveq	#0,d2
	move.w	#BG_SCREEN_PLANE_SIZE,d2
1:
    swap d0
    move.w d0,(a0)
    swap d0
    move.w d0,(4,a0)    
    addq.w  #8,a0
    add.l d2,d0		| LONG!
    dbf d1,1b

    rts

* set_fg_bitplanes
* what: sets bitplanes in copperlist
* sets 6 bitplanes at start even if only 4 are used in the panel
* or it will just be big headaches to compute...
* a small amount of chipmem is wasted for the 2 bitplanes that aren't active
* in the first 48 lines but we're talking about 48*40*2 = 3840 bytes...
* maybe we can use that memory for something at some point.

set_fg_bitplanes:
    move.l	fg_displayed_screen_ptr(pc),a0
    moveq #4-1,d1
	move.l	a0,d0
    lea	bobs_bitplanes+2,a0
	moveq	#0,d2
	move.w	#FG_SCREEN_PLANE_SIZE,d2
1:
    swap d0
    move.w d0,(a0)
    swap d0
    move.w d0,(4,a0)    
    addq.w  #8,a0
    add.l d2,d0		| LONG!
    dbf d1,1b

    rts


	

osd_debug_hook:
	rts
	
osd_get_random:
* > D0: pseudo random value (8 bits, all other bits zeroed)
	movem.l	a0,-(a7)
	lea	seed(pc),a0
	move.l	(a0),d0
	* thanks meynaf
	mulu #0xa57b,d0
	addi.l #0xbb40e62d,d0
	rol.l #6,d0	
	move.l	d0,(a0) 
	movem.l	(a7)+,a0
	add.b	_custom+vposr,d0
	and.l	#0xFF,d0
	rts
seed:
	dc.l	0x12345678

	
* d7=screen address
osd_r_videoram:
	movem.l	a0/d7,-(a7)
	sub.w	#SCREEN_ADDRESS,d7
	bmi.b	0f
	.ifndef	RELEASE
	cmp.w	#0x400,d7
	bcs.b	1f
0:
	* should not happen
	lea		read_videoram_out_of_range_error,a0
	jbsr	osd_break
	clr.b	d0
	move.b	D1,d1
	nop
	bra.b	2f
	.endif
1:
	lea		bg_videoram,a0
	move.b	(a0,d7.w),d0
2:
	movem.l	(a7)+,a0/d7
	rts

* < D0: scroll value 0->???
osd_set_ground_scroll_value:
	movem.w	d0/d1,-(a7)
	and.w	#0xF,d0
	move.b	d0,d1
	lsl.w	#4,d0
	or.b	d1,d0
	*move.w	d0,bplcon1_value
	movem.w	(a7)+,d0/d1
	rts
	
osd_read_in_2:
	moveq	#-1,d0
	movem.l	a0/d1,-(a7)
	lea		keyboard_table(pc),a0
	* misc control keys
	tst.b	(6,a0)		| "6" key like in MAME
	beq.b	0f
	bclr	#1,d0
0:	
	tst.b	(5,a0)		| "5" key like in MAME
	beq.b	0f
	bclr	#0,d0
0:
	tst.b	(1,a0)		| "1" key like in MAME
	beq.b	0f
	bclr	#2,d0
0:
	tst.b	(2,a0)		| "2" key like in MAME
	beq.b	0f
	bclr	#10,d0
0:	


*	* directions + fire
*	move.l	_joypad_state(pc),d1
*	btst	#JPB_BTN_UP,d1
*	beq.b	0f
*	bclr	#3,d0
*0:
*	btst	#JPB_BTN_DOWN,d1
*	beq.b	0f
*	bclr	#2,d0
*0:
*
*	btst	#JPB_BTN_RED,d1
*	beq.b	0f
*	bclr	#5,d0
*0:
	movem.l	(a7)+,a0/d1
	rts
	
osd_read_in_1:
	moveq	#-1,d0
	movem.l	a0/d1,-(a7)



	lea		keyboard_table(pc),a0

	tst.b	(0x4C,a0)		| "up" key
	beq.b	0f
	bclr	#3,d0
0:
	tst.b	(0x4D,a0)		| "down" key
	beq.b	0f
	bclr	#2,d0
0:
	tst.b	(0x4F,a0)		| "<-" key
	beq.b	0f
	bclr	#1,d0
0:
	tst.b	(0x4E,a0)		| "->" key
	beq.b	0f
	bclr	#0,d0
0:
	tst.b	(0x63,a0)		| "ctrl" key
	beq.b	0f
	bclr	#7,d0
0:
	tst.b	(0x64,a0)		| left "alt" key
	beq.b	0f
	bclr	#5,d0
0:

	* directions + fire
	move.l	_joypad_state(pc),d1
	btst	#JPB_BTN_UP,d1
	beq.b	0f
	bclr	#3,d0
	bclr	#5,d0		| if up for jump set!
0:
	btst	#JPB_BTN_DOWN,d1
	beq.b	0f
	bclr	#2,d0
0:
	btst	#JPB_BTN_LEFT,d1
	beq.b	0f
	bclr	#1,d0
0:
	btst	#JPB_BTN_RIGHT,d1
	beq.b	0f
	bclr	#0,d0
0:
	btst	#JPB_BTN_RED,d1
	beq.b	0f
	bclr	#7,d0
0:
	btst	#JPB_BTN_BLU,d1
	beq.b	0f
	bclr	#5,d0
0:

	movem.l	(a7)+,a0/d1
	rts
	
BIT_INSERT_COIN = 3
BIT_START_1P = 0
BIT_START_2P = 1

osd_read_in_0:
	moveq	#-1,d0
		
	movem.l	a0/d1,-(a7)

	tst.b	in_continue_loop_flag
	bne.b	0f
	bsr		is_game_playing
	bne.b	2f
0:
	* if game not playing, or within "continue" loop
	* consider "fire" as insert coin
	move.l	_joypad_state(pc),d1
	* save prev state as game loops within vblank
	* pushing fire would either lockup the game
	* or insert a lot of credits simulatenously

	* game not in play, accept start 1P game with "up"
	btst	#JPB_BTN_UP,d1
	beq.b	0f
	bclr	#BIT_START_1P,d0
0:
	* game not in play, accept start 2P game with "down"
	* temp: disabled ATM, 2P mode is buggy!
	btst	#JPB_BTN_DOWN,d1
	beq.b	0f
	bclr	#BIT_START_2P,d0
0:
	btst	#JPB_BTN_RED,d1
	beq.b	1f
	* game not in play, accept insert coin with fire
	bclr	#BIT_INSERT_COIN,d0
1:
2:

	lea		keyboard_table(pc),a0
	* misc control keys
	tst.b	(5,a0)		| "5" key like in MAME
	beq.b	0f
	bclr	#BIT_INSERT_COIN,d0		| insert coin
0:
	tst.b	(1,a0)		| "1" key like in MAME
	beq.b	0f
	bclr	#BIT_START_1P,d0
0:
	tst.b	(2,a0)		| "2" key like in MAME
	beq.b	0f
	bclr	#BIT_START_2P,d0
0:	
	movem.l	(a7)+,a0/d1

	rts
	
	
osd_read_dsw_1:
	* actual dipswitches
	move.b	dip_switches_1(pc),d0
	not.b	d0		| active low
	

	rts
osd_read_dsw_2:
	* actual dipswitches
	move.b	dip_switches_2(pc),d0
	not.b	d0		| active low
	

	rts
	
	


		
osd_read_high_scores:
	movem.l	d0-d7/a0-a6,-(a7)
	move.l	a0,a4
	move.l	_resload(pc),d0
	beq.b	0f
	move.l	d0,a2
	move.l	a0,a3
	bsr		get_hiscore_name
 	jsr		resload_GetFileSize(a2)		
	tst.l	d0
	beq.b	1f
	bsr		get_hiscore_name
	move.l	a3,a1
	jsr		resload_LoadFile(a2)
	* set highest score entry
    move.b    (a3)+,(a4)+
    move.b    (a3)+,(a4)+
    move.b    (a3)+,(a4)+		
	bra.b	1f
0:
	tst.b	highscore_loaded
	beq.b	1f
	* from DOS: just copy buffer
	lea		high_score_buffer(pc),a1
	* set highest score entry
	move.w	#SCORE_FILE_SIZE-1,d0
0:
    move.b    (a1)+,(a4)+
	dbf		d0,0b
1:
	movem.l	(a7)+,d0-d7/a0-a6
	rts
	
osd_write_high_scores:
	movem.l	d0-d7/a0-a6,-(a7)
	tst.b	cheat_used		| don't save score if cheat on
	bne.b	1f
	move.l	_resload(pc),d0
	beq.b	0f
	move.l	d0,a2
	move.l	#SCORE_FILE_SIZE,d0
	move.l	a0,a1
	bsr		get_hiscore_name
	jsr		resload_SaveFile(a2)
	bra.b	1f
0:
	* from DOS: just copy buffer
	lea		high_score_buffer(pc),a1
	move.w	#SCORE_FILE_SIZE-1,d0
0:
	move.b	(a0)+,(a1)+
	dbf		d0,0b

	st.b	highscore_needs_saving
1:
	movem.l	(a7)+,d0-d7/a0-a6
	rts


level2_interrupt:
	bsr		handle_keyboard
	move.w	#8,_custom+intreq
	rte
	
handle_keyboard:
	movem.l	D0/A0/A5,-(a7)
	LEA	0x00BFD000,A5
	MOVEQ	#0x08,D0
	AND.B	0x1D01(A5),D0
	jeq		1f
	MOVE.B	0x1C01(A5),D0
	NOT.B	D0
	ROR.B	#1,D0		| raw key code here
  
	CLR.B	0x1C01(A5)
  
    lea keyboard_table(pc),a0
    bclr    #7,d0
    seq (a0,d0.w)       | updates keyboard table
    jne   2f     | we don't care about key release
	
    cmp.b   #0x19,d0	| "P" key
    bne.b   0f

    bsr	toggle_pause
0:

	btst	#4,cheat_flags+3
	jeq		10f
	* cheat keys
	cmp.b	#0x50,d0	| F1 key
	bne.b	0f
	move.w	#0x0FF,_custom+color
	st.b	cheat_used
	st.b	section_completed_flag
0:
	cmp.b	#0x51,d0	| F2 key
	bne.b	0f
	st.b	cheat_used
	move.w	#0x0FF,_custom+color
	st.b	course_completed_flag
	
0:
	cmp.b	#0x52,d0	| F3 key
	bne.b	0f
	st.b	cheat_used
	* add 10000 points
0:
	cmp.b	#0x53,d0	| F4 key
	bne.b	0f
	st.b	cheat_used
	move.w	#0x0FF,_custom+color
	eor.b	#1,invincible_flag
0:
*	cmp.b	#0x54,d0	| F5 key
*	bne.b	0f
*	st.b	cheat_used
*	move.w	#0x0FF,_custom+color
*0:
*
*	cmp.b	#0x55,d0	| F6 key
*	bne.b	0f
*	* game over, no lives
*	nop
*0:
10:
	.ifndef	RELEASE
	cmp.b	#0x58,d0	| F9 key crashes game (restarts whdload)
	bne.b	0f
	illegal
	.endif
0:

	cmp.b	_keyexit,d0	| "ESC" key or whdload quitkey
	bne.b	2f
	BSET	#0x06,0x1E01(A5)
	moveq	#2,d0
	bsr	beamdelay
	BCLR	#0x06,0x1E01(A5)	| acknowledge key
	bra		quit_to_os
2:
	BSET	#0x06,0x1E01(A5)
	moveq	#2,d0
	bsr	beamdelay
	BCLR	#0x06,0x1E01(A5)	| acknowledge key

1:
	movem.l	(a7)+,d0/a0/a5
	rts
	
* reset all 3 slots for each line
reset_dynamic_colors:
	
	movem.l	a0/d2-d4,-(a7)
	lea	color_line_copper,a0
	moveq	#1,d4
	move.w	#0x1FE,d2
0:
	move.w	#HALF_DYNAMIC_COPPER_ROWS-1,d3
1:
	move.w	d2,(a0)
	addq.w	#4,a0
	move.w	d2,(a0)
	addq.w	#4,a0
	move.w	d2,(a0)
	addq.w	#8,a0
	dbf		d3,1b
	* skip lower sprite part
	add.w	#SPRITE_COPPERLIST_CHUNK_SIZE,a0
	dbf		d4,0b
	movem.l	(a7)+,a0/d2-d4
	rts

* only reset first slot (the one for the mountains/city colors)
reset_background_dynamic_colors:
	
	movem.l	a0/d2-d4,-(a7)
	lea	color_line_copper,a0
	moveq	#1,d4
	move.w	#0x01FE,d2
0:
	move.w	#HALF_DYNAMIC_COPPER_ROWS-1,d3
1:
	move.w	d2,(a0)
	add.w	#16,a0
	dbf		d3,1b
	* skip lower sprite part
	add.w	#SPRITE_COPPERLIST_CHUNK_SIZE,a0
	dbf		d4,0b
	movem.l	(a7)+,a0/d2-d4
	rts


toggle_pause:
	* pause only within game
	jbsr		is_game_playing
	beq.b	0f
	eor.b   #1,pause_flag
0:
	rts

	

    
* < D0: numbers of vertical positions to wait
beamdelay:
0:
	move.w  d0,-(a7)
    move.b	0xdff006,d0	| VPOS
1:
	cmp.b	0xdff006,d0
	beq.s	1b
	move.w	(a7)+,d0
	dbf	d0,0b
	rts

	
	MUL_TABLE	NB_BYTES_PER_ROW,256
	MUL_TABLE	NB_BYTES_PER_SCROLLABLE_STRIP_ROW,256

	.align	4		| leave this long word alignment
program_args:	ds.l	64,0
program_args_end:
	.long	0		| add a longword else it overwrites the read args string in kick 1.3!
	.align	4
read_args_string:
	.byte	read_args_string_end-read_args_string
	.ascii	"INVINCIBLE/S,INFLIVES/S,INFTIME/S,SECTORSELECT/S,"
	.ascii	"CHEATKEYS/S,STARTCOURSE/K/N,STARTLIVES/K/N"
read_args_string_end:
	.align	2


* 8 slots (indexed with the target sprite index, not
* the amiga sprite index) with
* - 4 bytes for the sprite actual address
* - 2 bytes amiga sprite index
* - 2 bytes??
hw_sprite_slots:
	ds.b	8*8
* 8 slots (indexed with the amiga sprite index)
amiga_sprite_slots:
	ds.b	8

	.ifndef	RELEASE
sprite_allocation_error:
	.asciz	"sprite allocation error"
sprite_doesnt_exist_error:
	.asciz	"sprite doesn't exist"
sprite_buffer_doesnt_exist_error:
	.asciz	"sprite buffer doesn't exist"
read_videoram_out_of_range_error:
	.asciz	"read videoram out of range"
write_videoram_out_of_range_error:
	.asciz	"write videoram out of range"
write_colorram_out_of_range_error:
	.asciz	"write colorram out of range"
	.align	2

	.endif


old_intena:
	.long	0
old_dmacon:
	.long	0
old_sysvectors:
	ds.l	10
old_vbr:
	.long	0
old_syscoplist:
	.long	0
old_actiview:
	.long	0
old_stack:
	.long	0
return_address:
	.long	0
	
	
_tag:
		.long	WHDLTAG_CHIPREVBITS_GET
chiprevbits:
		.long	0
		.long	WHDLTAG_CUSTOM1_GET
cheat_flags:
		.long	0

		.long	WHDLTAG_CUSTOM3_GET
misc_options:
		.long	0
		.long	WHDLTAG_CUSTOM4_GET
dip_switch_start_course:
		.long	0
		.long	WHDLTAG_CUSTOM5_GET
dip_switch_start_lives:
		.long	0
	.long	0
dip_switches_1:
		.byte	0
dip_switches_2:
		.byte	0
do_upper_part:
	.byte	0
background_cleared_flag:
	.byte	0

	.align	2
system_vbr:
	.long	0
	
orig_color_4:
	.word	0
toggle_blitter_draw:
	.word	0
	
high_score_buffer:
	ds.b	SCORE_FILE_SIZE

highscore_needs_saving:
	.byte	0
highscore_loaded:
	.byte	0
flip_flop:
	.byte	0
nb_displayed_wheels:
	.byte	0
nb_displayed_ships:
	.byte	0
nb_displayed_rocks:
	.byte	0
	.align	2

host_sprites:
	ds.b	8*SPRITE_SIZEOF
keyboard_table:
	ds.b	0x100

interrupt_mode:
	.word	0
	
pause_flag:
	.word	0


vbl_counter:
	.word	0
_resload:
	.long	0
_joypad_state:
	.long	0
_previous_joypad_state:
	.long	0
_gfxbase:
	.long	0
_dosbase:
	.long	0
delay_timer:
	.word	0
one_out_of_five:
	.word	0
fg_screen_data_1:
	.long	0
fg_screen_data_2:
	.long	0
	
upper_sprite_buffers:
	ds.l	8			| 8 pointers to 8 upper sprite end control words
bg_drawed_screen_ptr:
	.long	0
fg_drawed_screen_ptr:
	.long	0
fg_displayed_screen_ptr:
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	.long	0
	.else
	.long	0
	.endif


	.include	"sound_entries.68k"

green_y_end:
	.word	0
blue_y_end:
	.word	0
_keyexit:
	.byte	0x45	| ESC by default unless whdload overwrites it


dynamic_color_mode:
	.byte	0

cheat_used:
	.byte	0
dosname:
	.ascii	"dos.library"
	.byte	0
graphicsname:
	.ascii	"graphics.library"
	.byte	0
normal_hiscorename:
	.asciz	"mpatrol.high"
floppy_file:
	.ascii	"floppy"
	.byte	0
temp_filename_buffer:
	ds.b	255
_end_of_ng_code:
		
	.align 2
blank_sprite_table:
	.set	offset,0
	.rept	16
	.long	blank_sprite_0+offset
	.set	offset,offset+64+8
	.endr
	
tiles_palette:
	.include "tiles_palette.68k"

bobs_palette:
	.include "bobs_palette.68k"
	* sprites "individual" 4-color palettes
sprite_cluts:
	.include "palette_cluts.68k"
	
	* on amiga, this file is included in mpatrol.68k file
	* so the assembler can optimize by using PC-relative addressing
	* whenever possible (and it does)
	.ifndef	RELEASE
	* easier to debug game to have memory aligned on 0x10000
	.align	0x10000

	.ifne	OPT_ENABLE_LOGGING
	.section	.bss
	.ascii	"TILE"
tile_log_table:
	* 32 cluts, 1024 tiles
	* a lot of combinations aren't used (fortunately!)
	ds.w	0x10000
	.endif
	.endif
	.ascii	"CODE_END"


	.section	.datachip
	
.macro	DECL_EVEN_BITPLANES	bpoff_start,nb_planes
	.set	bpoff,\bpoff_start
	.rept	\nb_planes
	dc.w  0xe0+bpoff,0
	dc.w  0xe2+bpoff,0
	.set	bpoff,bpoff+8
	.endr
	.endm

.macro	DECL_COLOR_BANK	bankno
	.word	bplcon3,0xC00+(BORDERBLANK<<5)+(\bankno<<13)
	.endm
	
.macro	DECL_COLORS	offset,nb_colors
	.set	colidx,\offset
	.rept	\nb_colors
	dc.w	color+(colidx*2),0
	.set	colidx,colidx+1
	.endr
	.endm

.macro	DECL_SPRITES
	.rept	16
	* 2 slots
	.word	0x1FE,0
    .endr
	.endm

blank_sound:
	ds.l	4
	
debug_copperlist:
	dc.w	bplcon0,0x200
	dc.w	color
debug_color:
	dc.w	0
	dc.l	-2
	
blank_sprite_0:
	.rept	(64+8)*16
	.long	0
	.endr
	


	* main copperlist, get some aspirin!!
copperlist:
    *.word   0x1801,0xFFFE


panel_bitplanes:
	DECL_EVEN_BITPLANES	0,4
bobs_bitplanes:
	DECL_EVEN_BITPLANES	4,4
	* default color bank
	DECL_COLOR_BANK	0
panel_tiles_colors:
	DECL_COLORS	0,TOTAL_NB_COLORS

	* sprites color bank
	DECL_COLOR_BANK	1
sprites_upper_part:
	DECL_SPRITES
	* default color bank again
	DECL_COLOR_BANK	0



	* wait until line 48, just after the status panel is displayed
	* to change palette
 	.set    beampos,0x5401
    .word  beampos,0xFFFE

playfield_colors:
	DECL_COLORS	16,TOTAL_NB_COLORS
	* now set color bank 1
	DECL_COLOR_BANK	1
sprites_upper_cols:
	DECL_COLORS	0,16
	DECL_COLOR_BANK	0

	
color_line_copper:
	.rept	HALF_DYNAMIC_COPPER_ROWS
	* room for 3 color registers to change dynamically each line
	* reserved only to set color bank 0!
	.word	0x1FE,0
	.word	0x1FE,0
	.word	0x1FE,0
	.set    beampos,beampos+0x100
	.word	beampos,0xFFFE
	.endr
	* multiplexed sprites + mid-screen interrupt (disabled ATM
	* as it crashes the machine when calling mpatrol_irq from it...)
	.ifne	OPT_ENABLE_MULTIPLEXED_SPRITES
sprites_lower_part:
	DECL_SPRITES
	DECL_COLOR_BANK	1
sprites_lower_cols:
	DECL_COLORS	0,16
	DECL_COLOR_BANK	0		| back to bank	0
	.else
	* reserve room
	.rept	SPRITE_COPPERLIST_CHUNK_SIZE/4
	.word	0x1FE,0
	.endr
	.endif
	
	* rest of the color line copper stuff. Code knows that it must skip the sprites_lower_part sprite table
	.rept	HALF_DYNAMIC_COPPER_ROWS
	* room for 3 color registers to change dynamically each line
	.word	0x1FE,0
	.word	0x1FE,0
	.word	0x1FE,0
	.set    beampos,beampos+0x100
	.word	beampos,0xFFFE
	.endr

	* then we should wait a bit, and set palette to tiles palette definitely
	* so scrolling letters have the proper colors TODO
	
	* pal limit
    .word  0xFFDF,0xFFFE       | PAL wait
	.word	 intreq,0x8010	| no bobs from now on (maybe needs adjustment), get more drawing time
post_pal_copper_rows:
	.set    beampos,0x0001
	.rept	0x15
	* room for 3 color registers to change dynamically each line
	.word	0x1FE,0
	.word	0x1FE,0
	.word	0x1FE,0
	.set    beampos,beampos+0x100
	.word	beampos,0xFFFE
	.endr
	.word	color,0
	
    *.word  0x1401,0xFFFE		| wait more lines to set to black (big holes!)
	
    *.word   0x1C01,0xFFFE
	
 	.word	beampos,0xFFFE
    .long    -2					
	.ascii	"ENDCPLST"

	* aligning on 8 bytes so .align will work
	* in the next datachip sections
	.align	8
	
		.section .bsschip
bg_screen_buffer_1:
	.skip	BG_SCREEN_SIZE
	.skip	NB_BYTES_PER_ROW*12*3
	.skip	8
	
fg_screen_buffer_1:
	.skip	BG_SCREEN_SIZE
	.skip	NB_BYTES_PER_ROW*12*3
	.skip	8
	.ifne  OPT_ENABLE_DOUBLE_BUFFERING
fg_screen_buffer_2:
	.skip	BG_SCREEN_SIZE
	.skip	NB_BYTES_PER_ROW*12*3
	.skip	8
	.endif
	* draw the rows 24->31 in a buffer to be able
	* to blit it with scroll effect afterwards
	* double the buffer as we need to emulate revolving scroll
bg_scrollable_strip:
	ds.b	SCROLLABLE_PLANE_SIZE*NB_PLAYFIELD_PLANES
	.align	8

		