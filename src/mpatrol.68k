
*
* Moon Patrol 68k conversion by JOTD
*
* Reverse-engineered by JOTD
* with the help of comments & variable names found later on
* http://www.computerarcheology.com/Arcade/MoonPatrol/ big thanks/timesaver!
*
*/***************************************************************************
*
*    Irem M52 hardware
*
*****************************************************************************
*
*    Moon Patrol memory map
*
*    driver by Nicola Salmoria
*
*    0000-3fff ROM
*    8000-83ff Video RAM
*    8400-87ff Color RAM
*    e000-e7ff RAM
*
*
*    read:
*    8800      protection
*    d000      IN0
*    d001      IN1
*    d002      IN2
*    d003      DSW1
*    d004      DSW2
*
*    write:
*    c800-c8ff sprites
*    d000      sound command
*    d001      flip screen
*
*    I/O ports
*    write:
*    10-1f     scroll registers
*    40        background #1 x position
*    60        background #1 y position
*    80        background #2 x position
*    a0        background #2 y position
*    c0        background control

*	PORT_START("IN0")
*	/* Start 1 & 2 also restarts and freezes the game with stop mode on
*	   and are used in test mode to enter and esc the various tests */
*	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_START1 )
*	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_START2 )
*	/* coin input must be active for 19 frames to be consistently recognized */
*	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 ) PORT_IMPULSE(19)
*	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_COIN1 )
*	PORT_BIT( 0xf0, IP_ACTIVE_LOW, IPT_UNUSED )
*
*	PORT_START("IN1")
*	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY
*	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )  PORT_8WAY
*	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )  PORT_8WAY
*	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )    PORT_8WAY
*	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNUSED )
*	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 )
*	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )
*	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON1 )
*
*	PORT_START("IN2")
*	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_COCKTAIL
*	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )  PORT_8WAY PORT_COCKTAIL
*	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )  PORT_8WAY PORT_COCKTAIL
*	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )    PORT_8WAY PORT_COCKTAIL
*	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_COIN2 )
*	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL
*	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )
*	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL


*	PORT_START("DSW2")
*	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Flip_Screen ) ) PORT_DIPLOCATION("SW2:1")
*	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
*	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
*	PORT_DIPNAME( 0x02, 0x00, DEF_STR( Cabinet ) ) PORT_DIPLOCATION("SW2:2")
*	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
*	PORT_DIPSETTING(    0x02, DEF_STR( Cocktail ) )
*	PORT_DIPNAME( 0x04, 0x04, "Coin Mode" ) PORT_DIPLOCATION("SW2:3")
*	PORT_DIPSETTING(    0x04, "Mode 1" )
*	PORT_DIPSETTING(    0x00, "Mode 2" )
*	PORT_DIPUNKNOWN_DIPLOC( 0x08, IP_ACTIVE_LOW, "SW2:4" )
*	PORT_DIPUNKNOWN_DIPLOC( 0x10, IP_ACTIVE_LOW, "SW2:5" )
*	PORT_DIPUNKNOWN_DIPLOC( 0x20, IP_ACTIVE_LOW, "SW2:6" )
*	PORT_DIPNAME( 0x40, 0x40, "Invulnerability (Cheat)") PORT_DIPLOCATION("SW2:7")
*	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
*	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
*	PORT_SERVICE_DIPLOC( 0x80, IP_ACTIVE_LOW, "SW2:8" )
*
* only lines 192-256 scroll
*
* E04C: bit 0: cocktail flip
* terrain_slope_type_E508: 
* 0/1: flat with very small bumps
TERRAIN_FLAT_00 = 0
TERRAIN_FLAT_01 = 1
* 2: flat but with bumps (normal)
TERRAIN_BUMPY_02 = 2
* 3: rising slope
TERRAIN_RISING_03 = 3
* >3: descending slope
TERRAIN_LOWERING_04 = 4


* 5 ufos max of one category? or not counting the hole makers
MAX_NB_UFOS_1 = 5
* 9 ufos max
MAX_NB_UFOS_2 = 9

* jeep states
STATE_NOTHING_00 = 0
STATE_REPOSITION_DEFAULT_01 = 1
STATE_NORMAL_02 = 2
STATE_JUMP_START_03 = 3
START_JUMPING_04 = 4
STATE_FALL_IN_HOLE_06 = 6
STATE_EXPLODING_07 = 7
STATE_HOLD_IN_AIR_08 = 8

* obj_type is an index that allows to fetch object characteristics in a ROM
* table. For instance, UFO is 0x2A, another ufo is 0x30
* command/object structure is 16 bytes long
* X and Y coordinates are actually 16-bit. The displayed part is the MSB, where the LSB
* is used like "floating point" or "decimal" part, to be able to use fine speed changes
obj_command = 0
obj_x_decimal = 2
obj_x = 3
obj_x_speed_decimal = 4
obj_x_speed = 5
obj_y_decimal = 6
obj_y = 7
obj_y_speed_decimal = 0x8
obj_y_speed = 0x9
obj_next_frame_timeout = 0xA
obj_type = 0xD
obj_timeout = 0xF			| for flying objects
obj_absolute_x = 0xF		| for ground objects

    .global mpatrol_irq
    .global mpatrol_reset

	.include	"mpatrol.inc"
	.ifdef	__amiga__
	.include "mpatrol_ram.68k"
	.align	2
	.endif


	.macro CLEAR_XC_FLAGS
	moveq	#0,d7
	roxl.b	#1,d7
	.endm
	
	.macro SET_XC_FLAGS
	st	d7
	roxl.b	#1,d7
	.endm
	
	.macro	SET_X_FROM_C
	jcc		0f
	SET_XC_FLAGS
	bra.b	1f
0:
	CLEAR_XC_FLAGS
1:
	.endm
	
	.macro	INVERT_XC_FLAGS
	jcs		0f
	SET_XC_FLAGS
	bra.b	1f
0:
	CLEAR_XC_FLAGS
1:
	.endm
	
	.macro	CLR_W	address
	clr.b	\address
	clr.b	\address+1
	.endm
	
	.macro  LOAD_LEW	address,reg
	move.b	\address+1,\reg
	rol.w	#8,\reg
	move.b	\address,\reg
	.endm
	
	.macro  STORE_LEW	reg,address
	move.b	\reg,\address
	rol.w	#8,\reg
	move.b	\reg,\address+1
	rol.w	#8,\reg
	.endm
	
	
	.macro	LOAD_D1_16_FROM_D1D2
	and.l	#0xFFFF,d1
	lsl.w	#8,d1
	move.b	d2,d1
	.endm
	
	.macro	LOAD_D3_16_FROM_D3D4
	and.l	#0xFFFF,d3
	lsl.w	#8,d3
	move.b	d4,d3
	.endm
	.macro	LOAD_D5_16_FROM_D5D6
	and.l	#0xFFFF,d5
	lsl.w	#8,d5
	move.b	d6,d5
	.endm
	.macro	LOAD_D1D2_FROM_D1_16
	move.b	d1,d2
	lsr.w	#8,d1
	.endm
	.macro	LOAD_D5D6_FROM_D5_16
	move.b	d5,d6
	lsr.w	#8,d5
	.endm
	.macro	LOAD_D3D4_FROM_D3_16
	move.b	d3,d4
	lsr.w	#8,d3
	.endm

	.macro	LOAD_VIDEORAM_ADDRESS	val
	move.w	#\val,d7
	.endm
	.macro	LOAD_COLORRAM_ADDRESS	val
	move.w	#\val,d7
	.endm
	
	.macro	WRITE_VIDEORAM			val
	move.w	d0,-(sp)
	move.b	\val,d0
	jbsr	osd_w_videoram
	move.w	(sp)+,d0
	.endm

	
assert_failed:
	jra		osd_break
	
get_ram_address_d5_to_a0:
	lea		revolving_buffer_8_E000-0xE000,a0	| virtual ram start
	.ifndef	RELEASE
	cmp.w	#0xE000,d5
	bcs.b	0f
	cmp.w	#0xE800,d5
	bcs.b	1f
0:
	* D5 is not between E000 and E800: fail
	jbsr	assert_failed
	nop
	rts
1:
	.endif
	add.w	d5,a0
	rts
	
	
get_rom_address_d3_to_a1:
	lea	game_rom,a1
	cmp.w	#0x4000,d3	| no_fail
	bcc.b	0f
	add.w	d3,a1		| no_fail
	rts
0:
	jbsr	assert_failed
	nop
	rts
	
get_rom_address_d5_to_a0:
	lea	game_rom,a0
	cmp.w	#0x4000,d5	| no_fail
	bcc.b	0f
	add.w	d5,a0		| no_fail
	rts
0:
	jbsr	assert_failed
	nop
	rts

clear_video_area:
	moveq	#0,d0
	subq	#1,d1
0:
	jbsr	osd_w_videoram
	addq.w	#1,d7
	dbf		d1,0b
	rts
	
clear_color_area:
	moveq	#0,d0
	subq	#1,d1
0:
	jbsr	osd_w_colorram
	addq.w	#1,d7
	dbf		d1,0b
	rts


mpatrol_reset:
	.ifndef	RELEASE
	tst.b	break_at_startup_flag
	beq.b	0f
	* put anything here that you need to track addresses
	move.l	#bg_videoram,d7
	jbsr	osd_break
0:
	.endif
	
l_0000:
    jbsr  osd_disable_interrupts  | [di]
	lea	stack_top_E800,sp   | [ld   sp,unknown_E800]
	jbsr	osd_enable_interrupts
	*jbsr	osd_read_dsw_2                       	| [$0006: ld   a,($D004)] -  Service mode ...
	*tst.b	d0                              	| [$0009: and  a] -  ... switch set?
	*jpl	service_mode_3300                  	| [$000a: jp   p,service_mode_3300] -  0=Yes ... go do service mode (not in the same ROM chip but should be)
	jbsr	clear_ram_05f4                    	| [$000d: call clear_ram_05f4] -  Clear RAM (E000..E6FF)
	jbsr	read_settings_06f2                            	| [$0010: call $06F2] -  Read the dip-switch settings
	jbsr	l_0d29                            	| [$0013: call $0D29] -  ?? Clear screen, screen flip, clear ram mirror, clear sound queue
	jra	startup_cont_0068                             	| [$0016: jp   $0068] -  Continue startup

rst_28:
* < HL: jump table
* < A: index
	and.w	#0xFF,d0
	add.w	d0,d0                            	| [$0028: add  a,a] -  A*2 ...
	add.w	d0,d0                            	| [$0028: add  a,a] -  A*2 ...
	move.l	(a0,d0.w),a0                           	| [$0029: ld   e,a] -  ... to ...
	jra	(a0)                               	| [$0031: jp   (hl)] -  Jump to routine


* This is triggered every VBLANK ... 56.74Hz.
* -Copy RAM mirror to hardware registers
* -Bump the counters (E04E++, E04F every 16, E050--, E051--)
* -If in service mode twiddle timer, kill time, and out
* -Game mode:
*  -
*

mpatrol_irq:
mpatrol_irq_0038:
	exg	d0,d7                              	| [$0038: ex   af,af'] -  Switch to ...
	jbsr	exx                               	| [$0039: exx] -  ... interrupt-handlers registers
	jbsr	reg_mirror_056d               	| [$003a: call reg_mirror_056d] -  Copy RAM mirror to hardware at start of VBLANK
	lea	timer_8bit_E04E,a0                	| [$003d: ld   hl,timer_8bit_E04E] -  Counter area
	addq.b	#1,(a0)                         	| [$0040: inc  (hl)] -  Bump the counter byte
	move.b	(a0)+,d0                         	| [$0041: ld   a,(hl)] -  Get counter value
	                           	| [$0042: inc  hl] -  Next counter byte
	and.b	#0x0F,d0                         	| [$0043: and  $0F] -  Did we overflow first nibble?
	jne	l_0048                             	| [$0045: jr   nz,$0048] -  No ... skip bumping second
	addq.b	#1,(a0)                         	| [$0047: inc  (hl)] -  Increment 2nd counter byte
l_0048:
	addq.w	#1,a0                           	| [$0048: inc  hl] -  Next counter byte * J0045
	subq.b	#1,(a0)+                         	| [$0049: dec  (hl)] -  -1
	                           	| [$004a: inc  hl] -  Next counter byte
	subq.b	#1,(a0)                         	| [$004b: dec  (hl)] -  -1
	jbsr	osd_read_dsw_2                       	| [$004c: ld   a,($D004)] -  Are we ...
	tst.b	d0                               	| [$004f: and  a] -  ... in service mode?
	jmi	l_0093                             	| [$0050: jp   m,$0093] -  No ... process game
	lea	timer_8bit_E04E,a0                	| [$0053: ld   hl,timer_8bit_E04E] -  Point to counter1
	addq.b	#1,(a0)                         	| [$0056: inc  (hl)] -  Bump it again (will dec it in 3)
	move.b	#0x00,d1                        	| [$0057: ld   bc,$0003] 3 -  Count of 3*256
	move.b	#0x03,d2                        	| [$0057: ld   bc,$0003] 3 -  Count of 3*256
	lea	timer_8bit_E04E,a0                	| [$005a: ld   hl,timer_8bit_E04E] -  Point to counter1 again
	subq.b	#1,(a0)                         	| [$005d: dec  (hl)] -  Bump back down
l_005e:
	subq.b	#1,d1                           	| [...]
	jne	l_005e                             	| [$005e: djnz $005E] -  Inner count 256 * J005E,J0061
	subq.b	#1,d2                           	| [$0060: dec  c] -  Outer count ...
	jne	l_005e                             	| [$0061: jr   nz,$005E] -  ... 3 (3*256 total)
	jbsr	exx                               	| [$0063: exx] -  Restore main ...
	exg	d0,d7                              	| [$0064: ex   af,af'] -  ... registers
    jbsr  osd_enable_interrupts  | [ei]
	rts                                    	| [$0067: ret] -  Ignore

startup_cont_0068:
    jbsr  osd_enable_interrupts  | [ei]
	jbsr	display_status_bar_0b8a           	| [$0069: call display_status_bar_0b8a]
	move.b	#0x01,d0                        	| [$006c: ld   a,$01]
	move.b	d0,title_display_timer_E04D           | [$006e: ld   (title_display_timer_E04D),a]
	move.b	d0,moonbase_already_displayed_E50F       | [$0071: ld   (moonbase_already_displayed_E50F),a]
	                           	| [$0074: inc  a]
	* normal terrain: flat with bumps
	move.b	#TERRAIN_BUMPY_02,terrain_slope_type_E508                 	| [$0075: ld   (terrain_slope_type_E508),a]
	jra	start_new_section_0bb7                             	| [$0078: jp   $0BB7]
l_007b:
	clr.b	d1                               	| [$007b: ld   b,$00] -  * J0504
l_007d:
	clr.b	d0                               	| [$007d: xor  a] -  * J0091
	move.b	d0,title_display_timer_E04D                 	| [$007e: ld   (title_display_timer_E04D),a]
	lea	game_status_bits_E046,a0                	| [$0081: ld   hl,game_status_bits_E046]
	move.b	d1,(a0)                         	| [$0084: ld   (hl),b]
    jbsr  osd_enable_interrupts  | [ei]
	jbsr	l_0745                            	| [$0086: call $0745]
	jbsr	display_status_bar_0b8a           	| [$0089: call display_status_bar_0b8a]
	jra	start_new_section_0bb7                             	| [$008c: jp   $0BB7]
l_008f:
	move.b	#0x04,d1                        	| [$008f: ld   b,$04] -  * J00EF
	jra	l_007d                             	| [$0091: jr   $007D]

l_0093:
	jbsr	sound_stuff_05cb                            	| [$0093: call $05CB] -  Play next waiting sound (if any) * J0050
	jbsr	osd_read_in_0                       	| [$0096: ld   a,($D000)] -  Coins and start
	not.b	d0                               	| [$0099: cpl] -  Active high
	move.b	d0,coin_start_e053                 	| [$009a: ld   (coin_start_e053),a] -  Hold for whoever wants it
	* player 2 start
	btst.b	#1,d0                           	| [$009d: bit  1,a] -  Start-2 pressed?
	jeq	l_00b6                             	| [$009f: jr   z,$00B6] -  No ... move on
	jbsr	osd_read_dsw_2                       	| [$00a1: ld   a,($D004)] -  DSW2
	btst.b	#4,d0                           	| [$00a4: bit  4,a] -  Stop-mode cheat switch flipped?
	jne	l_00b6                             	| [$00a6: jr   nz,$00B6] -  No ... move on
	lea	game_status_bits_E046,a0                	| [$00a8: ld   hl,game_status_bits_E046] -  ??
	btst.b	#1,(a0)                         	| [$00ab: bit  1,(hl)] -  ??
	jne	l_00b6                             	| [$00ad: jr   nz,$00B6] -  Skip the pause
l_00af:
* Stop-mode switch and start-2 pressed (pause game, but not sound)
	jbsr	osd_read_in_0                       	| [$00af: ld   a,($D000)] -  Start buttons * J00B4
	and.b	#0x01,d0                         	| [$00b2: and  $01] -  Is start-1 pressed?
	jne	l_00af                             	| [$00b4: jr   nz,$00AF] -  No ... wait for it
l_00b6:
	jbsr	osd_read_dsw_2                       	| [$00b6: ld   a,($D004)] -  DSW2 again * J009F,J00A6,J00AD
	btst.b	#3,d0                           	| [$00b9: bit  3,a] -  ?? unused switch
	jne	l_00c3                             	| [$00bb: jr   nz,$00C3] -  Not flipped ... move on
	lea	unknown_E0F3,a0                	| [$00bd: ld   hl,unknown_E0F3] -  Bump ...
	addq.b	#1,(a0)                         	| [$00c0: inc  (hl)] -  ... ?? mysterious counter
	                         	| [$00c1: bit  0,(hl)] -  ?? Old code left behind? The flags are never used
l_00c3:

	move.l	a3,-(sp)                        	| [$00c3: push iy] -  Preserve these ... * J00BB,J05B7

	move.l	a2,-(sp)                        	| [$00c5: push ix] -  .. since the others are EXX to safety
	jbsr	coins_and_credits_040e                            	| [$00c7: call $040E] -  Handle coins and credits
	move.b	free_play_E041,d0                 	| [$00ca: ld   a,(free_play_E041)] -  Coin mode slot A
	                               	| [$00cd: and  a] -  Free play?
	jne	l_00d5                             	| [$00ce: jr   nz,$00D5] -  No ... keep credits
	move.b	#0x02,d0                        	| [$00d0: ld   a,$02] -  Free play ...
	move.b	d0,credits_e048              	| [$00d2: ld   (credits_e048),a] -  ... always 2 credits
l_00d5:
	lea	game_status_bits_E046,a0                	| [$00d5: ld   hl,game_status_bits_E046] -  * J00CE
	move.b	(a0),d1                         	| [$00d8: ld   b,(hl)]
	btst.b	#7,d1                           	| [$00d9: bit  7,b]
	jne	l_00f2                             	| [$00db: jr   nz,$00F2]
	btst.b	#1,d1                           	| [$00dd: bit  1,b]
	jne	l_00fc                             	| [$00df: jr   nz,$00FC]
	move.b	credits_e048,d0              	| [$00e1: ld   a,(credits_e048)]
	                               	| [$00e4: and  a]
	jne	l_0104                             	| [$00e5: jr   nz,$0104]
	btst.b	#2,d1                           	| [$00e7: bit  2,b]
	jne	l_00fc                             	| [$00e9: jr   nz,$00FC]
	move.b	cnt_till_cred_e047,d0                 	| [$00eb: ld   a,(cnt_till_cred_e047)]
	                               	| [$00ee: and  a]
	jne	l_008f                             	| [$00ef: jp   nz,$008F]
l_00f2:
	btst.b	#0,d1                           	| [$00f2: bit  0,b] -  * J00DB
	jeq	l_00fc                             	| [$00f4: jr   z,$00FC] -  Skip game objects
	jbsr	get_inputs_047a                            	| [$00f6: call $047A] -  Get inputs (or demo mode ??)
	jbsr	run_objects_01ec                            	| [$00f9: call $01EC] -  Run the game objects
l_00fc:
	move.l	(sp)+,a2                        	| [$00fc: pop  ix] -  Restore IX and ... * J00DF,J00E9,J00F4
	move.l	(sp)+,a3                        	| [$00fe: pop  iy] -  ... IY
	jbsr	exx                               	| [$0100: exx] -  Restore the other ...
 	exg	d0,d7                              	| [$0101: ex   af,af'] -  ... registers
    jbsr  osd_enable_interrupts  | [ei]
	rts                                    	| [$0103: ret] -  Done with ISR

l_0104:
	move.b	#0x02,(a0)                      	| [$0104: ld   (hl),$02] -  * J00E5
	lea		stack_top_E800,sp		| ld   sp,unknown_E800
    jbsr  osd_enable_interrupts  | [ei]
	jbsr	l_0d29                            	| [$010a: call $0D29]
l_010d:
	jbsr	l_0533                            	| [$010d: call $0533] -  * J0110
	jeq	l_010d                             	| [$0110: jr   z,$010D]
	jbsr	l_0b38                            	| [$0112: call $0B38]
	jra	start_new_section_0bb7                             	| [$0115: jp   $0BB7]
l_0118:
	lea		stack_top_E800,sp		| ld   sp,unknown_E800
	lea	game_status_bits_E046,a0                	| [$011b: ld   hl,game_status_bits_E046]
	subq.b	#1,(a0)                         	| [$011e: dec  (hl)]
    jbsr  osd_enable_interrupts  | [ei]
	jpl	startup_cont_0068                             	| [$0120: jp   p,$0068]
	jbsr	l_0b96                            	| [$0123: call $0B96]
	clr.b	d0                               	| [$0126: xor  a]
	move.b	d0,unknown_E1A6                 	| [$0127: ld   (unknown_E1A6),a]
	lea	nb_lives_E515,a0               	| [$012a: ld   hl,nb_lives_E515]
	subq.b	#1,(a0)                         	| [$012d: dec  (hl)]
	jeq	l_014b                             	| [$012e: jr   z,$014B]
	jbsr	display_nb_lives_06d5                            	| [$0130: call $06D5]
	lea	game_status_bits_E046,a0                	| [$0133: ld   hl,game_status_bits_E046]
	btst.b	#4,(a0)                         	| [$0136: bit  4,(hl)]  player 2?
	jeq	start_new_section_0bb7                             	| [$0138: jp   z,$0BB7]
	jbsr	swap_players_0603                            	| [$013b: call $0603]
	move.b	nb_lives_E515,d0                	| [$013e: ld   a,(nb_lives_E515)]
	                               	| [$0141: and  a]
	jne	start_new_section_0bb7                             	| [$0142: jp   nz,$0BB7]
	jbsr	swap_players_0603                            	| [$0145: call $0603]
	jra	start_new_section_0bb7                             	| [$0148: jp   $0BB7]
l_014b:
	move.b	#0x1B,d0                        	| [$014b: ld   a,$1B] -  Play ... * J012E
	jbsr	queue_sound_effect_if_game_playing_0d75                            	| [$014d: call $0D75] -  ... ending music
	lea	game_status_bits_E046,a0                	| [$0150: ld   hl,game_status_bits_E046]
	btst.b	#4,(a0)                         	| [$0153: bit  4,(hl)]
	jeq	l_0176                             	| [$0155: jr   z,$0176]
	lea	game_rom+0x2AED,a0                      	| [$0157: ld   hl,$2AED] -  "GAME OVER PLAYER " script
	jbsr	write_text_to_screen_at_xy_with_delay_034e                            	| [$015a: call $034E]
	move.b	game_status_bits_E046,d0                 	| [$015d: ld   a,(game_status_bits_E046)]
	ror.b	#3,d0                           	| [$0160: rra] * 3
	and.b	#0x01,d0                         	| [$0163: and  $01]
	addq.b	#1,d0                           	| [$0165: inc  a]
	jbsr	print_digit_03bd                            	| [$0166: call $03BD]
	jbsr	swap_players_0603                            	| [$0169: call $0603]
	jbsr	delay1_sec_05e4                            	| [$016c: call $05E4]
	move.b	nb_lives_E515,d0                	| [$016f: ld   a,(nb_lives_E515)]
	                               	| [$0172: and  a]
	jne	start_new_section_0bb7                             	| [$0173: jp   nz,$0BB7]
l_0176:
	lea	game_rom+0x2B02,a0                      	| [$0176: ld   hl,$2B02] -  "GAME OVER" script * J0155
	jbsr	write_text_to_screen_at_xy_with_delay_034e                            	| [$0179: call $034E]
	jbsr	is_player_2_061c                            	| [$017c: call $061C]
	jeq	l_0184                             	| [$017f: jr   z,$0184]
	jbsr	swap_players_0603                            	| [$0181: call $0603]
l_0184:
	jbsr	delay3_sec_05e8                            	| [$0184: call $05E8] -  * J017F
	jbsr	l_0d29                            	| [$0187: call $0D29]
	* write continue prompt (with typo, that I have fixed in ROM)
	lea	game_rom+0x2A2A,a0                      	| [$018a: ld   hl,$2A2A] -  "TO COUNTINUE GAME" (sic) script
	jbsr	write_to_screen_possible_typing_effect_300                            	| [$018d: call $0300] -  Print it
	move.b	#0x11,d0                        	| [$0190: ld   a,$11]  number of seconds of timer
l_0192:
	tst.b	d0                               	| [$0192: and  a] -  * J01AE
	jeq	l_01d2                             	| [$0193: jr   z,$01D2]
	moveq	#1,d7
	sbcd	d7,d0                           	| [$0195: dec  a + daa]
	move.b	d0,continue_timer_E054                 	| [$0197: ld   (continue_timer_E054),a]
	lea	0x8233,a1                      	| [$019a: ld   de,$8233]
	move.b	#0x02,d2                        	| [$019d: ld   c,$02]
	jbsr	set_character_at_address_03ae                            	| [$019f: call $03AE]
	move.b	#0x40,d0                        	| [$01a2: ld   a,$40]
	move.b	d0,sync_flag_E050                 	| [$01a4: ld   (sync_flag_E050),a]
	st.b	in_continue_loop_flag
l_01a7:
	                               	| [$01aa: and  a]
	move.b	continue_timer_E054,d0                 	| [$01ab: ld   a,(continue_timer_E054)]
	tst.b	sync_flag_E050                 	| [$01a7: ld   a,(sync_flag_E050)] -  * J01BF,J01C4
	jeq	l_0192                             	| [$01ae: jr   z,$0192]
	move.b	credits_e048,d0              	| [$01b0: ld   a,(credits_e048)]
	                               	| [$01b3: and  a]
	jne	l_01c1                             	| [$01b4: jr   nz,$01C1]
	lea	game_rom+0x2C57,a0                      	| [$01b6: ld   hl,$2C57] -  "INSERT COIN" script
	jbsr	flash_script_0374                            	| [$01b9: call $0374]
	jbsr	print_creds_0527                            	| [$01bc: call $0527]
	jra	l_01a7                             	| [$01bf: jr   $01A7]
l_01c1:
	* test if start button pressed
	jbsr	l_0533                            	| [$01c1: call $0533] -  * J01B4
	jeq	l_01a7                             	| [$01c4: jr   z,$01A7]
	clr.b	in_continue_loop_flag
	jbsr	l_01da                            	| [$01c6: call $01DA]
	jbsr	l_01da                            	| [$01c9: call $01DA]
	jbsr	l_0cbf                            	| [$01cc: call $0CBF]
	jra	start_new_section_0bb7                             	| [$01cf: jp   $0BB7]

l_01d2:
    jbsr  osd_disable_interrupts  | [di]
	clr.b	d0                               	| [$01d3: xor  a]
	move.b	d0,game_status_bits_E046                 	| [$01d4: ld   (game_status_bits_E046),a]
	jra	startup_cont_0068                             	| [$01d7: jp   $0068]

l_01da:
	move.b	lives_per_credit_e040,d0                 	| [$01da: ld   a,(lives_per_credit_e040)] -  * C01C6,C01C9
	move.b	d0,nb_lives_E515                	| [$01dd: ld   (nb_lives_E515),a]
	                      	| [$01e0: ld   hl,$0000] 0
	CLR_W	player_score_E500                 	| [$01e3: ld   (player_score_E500),hl]
	CLR_W	cur_score2_e502                 	| [$01e6: ld   (cur_score2_e502),hl]
	jra	swap_players_0603                             	| [$01e9: jp   $0603]


run_objects_01ec:
	* jump according to jeep state
	* 2: normal
	* 4: jumping
	* 6: falling in hole
	* 7: exploding
	* jeep params is only one of the buffers/objects (the first one)
	* another block is in E320: forward_shot_indicator_E320
	* first byte is the command (the index of the routine in jump table)
	lea	jeep_params_E300,a2                	| [$01ec: ld   ix,jeep_params_E300] -  Pointer to command buffer (32 slots of 16 bytes) * C00F9
	move.b	#0x20,d0                        	| [$01f0: ld   a,$20] -  32 command slots
	move.b	d0,command_number_of_slots_E0E8                 	| [$01f2: ld   (command_number_of_slots_E0E8),a] -  Hold the count
l_01f5:
	move.b	(a2),d0                    	| [$01f5: ld   a,(ix+$00)] -  Get the command number * J0209
	subq.b	#1,d0                           	| [$01f8: dec  a] -  0 means "invalid"
	jmi	l_0200                             	| [$01f9: jp   m,$0200] -  Not a valid command. Skip it
	.ifndef	RELEASE
	* check that command is within range
	cmp.b	#49,d0
	bcs.b	0f
	* > 48: there's a problem: which object is at fault?
	sub.l	#jeep_params_E300-0xE300,a2
	jbsr	osd_break
	illegal
0:
	.endif
	
	lea	jump_table_020C,a0             	| [$01fc: ld   hl,jump_table_020C] -  Routine jump table table
	jbsr	rst_28                            	| [$01ff: rst  $28] use jump table -  Call the routine by index number

l_0200:
											| [$0200: ld   de,$0010] 16 -  Bytes to next slot * J01F9
	add.w	#0x10,a2                            	| [$0203: add  ix,de] -  Point to next slot
	lea	command_number_of_slots_E0E8,a0                	| [$0205: ld   hl,command_number_of_slots_E0E8] -  Get current count
	subq.b	#1,(a0)                         	| [$0208: dec  (hl)] -  Decrement the count
	jne	l_01f5                             	| [$0209: jr   nz,$01F5] -  Do all 32 slots
	rts                                    	| [$020b: ret] -  Done

jump_table_020C:
	.long	course_start_1311                | 0
	.long	jeep_moving_on_track_1331        | 1
	.long	init_jump_1370                   | 2
	.long	jeep_jumping_1388                | 3
	.long	jeep_landing_13bc                | 4
	.long	jeep_falling_in_hole_13c2        | 5
	.long	handle_jeep_explosion_13eb       | 6
	.long	display_moon_patrol_title_1421   | 7
	.long	update_scrolling_layers_1809     | 8
	.long	init_forward_shot_15e0           | 9
	.long	handle_forward_shot_15fa         | 10
	.long	forward_shot_exploding_162d      | 11
	.long	forward_shot_exploding_162d      | 12
	.long	init_vertical_shot_1649          | 13
	.long	handle_vertical_shot_165d        | 14
	.long	clear_vertical_shot_168f         | 15
	.long	update_yellow_tank_shot_193d     | 16
	.long	update_rock_1957				 | 17
	.long	check_if_fall_in_hole_195e       | 18
	.long	update_volcano_19d1              | 19
	.long	exploding_volcano_1a2f           | 20
	.long	update_rolling_rock_1a44         | 21
	.long	rear_missile_following_1a92      | 22
	.long	rear_missile_following_1ab9      | 23
	.long	rear_missile_following_1af0      | 24
	.long	rear_missile_attacking_1b01      | 25
	.long	rear_missile_sitting_duck_1b27   | 26
	.long	jeep_bombed_1433                 | 27
	.long	update_yellow_tank_18e0          | 28
	.long	ufo_appearing_1eaa               | 29 blue ufo appearing, transitions to 30
	.long	animate_ufo_1f28                 | 30 blue ufo update
	.long	ufo_shot_20ac                    | 31
	.long	show_kill_score_20c4             | 32
	.long	ufo_appearing_1eaa               | 33 ufo appearing, transitions to 34
	.long	animate_ufo_1f28                 | 34 ufo flying
	.long	ufo_appearing_2000               | 35
	.long	animate_ufo_201a                 | 36
	.long	ufo_appearing_1ea4               | 37 ufo appearing, transitions to 38
	.long	animate_ufo_1f28                 | 38 ufo transition??? then 34
	.long	ufo_init_crash_on_player_204d    | 39
	.long	ufo_crashing_on_player_209c      | 40
	.long	handle_hole_making_bombs_1d23    | 41
	.long	hole_making_bomb_explodes_1df3   | 42
	.long	bomb_creates_hole_1e51           | 43
	.long	bomb_shot_1e9b                   | 44
	.long	init_standard_ufo_bomb_1c9b      | 45
	.long	update_standard_ufo_bomb_1cbc    | 46
	.long	init_ground_explosion_1e14       | 47
	.long	update_ground_explosion_1e29     | 48
                                  
game_mainloop_026e:
	jbsr	handle_path_advance_0ddc            | [$026e: call $0DDC] -  ?? Change terrain
	jbsr	handle_time_210d                    | [$0271: call $210D] -  Draw "point letter" in upper center status window
	jbsr	handle_ufo_shots_1b3a               | [$0274: call $1B3A] -  ?? Start UFO shot
	jbsr	handle_flying_enemies_1bc7          | [$0277: call $1BC7] -  ?? Init aliens
	jbsr	update_alien_sounds_12a7   		  	| [$027a: call $12A7] -  ?? Alien sounds
	jbsr	l_12e7                            	| [$027d: call $12E7] -  ??
	jbsr	handle_path_advance_0ddc                            	| [$0280: call $0DDC] -  ?? Change terrain
	move.b	com_list_head_e1cf,d0                 	| [$0283: ld   a,(com_list_head_e1cf)] -  LSB of head of text command list
l_0286:
	lea	event_buffer_index_E1D0,a0                	| [$0286: ld   hl,event_buffer_index_E1D0] -  Next available text command pointer * J02AB
	cmp.b	(a0),d0                          	| [$0289: cp   (hl)] -  Have we reached the end of the list?
	jeq	game_mainloop_026e                             	| [$028a: jr   z,$026E] -  Yes ... back to the top
	moveq	#0,d4
	move.b	d0,d4                           	| [$028c: ld   e,a] -  IX ...
	* set IX at $E600+offset                   	| [$028d: ld   d,$E6] -  ... becomes ...
	lea		unknown_E600,a2                      	| [$028f: ld   ix,$0000] 0 -  ... E6xx ...
	add.w	d4,a2                            	| [$0293: add  ix,de] -  ... pointer to current ??command
	move.b	(a2),d2                    	| [$0295: ld   c,(ix+$00)] -  Get command address
	asl.b	#1,d2                            	| [$0298: sla  c] -  Two bytes per jump address
	jne	l_02ad                             	| [$029a: jr   nz,$02AD] -  0 means no-command. Otherwise run it.
	lea	com_list_head_e1cf,a0                	| [$029c: ld   hl,com_list_head_e1cf] -  Is this inactive command ...
	cmp.b	(a0),d0                          	| [$029f: cp   (hl)] -  .. the first command in the list?
	jne	l_02a5                             	| [$02a0: jr   nz,$02A5] -  No ... the "first" pointer is OK
	addq.b	#0x04,d0                        	| [$02a2: add  a,$04] -  Remove this command ...
	move.b	d0,(a0)                         	| [$02a4: ld   (hl),a] -  ... from the head of the list
l_02a5:
	* convert address to offset back again
	sub.l	#unknown_E600,a2               	| [$02a5: push ix] -  Pointer ... * J02A0
	move.w	a2,d0                    	| [$02a7: pop  bc] -  ... to BC
	* next item									| [$02a8: ld   a,c] -  LSB plus ...
	addq.b	#0x04,d0                        	| [$02a9: add  a,$04] -  ... 4 (next object LSB in A)
	jra	l_0286                             	| [$02ab: jr   $0286] -  Loop over all objects in list
l_02ad:
	clr.w	d1                               	| [$02ad: ld   b,$00] -  Reset command value ... * J029A
	clr.b	(a2)                    	| [$02af: ld   (ix+$00),b] -  ... so (default) doesn't run again
	move.b	d2,d1
	add.w	d1,d1				| one more shift for 32 bit jump
	move.b	(0x01,a2),d0                    	| [$02b2: ld   a,(ix+$01)] -  Parameter data e.g. ISR count or score-adjust
	* push return address
	pea		l_02a5                      	| [$02b5: ld   hl,$02A5] -  Return to ...

	                        	| [$02b8: push hl] -  ... 2A5
	lea	jump_table_02D3,a0             	| [$02b9: ld   hl,jump_table_02D3] -  Jump table (back up one entry ... first entry is 1)
										| [$02bc: add  hl,bc] -  Offset to jump address
	move.l	(a0,d1.w),a0
											| [$02bd: ld   c,(hl)] -  LSB to C
											| [$02be: inc  hl] -  SKip over
											| [$02bf: ld   h,(hl)] -  MSB to H
											| [$02c0: ld   l,c] -  Now LSB to L
	* will return to l_02a5
	jra	(a0)                               	| [$02c1: jp   (hl)] -  Jump to routine (return to 2A5)

* called when score increases
* stores values of d2,d0,d4,d3 in a revolving buffer in E600
store_special_event_02c2:
	moveq	#0,d7
	move.b	event_buffer_index_E1D0,d7                	| [$02c2: ld   hl,event_buffer_index_E1D0] -  LSB of next-available text command * J0518,C1528,C1778,C1789,C17A3,J17E7,J19CE,C1DE7,C1E7A
	                         	| [$02c5: ld   l,(hl)] -  Set HL to ...
	lea	unknown_E600,a0                        	| [$02c6: ld   h,$E6] -  ... E6xx
	add.w	d7,a0
	move.b	d2,(a0)+                         	| [$02c8: ld   (hl),c] -  Set command number
	                           	| [$02c9: inc  hl] -  Next
	move.b	d0,(a0)+                         	| [$02ca: ld   (hl),a] -  Store text command parameter ... ISR value or score-adjust
	                           	| [$02cb: inc  hl] -  Next
	move.b	d4,(a0)+                         	| [$02cc: ld   (hl),e] -  Store ...
	                           	| [$02cd: inc  hl] -  ... text-script ...
	move.b	d3,(a0)                         	| [$02ce: ld   (hl),d] -  ... pointer
	                           	| [$02cf: inc  l] -  Next
	addq	#4,d7
	move.b	d7,event_buffer_index_E1D0                           	| [$02d0: ld   a,l] -  New LSB ...
	                 	| [$02d1: ld   (event_buffer_index_E1D0),a] -  ... of next available text command
	rts                                    	| [$02d4: ret] -  Done
* the jump table

jump_table_02D3:
	.long	l_0000                           	|  overlaps ret instruction, probably never used
	.long	l_0622
	.long	txt_cmd_02_02fa
	.long	l_02ed
	.long	l_0322
	.long	txt_cmd_05_032f
	.long	l_0367
	.long	wait_for_sync_0361
	.long	l_0337
	.long	ufo_bomb_creates_hole_0da6
	.long	l_1201
	.long	display_title_1218


l_02ed:
	move.b	timer_8bit_E04E,d0                 	| [$02ed: ld   a,(timer_8bit_E04E)] -  Get current ISR value
	add.b	(0x01,a2),d0                     	| [$02f0: add  a,(ix+$01)] -  Add time ...
	move.b	d0,(0x01,a2)                    	| [$02f3: ld   (ix+$01),a] -  ... offset to next run
	move.b	#0x04,(a2)                 	| [$02f6: ld   (ix+$00),$04] -  Next pass execute the "wait for time" state
txt_cmd_02_02fa:
	move.b	(0x02,a2),d6                    	| [$02fa: ld   l,(ix+$02)] -  Get script ... * C036C
	move.b	(0x03,a2),d5                    	| [$02fd: ld   h,(ix+$03)] -  ... pointer (fall into run)
	LOAD_D5D6_FROM_D5_16
	bsr		get_rom_address_d5_to_a0
write_to_screen_possible_typing_effect_300:
	jbsr	compute_screen_address_and_attribute_03db                            	| [$0300: call $03DB] -  Get screen pointer and color from script * C018D,J0379,C052A,C0548,C074B,C0B47,C0C31,C0C89,C0CEA,C0D06,J1258,C1285,C27EA,C27F3
l_0303:
	* handle special delay effects that simulate typing
	* if command is found in input data
	move.b	(a0),d0                         	| [$0303: ld   a,(hl)] -  Get command * J031B,J0320
	move.b	#0x12,d1                        	| [$0304: ld   b,$12] -  18 ISR delay (0.3 seconds)
	cmp.b	#0x26,d0                         	| [$0306: cp   $26] -  26 ...
	jeq	l_0310                             	| [$0308: jr   z,$0310] -  ... 0.3 second delay
	move.b	#0x30,d1                        	| [$030a: ld   b,$30] -  48 ISR delay (0.8 seconds)
	cmp.b	#0x27,d0                         	| [$030c: cp   $27] -  27 ... 0.8 second delay
	jne	l_031d                             	| [$030e: jr   nz,$031D] -  Not a delay ... do normal
l_0310:
	addq.w	#1,a0                           	| [$0310: inc  hl] -  Skip delay command value * J0308


	move.b	d1,d0                           	| [$0311: ld   a,b] -  Set ISR ...
	* typing wait effect
	move.b	d0,sync_flag_E050                 	| [$0312: ld   (sync_flag_E050),a] -  count down
l_0315:
	move.b	sync_flag_E050,d0                 	| [$0315: ld   a,(sync_flag_E050)] -  ISR counted ... * J0319
	                               	| [$0318: and  a] -  ... to 0 ?
	jne	l_0315                             	| [$0319: jr   nz,$0315] -  No ... keep waiting
	jra	l_0303                             	| [$031b: jr   $0303] -  Back to top of loop
l_031d:
	jbsr	write_to_screen_03c9                            	| [$031d: call $03C9] -  Process normal character or command sequence * J030E
	jra	l_0303                             	| [$0320: jr   $0303] -  Back to top of loop
l_0322:
	move.b	timer_8bit_E04E,d0                 	| [$0322: ld   a,(timer_8bit_E04E)] -  Count from ISR
	cmp.b	(0x01,a2),d0                     	| [$0325: cp   (ix+$01)] -  Target count value
	jeq	txt_cmd_05_032f                             	| [$0328: jr   z,$032F] -  It is time to run script
	move.b	#0x04,(a2)                 	| [$032a: ld   (ix+$00),$04] -  Stay in this state (the main run loop clears this)
	rts                                    	| [$032e: ret] -  Done
txt_cmd_05_032f:
	move.b	(0x02,a2),d6                    	| [$032f: ld   l,(ix+$02)] -  Get the ... * J0328,C033D
	move.b	(0x03,a2),d5                    	| [$0332: ld   h,(ix+$03)] -  ... script pointer
	LOAD_D5_16_FROM_D5D6
	lea		game_rom,a0
	add.l	d5,a0
	jra	erase_script_037b                             	| [$0335: jr   $037B] -  Erase the script and done
l_0337:
	move.b	sync_flag_E050,d0                 	| [$0337: ld   a,(sync_flag_E050)] -  Count-down ...
	                               	| [$033a: and  a] -  ... reached 0?
	jne	l_0349                             	| [$033b: jr   nz,$0349] -  No ... go to state 7
	jbsr	txt_cmd_05_032f                            	| [$033d: call $032F] -  Erase the script
	subq.b	#1,(0x01,a2)                    	| [$0340: dec  (ix+$01)] -  Has this been active for requested time?
	bne.b	0f                               	| [...]
	rts                                    	| [$0343: ret  z] [...] -  Yes. Leave the command "inactive" and pulled from duty
0:
	move.b	#0x04,d0                        	| [$0344: ld   a,$04] -  No. Reset the count-down ...
	move.b	d0,sync_flag_E050                 	| [$0346: ld   (sync_flag_E050),a] -  ... timer to 4 interrupts
l_0349:
	move.b	#0x07,(a2)                 	| [$0349: ld   (ix+$00),$07] -  Transition to state 7 * J033B
	rts                                    	| [$034d: ret] -  Out
	
* < HL pointer to X/Y pos + text
write_text_to_screen_at_xy_with_delay_034e:
	jbsr	compute_screen_address_and_attribute_03db                            	| [$034e: call $03DB] -  Get screen cursor and color
l_0351:
	* appears to be an infinite loop but this 
	* can be exited to the upper level at the end of the string
	jbsr	write_to_screen_03c9                            	| [$0351: call $03C9] -  Process one script command (abort takes us back to caller) * J035F
	move.b	#0x03,d0                        	| [$0354: ld   a,$03] -  Set ...
	move.b	d0,sync_flag_E050                 	| [$0356: ld   (sync_flag_E050),a] -  ... ISR delay
l_0359:
	* jotd: problem: in that loop, sync flag can be very high, like if a concurrent long wait changed the value...
	* happens in "TIME TO REACH POINT..." for instance
	move.b	sync_flag_E050,d0                 	| [$0359: ld   a,(sync_flag_E050)] -  Has ISR counted ... * J035D
	                               	| [$035c: and  a] -  ... this down to zero?
	jeq	l_0351                             	| [$035f: jr   $0351] -  Keep processing script
	cmp.b	#4,d0
	jcs		l_0359
	* some other part tampered with the timer: restore it
	move.b	#3,sync_flag_E050
	jra	l_0359                             	| [$035d: jr   nz,$0359] -  No ... wait for zero
	
	
wait_for_sync_0361:
	move.b	sync_flag_E050,d0                 	| [$0361: ld   a,(sync_flag_E050)] -  Count-down timer ...
	                               	| [$0364: and  a] -  ... reached zero?
	jne	l_036f                             	| [$0365: jr   nz,$036F] -  No ... transition to state 8
l_0367:
	move.b	#0x04,d0                        	| [$0367: ld   a,$04] -  Set count-down timer ...
	move.b	d0,sync_flag_E050                 	| [$0369: ld   (sync_flag_E050),a] -  ... to 4 interrupts
	jbsr	txt_cmd_02_02fa                            	| [$036c: call $02FA] -  Run object script
l_036f:
	move.b	#0x08,(a2)                 	| [$036f: ld   (ix+$00),$08] -  Transition to state 8 * J0365
	rts                                    	| [$0373: ret] -  Done
flash_script_0374:
	move.b	timer_8bit_E04E,d0                 	| [$0374: ld   a,(timer_8bit_E04E)] -  ISR up counter * C01B9,C0536
	btst.b	#4,d0                           	| [$0377: bit  4,a] -  Every 16 interrupts
	jne	write_to_screen_possible_typing_effect_300                             	| [$0379: jr   nz,$0300] -  Bit set ... print text (bit cleared ... fall into erase)
erase_script_037b:
	jbsr	compute_screen_address_and_attribute_03db                            	| [$037b: call $03DB] -  Load cursor and color from script * J0335,J0389,C126D,C1327
l_037e:
	move.b	(a0)+,d0                         	| [$037e: ld   a,(hl)] -  Get next character/command * J038E,J0391
	                           	| [$037f: inc  hl] -  Next in script
	cmp.b	#0x21,d0                         	| [$0380: cp   $21] -  Abort script ...
	bne.b	0f                               	| [...]
	rts                                    	| [$0382: ret  z] [...] -  ... by returning
0:
	cmp.b	#0x23,d0                         	| [$0383: cp   $23] -  Ignore ...
	jeq	l_0390                             	| [$0385: jr   z,$0390] -  ... set-color command (Should jump to 38D)
	cmp.b	#0x22,d0                         	| [$0387: cp   $22] -  Set screen cursor ...
	jeq	erase_script_037b                             	| [$0389: jr   z,$037B] -  ... and continue script
	clr.b	d0                               	| [$038b: xor  a] -  Clear ...
	exg		a1,d7
	jbsr	osd_w_videoram		| [$038c: ld   (de),a] -  ... screen character
	exg		d7,a1
	                         	
	addq	#1,a1                           	| [$038d: inc  de] -  Back up one
	jra	l_037e                             	| [$038e: jr   $037E] -  Keep processing
l_0390:
	addq.w	#1,a0                           	| [$0390: inc  hl] -  Next in script * J0385
	jra	l_037e                             	| [$0391: jr   $037E] -  Continue running script

* < A0: pointer on 2 digits (endianness??)
* < A1: video memory to write to
write_2_digits_to_screen_0393:
	move.b	(a0),d0                         	| [$0393: ld   a,(hl)] -  Get BCD number (most significant) * C2977
	addq.w	#1,a1                           	| [$0394: inc  de] -  Skip potentially 0 leading digit
	and.b	#0x0F,d0                         	| [$0395: and  $0F] -  If the lower digit is 0 then ...
	jeq	l_039d                             	| [$0397: jr   z,$039D] -  ... skip printing it
	subq.w	#1,a1                           	| [$0399: dec  de] -  We will be printing this digit after all
* < A1: video memory to write to
write_2_digits_to_screen_039a:
	jbsr	l_03a6                            	| [$039a: call $03A6] -  Print lower BCD digit * C2924,C293A,J296E
l_039d:
	                           	| [$039d: dec  hl] -  Next less-significant BCD value * J0397
	move.b	-(a0),d0                         	| [$039e: ld   a,(hl)] -  Get BCD number
	ror.b	#4,d0                           	| [$039f: rra] * 4 -  Isolate ...
	jbsr	l_03a7                            	| [$03a3: call $03A7] -  Print digit (without color change)
	
* < A1: screen address
* < A0: points to number
l_03a6:
	move.b	(a0),d0                         	| [$03a6: ld   a,(hl)] -  Get BCD number * C039A
l_03a7:
	and.b	#0x0F,d0                         	| [$03a7: and  $0F] -  Isolate lower digit * C03A3
	add.b	#0x30,d0                         	| [$03a9: add  a,$30] -  Make it ASCII (tile number)
	exg		a1,d7
	jbsr	osd_w_videoram                         	| [$03ab: ld   (de),a] -  Store it on the screen
	exg		a1,d7
	addq.w	#1,a1                           	| [$03ac: inc  de] -  Advance screen pointer
	rts                                    	| [$03ad: ret] -  Done
	
* < A1: video address (0x8xxx)
* < D0: character code
* < D2: character attribute
set_character_at_address_03ae:
												| [$03ae: ld   iy,$0400] -  Set color memory ... * C019F,J0530,C067E,J2141
	lea		(0x400,a1),a3                            	| [$03b2: add  iy,de] -  ... pointer to same slot as tile pointer
	move.w	d0,-(sp)                        	| [$03b4: push af] -  Hold A
	ror.b	#4,d0                           	| [$03b5: rra] * 4 -  Do ...
	jbsr	print_digit_03bd                            	| [$03b9: call $03BD] -  Print digit
	move.w	(sp)+,d0                        	| [$03bc: pop  af] -  Lower ...
print_digit_03bd:
	and.b	#0x0F,d0                         	| [$03bd: and  $0F] -  ... BDC digit * C0166,C03B9,C213B
	add.b	#0x30,d0                         	| [$03bf: add  a,$30] -  Convert to number (ASCII)
	
* < A1: videoram address (updated)
* < A3: colorram address (updated)
* < D0: character code
* < D2: attribute
write_to_screen_and_move_cursor_03c1:
	move.w	d7,-(sp)
	move.l	a1,d7
	jbsr	osd_w_videoram   			| [$03c1: ld   (de),a] -  Store character (tile number) to screen * J03D9,C0408
	exg		d2,d0                    	| [$03c2: ld   (iy+$00),c] -  Store background to color memory
	move.l	a3,d7
	jbsr	osd_w_colorram
	exg		d2,d0
	addq.w	#1,a1                           	| [$03c5: inc  de] -  Next on screen
	addq.w	#1,a3                           	| [$03c6: inc  iy] -  Next in color
	move.w	(sp)+,d7
	rts                                    	| [$03c8: ret] -  Done

* <> A0: points on ascii string + special escape control codes
* to write RLE-compressed strings, change position, etc...
* <> A1: screen address
* <> A3: corresponding screen attribute address (A1+0x400)
* <  D2: attribute

write_to_screen_03c9:
	move.b	(a0)+,d0                         	| [$03c9: ld   a,(hl)] -  Get command or character from script * C031D,C0351
	                           	| [$03ca: inc  hl] -  Next in script
	cmp.b	#0x21,d0                         	| [$03cb: cp   $21] -  Abort script?
	jeq	l_0402                             	| [$03cd: jr   z,$0402] -  Yes ... POP return and abort script
	cmp.b	#0x23,d0                         	| [$03cf: cp   $23] -  Command 23 ...
	jeq	l_03e5                             	| [$03d1: jr   z,$03E5] -  ... set color value
	cmp.b	#0x25,d0                         	| [$03d3: cp   $25] -  Command 25 ...
	jeq	write_text_using_rle_0404                             	| [$03d5: jr   z,$0404] -  ... write repeated character
	cmp.b	#0x22,d0                         	| [$03d7: cp   $22] -  Command 22 ... set cursor and load color
	* if not equal, then standard letters
	jne	write_to_screen_and_move_cursor_03c1                             	| [$03d9: jr   nz,$03C1] -  Normal character (not a command) ... store it to screen
	
* < A0: points on screen addresses (little endian)
* > A1: screen address
* > A3: corresponding screen attribute address (A1+0x400)
* > D2: attribute

compute_screen_address_and_attribute_03db:
	* recompose little endian screen address
	move.b	(a0)+,d4                         	| [$03db: ld   e,(hl)] -  Load ... * C0300,C034E,C037B
	                           	| [$03dc: inc  hl] -  ... the ...
	move.b	(a0)+,d3                         	| [$03dd: ld   d,(hl)] -  ... tile memory ...
	                           	| [$03de: inc  hl] -  ... pointer
	LOAD_D3_16_FROM_D3D4
	
	move.l	d3,a1
	lea	(0x0400,a1),a3                      	| [$03df: ld   iy,$0400] -  Color is tile ...
	                            	| [$03e3: add  iy,de] -  ... plus 400
l_03e5:
	move.b	(a0)+,d2                         	| [$03e5: ld   c,(hl)] -  Load color ... * J03D1
	                           	| [$03e6: inc  hl] -  ... from script

* d2: in/out: ink color, changed in champion mode depending on the value
trans_color_03e7:
	tst.b	champ_colors_e0f9                 	| [$03e7: ld   a,(champ_colors_e0f9)] -  Get champion-color flag * C0678,C06A9,C0CD7,C2135,C2993
	                               	| [$03ea: and  a] -  If 0 ...
	bne.b	0f                               	| [...]
	rts                                    	| [$03eb: ret  z] [...] -  ... skip color translation
0:
	move.b	d2,d0                           	| [$03ec: ld   a,c] -  Color to accumulator
	                               	| [$03ed: and  a] -  Leave it alone ...
	bne.b	0f                               	| [...]
	rts                                    	| [$03ee: ret  z] [...] -  ... if it is 0
0:
	cmp.b	#0x03,d0                         	| [$03ef: cp   $03] -  Less than 3?
	jcs	l_03fe                             	| [$03f1: jr   c,$03FE] -  Yes ... 1 or 2 becomes C or D
	cmp.b	#0x06,d0                         	| [$03f3: cp   $06] -  Value 6?
	jeq	l_03fa                             	| [$03f5: jr   z,$03FA] -  Yes ... becomes B
	cmp.b	#0x09,d0                         	| [$03f7: cp   $09] -  Value 9?
	beq.b	0f                               	| [...]
	rts                                    	| [$03f9: ret  nz] [...] -  No ... leave it (9 becomes E)
0:
l_03fa:
	addq.b	#0x05,d0                        	| [$03fa: add  a,$05] -  Values 6 and 9 ... * J03F5
	move.b	d0,d2                           	| [$03fc: ld   c,a] -  ... become B and E
	rts                                    	| [$03fd: ret] -  Done
l_03fe:
	add.b	#0x0B,d0                         	| [$03fe: add  a,$0B] -  Values 1 and 2 ... * J03F1
	move.b	d0,d2                           	| [$0400: ld   c,a] -  ... become C and D
	rts                                    	| [$0401: ret] -  Done
	
	
	
l_0402:
	* pops stack to pop caller (exit out of infinite loop)
	move.l	(sp)+,a0                        	| [$0402: pop  hl] -  Don't return to script processor * J03CD
	rts                                    	| [$0403: ret] -  Return out of script (abort)
	
write_text_using_rle_0404:
	* kind of RLE compression to display text/graphics
	* first number of chars to write
	move.b	(a0)+,d1                         	| [$0404: ld   b,(hl)] -  Get the count * J03D5
	                           	| [$0405: inc  hl] -  Skip count byte
	* then char type
	move.b	(a0)+,d0                         	| [$0406: ld   a,(hl)] -  Get the character value
	                           	| [$0407: inc  hl] -  Skip to next
							
l_0408:
	* repeats write char and add 1 to Xtile
	jbsr	write_to_screen_and_move_cursor_03c1                            	| [$0408: call $03C1] -  Write the character/color * J040B
	subq.b	#1,d1                           	| [...]
	jne	l_0408                             	| [$040b: djnz $0408] -  Do all loops
	rts                                    	| [$040d: ret] -  Done
	
coins_and_credits_040e:
	lea	unknown_E03E,a0                	| [$040e: ld   hl,unknown_E03E] -  Coin and service-credit signal history for slot A * C00C7
	lea	free_play_E041,a1                	| [$0411: ld   de,free_play_E041] -  Slot A coin mode
	jbsr	osd_read_in_0                       	| [$0414: ld   a,($D000)] -  Current switch values
	move.b	#0x00,d1                        	| [$0417: ld   bc,$0002] 2 -  B=0 (coin counter trigger) C=2 (to trigger counter A)
	move.b	#0x02,d2                        	| [$0417: ld   bc,$0002] 2 -  B=0 (coin counter trigger) C=2 (to trigger counter A)
	jbsr	l_0434                            	| [$041a: call $0434] -  Process coins and credits for slot A
	lea	unknown_E03F,a0                	| [$041d: ld   hl,unknown_E03F] -  Coin and service-credit signal history for slot B
	addq.w	#1,a1                           	| [$0420: inc  de] -  Slot B coin mode
	jbsr	osd_read_in_2                       	| [$0421: ld   a,($D002)] -  Current switch values
	ror.b	#1,d0                           	| [$0424: rra] -  Make it look like D000
	or.b	#0x04,d0                          	| [$0425: or   $04] -  There is no service-credit for slot B ... turn it off
	move.b	#0x20,d2                        	| [$0427: ld   c,$20] -  C=20 (to trigger counter B)
	jbsr	l_0434                            	| [$0429: call $0434] -  Process coins and credits for slot B
	move.b	flip_value_e04c,d0                 	| [$042c: ld   a,(flip_value_e04c)] -  Current flip status
	or.b	d1,d0                             	| [$042f: or   b] -  OR in coin-counter triggers
	* flip screen
	*move.b	d0,0xD001                       	| [$0430: ld   ($D001),a] -  Trigger hardware coin counters
	rts                                    	| [$0433: ret] -  Done
l_0434:
	CLEAR_XC_FLAGS
	                           	| [$0434: rra] -  Service-credit ... * C041A,C0429
	roxr.b	#3,d0                           	| [$0435: rra] * 3 -  ... to ...
	move.b	(a0),d7
	roxl.b	#1,d7                         	| [$0437: rl   (hl)] -  ... of memory
	roxr.b	#1,d0                           	| [$0439: rra] -  Coin to bit 0 ...
	roxl.b	#1,d7                         	| [$043a: rl   (hl)] -  ... service-credit to bit 1
	move.b	d7,d0                         	| [$043c: ld   a,(hl)] -  Get switch value
	move.b	d7,(a0)
	and.b	#0x55,d0                         	| [$043d: and  $55] -  Only looking for bit 0 (coin)
	cmp.b	#0x54,d0                         	| [$043f: cp   $54] -  Transitioned from low to high?
	jeq	l_0451                             	| [$0441: jr   z,$0451] -  Yes ... register a coin
	move.b	(a0),d0                         	| [$0443: ld   a,(hl)] -  Get switch value
	and.b	#0xAA,d0                         	| [$0444: and  $AA] -  Only looking for bit 1 (service-credit)
	beq.b	0f                               	| [...]
	rts                                    	| [$0446: ret  nz] [...] -  Return if not triggered for 4 loops (debounce)
0:
	lea	unknown_E0ED,a0                	| [$0447: ld   hl,unknown_E0ED] -  Count for number of ISRs that ...
	addq.b	#1,(a0)                         	| [$044a: inc  (hl)] -  ... service-credit has been held down
	move.b	(a0),d0                         	| [$044b: ld   a,(hl)] -  Held down ...
	and.b	#0x0F,d0                         	| [$044c: and  $0F] -  ... for 16 ISRs?
	beq.b	0f                               	| [...]
	rts                                    	| [$044e: ret  nz] [...] -  No
0:
	jra	l_046a                             	| [$044f: jr   $046A] -  Yes ... add one credit
l_0451:
	* protection against spurious credit insertion
	* credit must remain active during 19 calls/frames
	move.b	d1,d0                           	| [$0451: ld   a,b] -  Or in ... * J0441
	or.b	d2,d0                             	| [$0452: or   c] -  ... bit to trigger ...
	move.b	d0,d1                           	| [$0453: ld   b,a] -  ... hardware coin counter
	move.b	#0x13,d0                        	| [$0454: ld   a,$13]  19 frames to wait -  Play ...
	jbsr	queue_sound_effect_0d7d                            	| [$0456: call $0D7D] -  ... coin sound
	move.b	(a1),d0                         	| [$0459: ld   a,(de)] -  Coin mode
	cmp.b	#0x01,d0                         	| [$045a: cp   $01] -  One-coin = one-play?
	jeq	l_046f                             	| [$045c: jr   z,$046F] -  Yes ... register one credit for this coin
	cmp.b	#0x08,d0                         	| [$045e: cp   $08] -  What do we have multiples of?
	jcc	l_046d                             	| [$0460: jr   nc,$046D] -  Bit 4 is 1 ... multiple credits per coin
	lea	cnt_till_cred_e047,a0                	| [$0462: ld   hl,cnt_till_cred_e047] -  Get the coins-till-credit counter
	addq.b	#1,(a0)                         	| [$0465: inc  (hl)] -  Add a coin
	cmp.b	(a0),d0                          	| [$0466: cp   (hl)] -  Enough coins for a credit?
	beq.b	0f                               	| [...]
	rts                                    	| [$0467: ret  nz] [...] -  No ... out
0:
	clr.b	d0                               	| [$0468: xor  a] -  Reset the ...
	move.b	d0,(a0)                         	| [$0469: ld   (hl),a] -  ... coin-till-credit count
l_046a:
	addq.b	#1,d0                           	| [$046a: inc  a] -  Add one ... * J044F
	jra	l_046f                             	| [$046b: jr   $046F] -  ... credit
l_046d:
	sub.b	#0x08,d0                         	| [$046d: sub  $08] -  Drop the bit 4 and add multiple credits for one coin * J0460
l_046f:
	lea	credits_e048,a0             	| [$046f: ld   hl,credits_e048] -  Will be using the number-of-credits * J045C,J046B
	move.b	(a0),d7                          	| [$0472: add  a,(hl)] -  Add the new coin credit count
	abcd	d7,d0						| [daa]
	jcc	l_0478                             	| [$0474: jr   nc,$0478] -  Didn't overflow ... keep this value
	* max 99 credits
	move.b	#0x99,d0                        	| [$0476: ld   a,$99] -  Max 99 coins
l_0478:
	move.b	d0,(a0)                         	| [$0478: ld   (hl),a] -  Store the new number of credits * J0474
	rts                                    	| [$0479: ret] -  Done
get_inputs_047a:
	move.b	game_status_bits_E046,d0                 	| [$047a: ld   a,(game_status_bits_E046)] -  ??Demo mode flag * C00F6
	rol.b	#1,d0                            	| [$047d: rlca] -  ??Are we in demo mode?
	jcc	get_current_input_04db                             	| [$047e: jr   nc,$04DB] -  ??Yes ... go get demo inputs
	move.w	#0xD001,a1                      	| [$0480: ld   de,$D001] fake signpost address -  Player 1 inputs
* skipped player 2 + cocktail
*	btst.b	#4,d0                           	| [$0483: bit  4,a]
*	jeq	l_048e                             	| [$0485: jr   z,$048E]
*	move.b	cocktail_mode_E043,d0                 	| [$0487: ld   a,(cocktail_mode_E043)] -  Cabinet type
*	subq.b	#1,d0                           	| [$048a: dec  a] -  Upright?
*	jeq	l_048e                             	| [$048b: jr   z,$048E] -  Yes ... use player 1
*	* other port to read inputs
*	addq.w	#1,a1                           	| [$048d: inc  de] -  Cocktail ... use player 2
l_048e:
	lea	current_input_E04A,a0                	| [$048e: ld   hl,current_input_E04A] -  Get last ... * J0485,J048B,J04B3
	move.b	(a0),d0                         	| [$0491: ld   a,(hl)] -  ... inputs
	                           	| [$0492: inc  hl] -  Remember ...
	move.b	d0,(1,a0)                         	| [$0493: ld   (hl),a] -  ... last inputs
												| [$0494: dec  hl] -  Back to current
	* read port or demo input
	cmp.w	#0xD001,a1
	bne.b	0f
	jbsr	osd_read_in_1
	bra.b	1f
0:
*	cmp.w	#0xD002,a1
*	bne.b	0f
*	jbsr	osd_read_in_2
*	bra.b	1f
*0:
	move.b	(a1),d0                         	| [$0495: ld   a,(de)] -  Get inputs from D001 or D002
1:
	not.b	d0                               	| [$0496: cpl] -  Active high
	move.b	d0,(a0)                         	| [$0497: ld   (hl),a] -  Store them
	                           	| [$0498: dec  hl] -  E049
	and.b	#0x03,d0                         	| [$0499: and  $03] -  Keep only the start buttons
	move.b	d0,-(a0)                         	| [$049b: ld   (hl),a] -  Store the start buttons
	rts                                    	| [$049c: ret] -  Done
	
get_current_input_049d:
	move.b	fine_position_on_track_E50B,d0                 	| [$049d: ld   a,(fine_position_on_track_E50B)] -  * J04E4
	move.l	demo_fake_inputs_pointer_E0F7,a0             	| [$04a0: ld   hl,(demo_fake_inputs_pointer_E0F7)]
	cmp.b	(a0),d0                          	| [$04a3: cp   (hl)]
	jne	l_04b9                             	| [$04a4: jr   nz,$04B9]
	addq.w	#1,a0                           	| [$04a6: inc  hl]
	move.l	a0,a1                           	| [$04a8: ld   d,h]
	move.b	(a0)+,d0                         	| [$04a7: ld   a,(hl)]
	                           	| [$04a9: ld   e,l]
	                           	| [$04aa: inc  hl]
	move.l	a0,demo_fake_inputs_pointer_E0F7                 	| [$04ab: ld   (demo_fake_inputs_pointer_E0F7),hl]
	tst.b	d0                               	| [$04ae: and  a]
	jeq	l_04b5                             	| [$04af: jr   z,$04B5]
	cmp.b	#0xFF,d0                         	| [$04b1: cp   $FF]
	jne	l_048e                             	| [$04b3: jr   nz,$048E]
l_04b5:
	move.b	d0,unknown_E1E0                 	| [$04b5: ld   (unknown_E1E0),a] -  * J04AF
	rts                                    	| [$04b8: ret]
l_04b9:
	lea	current_input_E04A,a0                	| [$04b9: ld   hl,current_input_E04A] -  * J04A4
	move.b	unknown_E1E0,d0                 	| [$04bc: ld   a,(unknown_E1E0)]
	                               	| [$04bf: and  a]
	jeq	l_04d5                             	| [$04c0: jr   z,$04D5]
	move.b	timer_8bit_E04E,d0                 	| [$04c2: ld   a,(timer_8bit_E04E)]
	rol.b	#1,d0                            	| [$04c5: rlca]
	move.b	d0,d1                           	| [$04c6: ld   b,a]
	and.b	#0x01,d0                         	| [$04c7: and  $01]
	addq.b	#1,d0                           	| [$04c9: inc  a]
	move.b	d0,unknown_E049                 	| [$04ca: ld   (unknown_E049),a]
	move.b	d1,d0                           	| [$04cd: ld   a,b]
	and.b	#0x1E,d0                         	| [$04ce: and  $1E]
	jne	l_04d5                             	| [$04d0: jr   nz,$04D5]
	move.b	#0x20,(a0)                      	| [$04d2: ld   (hl),$20]
	rts                                    	| [$04d4: ret]
l_04d5:
	move.b	(a0),d0                         	| [$04d5: ld   a,(hl)] -  * J04C0,J04D0
	st.b	(a0)+                      	| [$04d6: ld   (hl),$FF] nullify/ack input
	                           	| [$04d8: inc  hl]
	move.b	d0,(a0)                         	| [$04d9: ld   (hl),a]  save as previous input
	rts                                    	| [$04da: ret]
get_current_input_04db:
	lea	title_display_timer_E04D,a0                	| [$04db: ld   hl,title_display_timer_E04D] -  * J047E
	move.b	timer_8bit_E04E,d0                 	| [$04de: ld   a,(timer_8bit_E04E)] -  ISR incrementing counter
	move.b	d0,d1                           	| [$04e1: ld   b,a]
	move.b	(a0),d0                         	| [$04e2: ld   a,(hl)]
	                               	| [$04e3: and  a]
	jeq	get_current_input_049d                             	| [$04e4: jr   z,$049D]
	* we're in title sequence
	* jeep rolls, no obstacles
	cmp.b	#0x50,d0                         	| [$04e6: cp   $50]
	jeq	jeep_jumps_and_title_shows_0507                             	| [$04e8: jr   z,$0507]
	jcc	1f
	* jotd: handle C flag manually
	roxr.b	#1,d1                           	| [$04ea: rr   b]
	bset	#7,d1		| C flag means we have to set d1 bit 0
	bra.b	2f
1:
	roxr.b	#1,d1                           	| [$04ea: rr   b] 
	bclr	#7,d1		| we don't have to set d1 bit
2:
	jcs	l_04f3                             	| [$04ec: jr   c,$04F3]
	roxr.b	#1,d1                           	| [$04ee: rr   b]
	jcs	l_04f3                             	| [$04f0: jr   c,$04F3]
	addq.b	#1,(a0)                         	| [$04f2: inc  (hl)] increase title display timer
l_04f3:
	move.b	#0x02,d2                        	| [$04f3: ld   c,$02] -  Value for "left button" * J04EC,J04F0
	lea	unknown_E049,a0                	| [$04f5: ld   hl,unknown_E049] -  Current button value spot
	cmp.b	#0x18,d0                         	| [$04f8: cp   $18]
	jcs	l_04fd                             	| [$04fa: jr   c,$04FD]
	subq.b	#1,d2                           	| [$04fc: dec  c] -  Now value for "right button"
l_04fd:
	move.b	d2,(a0)+                         	| [$04fd: ld   (hl),c] -  Store left or right button down * J04FA
	                           	| [$04fe: inc  hl] -  Point to last inputs
	clr.b	(a0)                             	| [$04ff: ld   (hl),$00] -  Last inputs now 00 (triggers a transition)
	cmp.b	#0xB0,d0                         	| [$0501: cp   $B0]
	bcc.b	0f                               	| [...]
	rts                                    	| [$0503: ret  c] [...]
0:
	jra	l_007b                             	| [$0504: jp   $007B]
jeep_jumps_and_title_shows_0507:
	lea	jeep_params_E300,a0                	| [$0507: ld   hl,jeep_params_E300] -  MoonBuggy object * J04E8
	move.b	(a0),d0                         	| [$050a: ld   a,(hl)] -  Get the current command
	cmp.b	#START_JUMPING_04,d0                         	| [$050b: cp   $04] -  Is the buggy in the air?
	jne	l_051b                             	| [$050d: jr   nz,$051B] -  No ... move on
	CLEAR_XC_FLAGS
	* check if apex of jump
	move.b	unknown_16bit_E308+1,d0                 	| [$050f: ld   a,(unknown_E309)]
	roxl.b	#1,d0                           	| [$0512: rla]
	bcc.b	0f                               	| [...]
	rts                                    	| [$0513: ret  c] [...] -  ?? falls through when jump buggy is at apex
0:
	move.b	#STATE_HOLD_IN_AIR_08,(a0)                      	| [$0514: ld   (hl),$08] -  Transition to "hold buggy in air" sequence
	move.b	#0x0A,d2                        	| [$0516: ld   c,$0A] -  Init "MOON PATROL" splash sequence
	jra	store_special_event_02c2                             	| [$0518: jp   $02C2] -  Add the text-command and out
l_051b:
	cmp.b	#STATE_HOLD_IN_AIR_08,d0                         	| [$051b: cp   $08] -  Buggy-held-in-air sequence? * J050D
	bne.b	0f                               	| [...]
	rts                                    	| [$051d: ret  z] [...] -  Yes ... no inputs
0:
	lea	current_input_E04A,a0                	| [$051e: ld   hl,current_input_E04A] -  Current inputs
	move.b	#0x20,(a0)+                      	| [$0521: ld   (hl),$20] -  Current input is a JUMP
	                           	| [$0523: inc  hl] -  Last input is ...
	clr.b	(a0)                             	| [$0524: ld   (hl),$00] -  ... nothing (register transition)
	rts                                    	| [$0526: ret] -  Done
print_creds_0527:
	lea	game_rom+0x2AE2,a0                      	| [$0527: ld   hl,$2AE2] -  "CREDIT " script * C01BC,C0539,C074E
	jbsr	write_to_screen_possible_typing_effect_300                            	| [$052a: call $0300] -  Print it
	move.b	credits_e048,d0              	| [$052d: ld   a,(credits_e048)] -  Number of credits
	jra	set_character_at_address_03ae                             	| [$0530: jp   $03AE] -  Print it and out
l_0533:
	lea	game_rom+0x2AD1,a0                      	| [$0533: ld   hl,$2AD1] -  " PUSH BUTTON " script * C010D,C01C1
	jbsr	flash_script_0374                            	| [$0536: call $0374] -  Print the flashing script
	jbsr	print_creds_0527                            	| [$0539: call $0527] -  Print number of credits
	lea	game_rom+0x2A86,a0                      	| [$053c: ld   hl,$2A86] -  "ONLY 1 PLAYER" script
	move.b	credits_e048,d0              	| [$053f: ld   a,(credits_e048)] -  Number of credits
	subq.b	#1,d0                           	| [$0542: dec  a] -  Only one player?
	jeq	l_0548                             	| [$0543: jr   z,$0548] -  Yes ... leave this message
	lea	game_rom+0x2A97,a0                      	| [$0545: ld   hl,$2A97] -  "1 OR 2 PLAYERS" script
l_0548:
	jbsr	write_to_screen_possible_typing_effect_300                            	| [$0548: call $0300] -  Print it * J0543
	* which start button was pressed
	move.b	coin_start_e053,d0                 	| [$054b: ld   a,(coin_start_e053)]
	and.b	#0x03,d0                         	| [$054e: and  $03]
	bne.b	0f                               	| [...]
	rts                                    	| [$0550: ret  z] [...]
0:
	move.b	#0x80,d1                        	| [$0555: ld   b,$80]
	roxr.b	#1,d0                           	| [$0551: rra]
	jcs	l_055f                             	| [$0557: jr   c,$055F]
	move.b	credits_e048,d0              	| [$0552: ld   a,(credits_e048)]
	* 1-player game
	moveq	#1,d7
	sbcd	d7,d0                        	| [$0559: sub  $01 + daa]
	bne.b	0f                               	| [...]
	rts                                    	| [$055c: ret  z] [...]
0:
	* 2-player game
	move.b	#0x90,d1                        	| [$055d: ld   b,$90]
l_055f:
	move.b	credits_e048,d0              	| [$0552: ld   a,(credits_e048)]
	moveq	#1,d7
	sbcd	d7,d0                        	| [$055f: sub  $01 + daa] -  * J0557
    jbsr  osd_disable_interrupts  | [di]
	move.b	d0,credits_e048              	| [$0563: ld   (credits_e048),a]
	move.b	d1,d0                           	| [$0566: ld   a,b]
	move.b	d0,game_status_bits_E046                 	| [$0567: ld   (game_status_bits_E046),a]
	addq.b	#1,d0                           	| [$056a: inc  a]
    jbsr  osd_enable_interrupts  | [ei]
	rts                                    	| [$056c: ret]

reg_mirror_056d:
** copy E100 => C800 ($40 bytes)
	lea	sprite_shadow_E100,a0          	| [$056d: ld   hl,sprite_shadow_E100] -  Start of mirror memory * C003A
	jbsr	osd_update_sprites
*	lea	l_C840,a1                      	| [$0570: ld   de,$C840] -  ?? Sprite memory Enemy ships and rocks
*	move.b	#0x00,d1                        	| [$0573: ld   bc,$0040] 64 -  40 bytes, 16 sprites
*	move.b	#0x40,d2                        	| [$0573: ld   bc,$0040] 64 -  40 bytes, 16 sprites
*	jbsr	ldir                              	| [$0576: ldir] -  E100..E13F to C840..C87F (40 bytes, 16 sprites)
*     
** copy E140 => C820 ($20 bytes)
*	move.b	#0x20,d4                        	| [$0578: ld   e,$20] -  Sprite memory
*	move.b	#0x20,d2                        	| [$057a: ld   c,$20] -  20 bytes
*	jbsr	ldir                              	| [$057c: ldir] -  E140..E15F to C820..C83F (20 bytes, 8 sprites)
*     
*	move.b	#0xC0,d4                        	| [$057e: ld   e,$C0] -  Sprite memory
*	move.b	#0x40,d2                        	| [$0580: ld   c,$40] -  40 bytes
** copy E160 => C8C0 ($40 bytes)
*	jbsr	ldir                              	| [$0582: ldir] -  E160..E19F to C8C0..C8FF (40 bytes, 16 sprites)
*     
** copy E1A0 => C8A0 ($20 bytes): jeep
* jeep body uses 7 sprites: 4 for the body
* and 3 for the wheels which are independent
* E1A0: forward shot
* E1A4-E1AF: wheels
* E1B0-E1BF: jeep body
*	lea	l_C8A0,a1                      	| [$0584: ld   de,$C8A0] -  ?? Sprite memory Buggy, wheels, forward shot
*	move.w	#0x20,d1                        	| [$0587: ld   c,$20] -  20 bytes
*	jbsr	ldir                              	| [$0589: ldir] -  E1A0..E1BF to C8A0..C8BF (20 bytes, 8 sprites)
* update scroll layers
* E1C0: scroll X offset for ground
* E1C1: scroll X offset for green background
* E1C2: scroll X offset for blue background
	lea		scroll_x_value_ground_layer_E1C0,a0
	move.b	#0x1C,d2                        	| [$058b: ld   c,$1C] -  Copy ...
	move.b	(a0),d0                         	| [$058d: ld   a,(hl)] -  ... E1C0 ...
	move.b	#0x04,d1                        	| [$058e: ld   b,$04] -  ... to ...
	* set scroll value for ground
*l_0590:
	jbsr	osd_set_ground_scroll_value
**out  (c),a
*	addq.b	#1,d2                           	| [$0592: inc  c] -  ... four ...
*	subq.b	#1,d1                           	| [...]
*	jne	l_0590                             	| [$0593: djnz $0590] -  ... scroll registers
	addq.w	#1,a0                           	| [$0595: inc  hl] -  Now E1C1
	move.b	green_layer_y_pos_E1C3,d0                 	| [$0596: ld   a,(green_layer_y_pos_E1C3)] -  Value destined for BKG1Y
	                               	| [$0599: and  a] -  ?? 1Y is 0?
	jeq	l_05c7                             	| [$059a: jr   z,$05C7] -  Change to FF and disable all backgrounds
	move.b	(a0),d0                         	| [$059c: ld   a,(hl)] -  Value to be written to BKG1X.
	and.b	#0x7F,d0                         	| [$059d: and  $7F] -  ... The "protection" chip returns a ...
	move.b	#0x00,d1                        	| [$059f: ld   bc,$0040] 64 -  ... mangled ...
	move.b	#0x40,d2                        	| [$059f: ld   bc,$0040] 64 -  ... mangled ...
l_05a2:
	lsr.b	#1,d0                            	| [$05a2: srl  a] -  ... value based on ... * J05A7
	jcc	l_05a7                             	| [$05a4: jr   nc,$05A7] -  ... the value ...
	addq.b	#1,d1                           	| [$05a6: inc  b] -  ... written to ...
l_05a7:
	jne	l_05a2                             	| [$05a7: jr   nz,$05A2] -  ... BKG1X. We ... * J05A4
	move.b	(a0),d0                         	| [$05a9: ld   a,(hl)] -  ... calculate ...
	rol.b	#1,d0                            	| [$05aa: rlca] -  ... what ...
	and.b	#0x01,d0                         	| [$05ab: and  $01] -  ... it ...
	eor.b	d1,d0                            	| [$05ad: xor  b] -  ... should ...
	move.b	d0,d4                           	| [$05ae: ld   e,a] -  ... return
	* disabling protection
*outi
*	move.b	0x8800,d0                       	| [$05b1: ld   a,($8800)] protection -  Get mangled bkg1X from protection
    
*	and.b	#0x07,d0                         	| [$05b4: and  $07] -  Keep lower 3 bits
*	cmp.b	d4,d0                            	| [$05b6: cp   e] -  Make sure protection chip did its thing
* a must be the same as e
*	jne	l_00c3                             	| [$05b7: jp   nz,$00C3] -  Protection chip failed
*	move.b	#0x80,d2                        	| [$05ba: ld   c,$80] -  BKG2X
*outi
*	move.b	#0x60,d2                        	| [$05be: ld   c,$60] -  BKG1Y
*outi
*	move.b	#0xA0,d2                        	| [$05c2: ld   c,$A0] -  BKG2Y
*outi
*	move.b	(a0),d0                         	| [$05c6: ld   a,(hl)] -  From E1C5 (to BkgControl)
l_05c7:
*	not.b	d0                               	| [$05c7: cpl] -  Reverse bits to active high * J059A
*out  ($C0),a
	rts                                    	| [$05ca: ret] -  Done
sound_stuff_05cb:
*	move.w	sndQ_front_e1dd,a0x             	| [$05cb: ld   hl,(sndQ_front_e1dd)] -  Get front (L) and back (H) of sound effect queue pointer * C0093
*                  
*	move.b	d6,d0                           	| [$05ce: ld   a,l] -  Head and tail ...
*	cmp.b	d5,d0                            	| [$05cf: cp   h] -  ... the same?
*	bne.b	0f                               	| [...]
*	rts                                    	| [$05d0: ret  z] [...] -  Yes ... nothing to queue up
*0:
*	move.b	#0xE0,d5                        	| [$05d1: ld   h,$E0] -  MSB is E0
*	move.b	(a0),d0                         	| [$05d3: ld   a,(hl)] -  Get sound effect number from
*	move.b	d0,0xD000                       	| [$05d4: ld   ($D000),a] -  Write sound command with IRQ triggered (D7=0)
*          TODO: review absolute 16-bit address write
*	bset.b	#7,d0                           	| [$05d7: set  7,a] -  Release the IRQ ...
*	move.b	d0,0xD000                       	| [$05d9: ld   ($D000),a] -  ... trigger D7=1
*          TODO: review absolute 16-bit address write
*	move.b	d6,d0                           	| [$05dc: ld   a,l] -  Bump to the ...
*	addq.b	#1,d0                           	| [$05dd: inc  a] -  ... next effect in the queue
*	and.b	#0x07,d0                         	| [$05de: and  $07] -  Only 8 bytes in queue ... then we wrap
*	move.b	d0,sndQ_front_e1dd                 	| [$05e0: ld   (sndQ_front_e1dd),a] -  Store the updated front
	rts                                    	| [$05e3: ret] -  Done
delay1_sec_05e4:
	move.b	#0x40,d0                        	| [$05e4: ld   a,$40] -  About 1 second * C016C
	jra	wait_for_sync_05ea                             	| [$05e6: jr   $05EA] -  Wait for it and return
delay3_sec_05e8:
	move.b	#0xC0,d0                        	| [$05e8: ld   a,$C0] -  About 3 seconds * C0184,J0794,C27E4,C2889,C288E,C28BA
wait_for_sync_05ea:
	move.b	d0,sync_flag_E050                 	| [$05ea: ld   (sync_flag_E050),a] -  Set countdown timer * J05E6,C2859,C286E
l_05ed:
	move.b	sync_flag_E050,d0                 	| [$05ed: ld   a,(sync_flag_E050)] -  Wait for ... * J05F1
	                               	| [$05f0: and  a] -  ... count to ...
	jne	l_05ed                             	| [$05f1: jr   nz,$05ED] -  ... reach 0
	rts                                    	| [$05f3: ret] -  Done

clear_ram_05f4:
	lea	revolving_buffer_8_E000,a0                	| [$05f4: ld   hl,revolving_buffer_8_E000] -  Point to start of RAM * C000D
	move.w	#0x0700,d1                        	| [$05f7: ld   bc,$0700] 1792 -  Number of bytes to clear
* < HL: start
* < BC: length
clear_area_05fa:
	clr.b	(a0)+                             	| [$05fa: ld   (hl),$00] -  Clear location * J0600,C0BBD,C0C9E,C0D2F,C0D38,C294E,J2957,C2960
	                         	| [$05fc: inc  hl] -  Next in RAM
	                         	| [$05fd: dec  bc] -  Decrement counter
	                         	| [$05fe: ld   a,b] -  Is counter ...
	subq	#1,d1                           	| [$05ff: or   c] -  ... all 0's?
	jne		clear_area_05fa                    	| [$0600: jr   nz,clear_area_05fa] -  No ... keep clearing
	rts                                    	| [$0602: ret] -  Done

swap_players_0603:
	lea	game_status_bits_E046,a0                	| [$0603: ld   hl,game_status_bits_E046] -  Game mode * C013B,C0145,C0169,C0181,J01E9,C0C95,C0CFA,C0D00
	move.b	(a0),d0                         	| [$0606: ld   a,(hl)] -  Get game mode
	* toggle current player
	eor.b	#0x08,d0                         	| [$0607: xor  $08] -  Change ...
	move.b	d0,(a0)                         	| [$0609: ld   (hl),a] -  ... players
	lea	player_score_E500,a0                	| [$060a: ld   hl,player_score_E500] -  Pointer to current player
	lea	other_player_data_E518,a1                	| [$060d: ld   de,other_player_data_E518] -  Pointer to "other" player
	move.b	#0x18+2,d1                        	| [$0610: ld   b,$18] -  24 bytes to swap + 2 there's a 32 bit pointer
l_0612:
	move.b	(a1),d2                         	| [$0612: ld   a,(de)] -  From other player * J0619
	                           	| [$0613: ld   c,a] -  Now in C
	move.b	(a0),d0                         	| [$0614: ld   a,(hl)] -  From current player
	move.b	d0,(a1)+                         	| [$0615: ld   (de),a] -  Swap current ...
	move.b	d2,(a0)+                         	| [$0616: ld   (hl),c] -  ... and other player data
	                           	| [$0617: inc  hl] -  Next in current
	                           	| [$0618: inc  de] -  Next in other
	subq.b	#1,d1                           	| [...]
	jne	l_0612                             	| [$0619: djnz $0612] -  Do all 24 bytes
	rts                                    	| [$061b: ret] -  Done

is_player_2_061c:
	move.b	game_status_bits_E046,d0                 	| [$061c: ld   a,(game_status_bits_E046)] -  Get game-mode * C017C,C066B
	btst.b	#3,d0                           	| [$061f: bit  3,a] -  Test value of bit-3
	rts                                    	| [$0621: ret] -  Return in Z flag
l_0622:
	move.b	d0,d2                           	| [$0622: ld   c,a] -  A = A * 3 ...
	add.b	d2,d0                            	| [$0623: add  a,c] -  ... three byte add ...
	add.b	d2,d0                            	| [$0624: add  a,c] -  ... for 6-digit BCD
	move.b	d0,d2                           	| [$0625: ld   c,a] -  Now to ...
	clr.w	d1                               	| [$0626: ld   b,$00] -  ... BC
	move.b	d2,d1
	lea	game_rom+0x2A0C,a0                      	| [$0628: ld   hl,$2A0C] -  Offset into ...
	add.w	d1,a0                            	| [$062b: add  hl,bc] -  ... score table
	move.b	game_status_bits_E046,d0                 	| [$062c: ld   a,(game_status_bits_E046)] -  Game mode
	                               	| [$062f: and  a] -  Are we in demo mode?
	bmi.b	0f                               	| [...]
	rts                                    	| [$0630: ret  p] [...] -  Yes ... don't register score
0:
	* game in play!
	lea	player_score_E500,a1                	| [$0631: ld   de,player_score_E500] -  Score for current player
	move.w	#0x03-1,d1                        	| [$0634: ld   b,$03] -  Do three bytes (6 digits)
l_0636:
	CLEAR_XC_FLAGS                               	| [$0636: and  a] -  Clear carry for first pass * C2899
l_0637:
	move.b	(a1),d0                         	| [$0637: ld   a,(de)] -  Add current value ... * J063D
	move.b	(a0)+,d7			|	adc  a,(hl)
	abcd	d7,d0           |    daa

	move.b	d0,(a1)+                         	| [$063a: ld   (de),a] -  New current value
	                           	| [$063b: inc  de] -  Next in value
	                           	| [$063c: inc  hl] -  Next in offset
	dbf		d1,l_0637                             	| [$063d: djnz $0637] -  Do all digits, preserve X flag!
	jbsr	check_ext_play_06af                            	| [$063f: call $06AF] -  Check and handle extended play
	move.w	#0x03-1,d1                        	| [$0642: ld   b,$03] -  Three bytes (six digits)
	lea	player_score_E500,a1                	| [$0644: ld   de,player_score_E500] -  Current score
	lea	high_score_e008,a0                	| [$0647: ld   hl,high_score_e008] -  High Score
	CLEAR_XC_FLAGS                               	| [$064a: and  a] -  Start with clear carry
l_064b:
	move.b	(a1)+,d0                         	| [$064b: ld   a,(de)] -  Compare current ... * J064F
	move.b	(a0)+,d7
	subx.b	d7,d0                         	| [$064c: sbc  a,(hl)] -  ... to high score
											| [$064d: inc  hl] -  Next in high
											| [$064e: inc  de] -  Next in current
	                           	| [...]
	dbf	d1,l_064b                             	| [$064f: djnz $064B] -  Compare all digits
	jcs	display_score_0668                             	| [$0651: jr   c,$0668] -  Current score is lower ... don't update high score
	move.w	player_score_E500,high_score_e008          	| [$0653: ld   hl,(player_score_E500)] -  Copy ...
	                 	|								 [$0656: ld   (high_score_e008),hl] -  ... current score ...
	move.b	cur_score2_e502,d0                 	| [$0659: ld   a,(cur_score2_e502)] -  ... to ...
	move.b	d0,high_score2_e00a                 	| [$065c: ld   (high_score2_e00a),a] -  ... high score
	move.b	cur_point_e50e,d0                 	| [$065f: ld   a,(cur_point_e50e)] -  Current passed-point
	move.b	d0,high_point_e00b                 	| [$0662: ld   (high_point_e00b),a] -  Copy to high passed-point
	jbsr	print_high_0685                            	| [$0665: call $0685] -  Print high-score and high-passed-point
display_score_0668:
	lea	0x8084,a1                      	| [$0668: ld   de,$8084] -  Player 1's score on screen * J0651,C0CED,C0CFD
	jbsr	is_player_2_061c                            	| [$066b: call $061C] -  Player 1 or 2?
	jeq	l_0673                             	| [$066e: jr   z,$0673] -  This is player 1 ... we have the right screen location
	lea	0x80A4,a1                      	| [$0670: ld   de,$80A4] -  Player 2's score on screen (+32 ... one row)
l_0673:
	lea	cur_score2_e502,a0                	| [$0673: ld   hl,cur_score2_e502] -  * J066E
	move.b	#0x01,d2                        	| [$0676: ld   c,$01] -  Color set
	jbsr	trans_color_03e7                            	| [$0678: call $03E7] -  Translate colors
l_067b:
	move.b	#0x03,d1                        	| [$067b: ld   b,$03] -  Three bytes to print * J06AD
l_067d:
	move.b	(a0),d0                         	| [$067d: ld   a,(hl)] -  Get BCD double digit * J0682
	jbsr	set_character_at_address_03ae                            	| [$067e: call $03AE] -  Print two digits to screen at DE
	subq.w	#1,a0                           	| [$0681: dec  hl] -  Back up a byte (these are stored in memory LSB first)
	subq.b	#1,d1                           	| [...]
	jne	l_067d                             	| [$0682: djnz $067D] -  Do all digits
	rts                                    	| [$0684: ret] -  Out
print_high_0685:
	lea	high_point_e00b,a0                	| [$0685: ld   hl,high_point_e00b] -  Location of high passed-point * C0665,C0CF0
	move.b	(a0),d0                         	| [$0688: ld   a,(hl)] -  Get high passed-point
	move.b	#0x09,d2                        	| [$0689: ld   c,$09] -  Color for 1st pass through letters
	cmp.b	#0x1B,d0                         	| [$068b: cp   $1B] -  Rolled past letter 'Z' ?
	jcs	l_0693                             	| [$068d: jr   c,$0693] -  No ... keep it
	sub.b	#0x1A,d0                         	| [$068f: sub  $1A] -  Roll back around
	move.b	#0x06,d2                        	| [$0691: ld   c,$06] -  Color for 2nd pass through letters
l_0693:
	add.b	#0x40,d0                         	| [$0693: add  a,$40] -  Becomes an ASCII letter * J068D
	move.w	#0x804A,d7                       	| [$0695: ld   ($804A),a] -  Store it to screen
    jbsr	osd_w_videoram
	move.b	champ_colors_e0f9,d0                 	| [$0698: ld   a,(champ_colors_e0f9)] -  Champion ...
	ror.b	#1,d0                           	| [$069b: rra] -  ... course?
   
	jcc	l_06a1                             	| [$069d: jr   nc,$06A1] -  Normal colors
	move.b	d2,d0                           	| [$069c: ld   a,c] -  Color
	addq.b	#0x05,d0                        	| [$069f: add  a,$05] -  Champion colors
	bra.b	l_06a1_2
l_06a1:
	move.b	d2,d0                           	| [$069c: ld   a,c] -  Color
l_06a1_2:
	move.w	#0x844A,d7
	jbsr	osd_w_colorram                       	| [$06a1: ld   ($844A),a] -  Set the color of the high passed-point character * J069D
	lea	0x8043,a1                      	| [$06a4: ld   de,$8043] -  Location of high-score on screen
	move.b	#0x09,d2                        	| [$06a7: ld   c,$09] -  Color set
	jbsr	trans_color_03e7                            	| [$06a9: call $03E7] -  Do color translation
	subq.w	#1,a0                           	| [$06ac: dec  hl] -  Back up to MSB of high score (E00A)
	jra	l_067b                             	| [$06ad: jr   $067B] -  Print high score digits to screen and out

check_ext_play_06af:
	move.b	cur_score1_e501,d6             	| [$06af: ld   hl,(cur_score1_e501)] -  * C063F
	move.b	cur_score1_e501+1,d5             	| [$06af: ld   hl,(cur_score1_e501)] -  * C063F
	move.b	ext_points_e045,d0                 	| [$06b2: ld   a,(ext_points_e045)] -  Extra points setting
	subq.b	#1,d0                           	| [$06b5: dec  a]
	bpl.b	0f                               	| [...]
	rts                                    	| [$06b6: ret  m] [...]
0:
	subq.b	#1,d0                           	| [$06b7: dec  a]
	jeq	l_06bb                             	| [$06b8: jr   z,$06BB]
	addq.b	#1,d5                           	| [$06ba: inc  h]
l_06bb:
	asr.b	#1,d5                            	| [$06bb: sra  h] -  * J06B8
	subq.b	#1,d5                           	| [$06bd: dec  h]
	addq.b	#1,d0                           	| [$06be: inc  a]
	jne	l_06c7                             	| [$06c0: jr   nz,$06C7]
	move.b	d5,d0                           	| [$06bf: ld   a,h]
	                               	| [$06c2: and  a]
	jeq	l_06c7                             	| [$06c3: jr   z,$06C7]
	move.b	#0xFE,d0                        	| [$06c5: ld   a,$FE]
l_06c7:
	move.b	d5,d0                           	| [$06bf: ld   a,h]
	lea	unknown_E503,a0                	| [$06c7: ld   hl,unknown_E503] -  * J06C0,J06C3
	cmp.b	(a0),d0                          	| [$06ca: cp   (hl)]
	beq.b	0f                               	| [...]
	rts                                    	| [$06cb: ret  nz] [...]
0:
	move.b	(a0),d0                         	| [$06cc: ld   a,(hl)]
	cmp.b	#0x03,d0                         	| [$06cd: cp   $03]
	bne.b	0f                               	| [...]
	rts                                    	| [$06cf: ret  z] [...]
0:
	addq.b	#1,(a0)                         	| [$06d0: inc  (hl)]
	lea	nb_lives_E515,a0               	| [$06d1: ld   hl,nb_lives_E515]
	addq.b	#1,(a0)                         	| [$06d4: inc  (hl)]
display_nb_lives_06d5:
	move.b	nb_lives_E515,d0                	| [$06d5: ld   a,(nb_lives_E515)] -  * C0130,C0D09
	subq.b	#1,d0                           	| [$06d8: dec  a]
	jeq	l_06de                             	| [$06d9: jr   z,$06DE]
	move.b	d0,d2                           	| [$06db: ld   c,a]
	move.b	#0x01,d0                        	| [$06dc: ld   a,$01] jeep tile 1
l_06de:
	move.w	#0x807C,d7                      	| [$06de: ld   hl,$807C] -  * J06D9
	jbsr	write_to_screen_and_inc_x_and_char_06ec                            	| [$06e1: call $06EC]
	jbsr	write_to_screen_and_inc_x_and_char_06ec                            	| [$06e4: call $06EC]
	jeq	write_to_screen_and_inc_x_and_char_06ec                             	| [$06e7: jr   z,$06EC] never branches???
	move.b	d2,d0                           	| [$06e9: ld   a,c]
	* add '0' to number of lives
	add.b	#0x30,d0                         	| [$06ea: add  a,$30]
write_to_screen_and_inc_x_and_char_06ec:
	jbsr	osd_w_videoram                         	| [$06ec: ld   (hl),a] -  * C06E1,C06E4,J06E7
	addq.w	#1,d7                           	| [$06ed: inc  hl]
	tst.b	d0                               	| [$06ee: and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [$06ef: ret  z] [...]
0:
	addq.b	#1,d0                           	| [$06f0: inc  a]
	rts                                    	| [$06f1: ret]

read_settings_06f2:
	lea	lives_per_credit_e040,a0                	| [$06f2: ld   hl,lives_per_credit_e040] -  Holds lives-per-credit * C0010
	jbsr	osd_read_dsw_1                       	| [$06f5: ld   a,($D003)] -  Read the number of lives-per-credit
	move.b	d0,d1                           	| [$06f8: ld   b,a] -  Hold original in B
	addq.b	#1,d0                           	| [$06f9: inc  a] -  Value is now 1,2,3, 4
	and.b	#0x03,d0                         	| [$06fa: and  $03] -  Is it 1,2, or 3?
	jne	l_0700                             	| [$06fc: jr   nz,$0700] -  Yes ... keep 1,2, or 3
	move.b	#0x05,d0                        	| [$06fe: ld   a,$05] -  4 becomes 5 lives
l_0700:
	move.b	d0,(a0)                         	| [$0700: ld   (hl),a] -  Store lives-per-credit; * J06FC
	addq.w	#1,a0                           	| [$0701: inc  hl] -  E041 (holds coin mode for slot A)
	move.b	d1,d0                           	| [$0702: ld   a,b] -  Original port value just read
	ror.b	#2,d0                            	| [$0703: rrca] * 2 -  Skip over ...
	move.b	d0,d1                           	| [$0705: ld   b,a] -  Drop num-cars field from the original value
	and.b	#0x03,d0                         	| [$0706: and  $03] -  Store ...
	move.b	d0,ext_points_e045                 	| [$0708: ld   (ext_points_e045),a] -  ... extended points field
	jbsr	osd_read_dsw_2                       	| [$070b: ld   a,($D004)] -  Get ...
	move.b	d0,d7
	move.b	d1,d0                           	| [$0710: ld   a,b] -  original value
	* read coin mode
	btst.b	#2,d7                           	| [$070e: bit  2,a] -  ... coin mode
	jeq	l_0732                             	| [$0711: jr   z,$0732] -  In modeB (two different slot currencies)
	ror.b	#2,d0                           	| [$0713: rra] * 2 -  Drop the ...
	neg.b	d0                               	| [$0715: neg] -  A = 0-A. Make active high then add one
	and.b	#0x0F,d0                         	| [$0717: and  $0F] -  Only 4 bits in coin modes
	btst.b	#3,d0                           	| [$0719: bit  3,a] -  Multi plays per coin?
	jeq	l_071e                             	| [$071b: jr   z,$071E] -  No ... leave the value alone.
	addq.b	#1,d0                           	| [$071d: inc  a] -  Multi-plays-per-coin value goes 1-7 with 0 and 1 on the end
l_071e:
	move.b	d0,(a0)                         	| [$071e: ld   (hl),a] -  Store coin mode slot A * J071B
l_071f:
	addq.w	#1,a0                           	| [$071f: inc  hl] -  E042 ... mode for slot B * J0743
	move.b	d0,(a0)                         	| [$0720: ld   (hl),a] -  Same coin mode for slot B
	jbsr	osd_read_dsw_2                       	| [$0721: ld   a,($D004)] -  Various settings
	not.b	d0                               	| [$0724: cpl] -  Active 1 now
	ror.b	#1,d0                           	| [$0725: rra] -  Skip the "flip screen" bit
	move.b	d0,d1                           	| [$0726: ld   b,a] -  Hold new value
	and.b	#0x01,d0                         	| [$0727: and  $01] -  Cabinet mode
	addq.w	#1,a0                           	| [$0729: inc  hl] -  Store cabinet mode ...
	move.b	d0,(a0)	                         	| [$072a: ld   (hl),a] -  ... to E043
	move.b	d1,d0                           	| [$072b: ld   a,b] -  Original value
	ror.b	#1,d0                           	| [$072c: rra] -  Skip the "cabinet" bit
	and.b	#0x01,d0                         	| [$072d: and  $01] -  Slot mode
	addq.w	#1,a0                           	| [$072f: inc  hl] -  Store slot mode ...
	move.b	d0,(a0)                         	| [$0730: ld   (hl),a] -  ... to E044
	rts                                    	| [$0731: ret] -  Done

* not reached with normal coin settings
l_0732:
	ror.b	#2,d0                           	| [$0732: rra] * 2 -  Skip the ... * J0711
	not.b	d0                               	| [$0734: cpl] -  Straight reverse now
	move.b	d0,d1                           	| [$0735: ld   b,a] -  Hold this
	addq.b	#1,d0                           	| [$0736: inc  a] -  NOW make it NEG like in 1 coin mode
	and.b	#0x03,d0                         	| [$0737: and  $03] -  Keep lower 2 bits. This is a multi-coin-per-play setting
	move.b	d0,(a0)                         	| [$0739: ld   (hl),a] -  Store coin mode
	move.b	d1,d0                           	| [$073a: ld   a,b] -  Complimented value
	ror.b	#2,d0                           	| [$073b: rra] * 2 -  Drop ...
 	and.b	#0x03,d0                         	| [$073d: and  $03] -  Only 2 bits
	cmp.b	#0x02,d0                         	| [$073f: cp   $02] -  This becomes a ...
	SET_X_FROM_C
	move.b	#0xF5,d7
	subx.b	d7,d0                        	| [$0741: sbc  a,$F5] -  ... multi-play-per-coin setting
	jra	l_071f                             	| [$0743: jr   $071F] -  Store it
l_0745:
	jbsr	l_0d29                            	| [$0745: call $0D29] -  * C0086
	lea	game_rom+0x2C97,a0                      	| [$0748: ld   hl,$2C97] -  "1982 IREM CORP" script
	jbsr	write_to_screen_possible_typing_effect_300                            	| [$074b: call $0300]
	jbsr	print_creds_0527                            	| [$074e: call $0527]
	* "INSERT COIN" text
	lea	game_rom+0x2C57,a0                      	| [$0751: ld   hl,$2C57] -  "INSERT COIN" script
	jbsr	write_text_to_screen_at_xy_with_delay_034e                            	| [$0754: call $034E]
	lea	continue_timer_E054,a1                	| [$0757: ld   de,continue_timer_E054]
	move.w	#0x20,d1                        	| [$075a: ld   bc,$0020] 32
	move.b	slot_mode_e044,d0                 	| [$075d: ld   a,(slot_mode_e044)]
	                               	| [$0760: and  a]
	jne	l_0797                             	| [$0761: jr   nz,$0797]
	jbsr	l_079f                            	| [$0763: call $079F]
	jbsr	l_07e8                            	| [$0766: call $07E8]
	move.b	(a0),d0                         	| [$0769: ld   a,(hl)]
	cmp.b	#0x32,d0                         	| [$076a: cp   $32]
	jne	l_078e                             	| [$076c: jr   nz,$078E]
	move.b	#0x53,d0                        	| [$076e: ld   a,$53]
	move.b	d0,unknown_E05F                 	| [$0770: ld   (unknown_E05F),a]
	move.b	d0,unknown_E068                 	| [$0773: ld   (unknown_E068),a]
	lea	unknown_E062,a0                	| [$0776: ld   hl,unknown_E062]
	move.b	(a0),d0                         	| [$0779: ld   a,(hl)]
	add.b	d0,d0                            	| [$077a: add  a,a]
	sub.b	#0x30,d0                         	| [$077b: sub  $30]
	cmp.b	#0x3A,d0                         	| [$077d: cp   $3A]
	jcs	l_0787                             	| [$077f: jr   c,$0787]
	sub.b	#0x0A,d0                         	| [$0781: sub  $0A]
	move.b	d0,(a0)                         	| [$0783: ld   (hl),a]
	subq.w	#1,a0                           	| [$0784: dec  hl]
	move.b	#0x31,d0                        	| [$0785: ld   a,$31]
l_0787:
	move.b	d0,(a0)                         	| [$0787: ld   (hl),a] -  * J077F
l_0788:
	lea	continue_timer_E054,a0                	| [$0788: ld   hl,continue_timer_E054] -  * J079D
	jbsr	write_text_to_screen_at_xy_with_delay_034e                            	| [$078b: call $034E]
l_078e:
	move.b	cnt_till_cred_e047,d0                 	| [$078e: ld   a,(cnt_till_cred_e047)] -  * J076C,J0792
	                               	| [$0791: and  a]
	jne	l_078e                             	| [$0792: jr   nz,$078E]
	jra	delay3_sec_05e8                             	| [$0794: jp   $05E8]
l_0797:
	jbsr	l_07d3                            	| [$0797: call $07D3] -  * J0761
	jbsr	l_07dd                            	| [$079a: call $07DD]
	jra	l_0788                             	| [$079d: jr   $0788]
l_079f:
	lea	game_rom+0x2C67,a0                      	| [$079f: ld   hl,$2C67] -  "1 PLAYER 1 COIN" script * C0763
	jbsr	ldir                              	| [$07a2: ldir]
	lea	unknown_E057,a0                	| [$07a4: ld   hl,unknown_E057]
l_07a7:
	move.b	free_play_E041,d0                 	| [$07a7: ld   a,(free_play_E041)] -  * J07DB
l_07aa:
	move.w	#0x0008,d3                      	| [$07aa: ld   de,$0008] 8 -  * J07E6
	cmp.b	#0x08,d0                         	| [$07ad: cp   $08]
	jcs	l_07c3                             	| [$07af: jr   c,$07C3]
	add.b	#0x28,d0                         	| [$07b1: add  a,$28]
	move.b	d0,(a0)                         	| [$07b3: ld   (hl),a]
	add.w	d3,a0                            	| [$07b4: add  hl,de]
	move.b	#0x53,(a0)                      	| [$07b5: ld   (hl),$53]
	addq.w	#3,a0                           	| [$07b7: inc  hl] * 3
	move.b	#0x31,(a0)                      	| [$07ba: ld   (hl),$31]
	move.w	#0x0006,d3                      	| [$07bc: ld   de,$0006] 6
	add.w	d3,a0                            	| [$07bf: add  hl,de]
	clr.b	(a0)                             	| [$07c0: ld   (hl),$00]
	rts                                    	| [$07c2: ret]
l_07c3:
	subq.b	#1,d0                           	| [$07c3: dec  a] -  * J07AF
	bne.b	0f                               	| [...]
	rts                                    	| [$07c4: ret  z] [...]
0:
	move.w	#0x000B,d3                      	| [$07c5: ld   de,$000B] 11
	add.w	d3,a0                            	| [$07c8: add  hl,de]
	add.b	#0x31,d0                         	| [$07c9: add  a,$31]
	move.b	d0,(a0)                         	| [$07cb: ld   (hl),a]
	move.w	#0x0006,d3                      	| [$07cc: ld   de,$0006] 6
	add.w	d3,a0                            	| [$07cf: add  hl,de]
	move.b	#0x53,(a0)                      	| [$07d0: ld   (hl),$53]
	rts                                    	| [$07d2: ret]
l_07d3:
	lea	game_rom+0x2C7D,a0                      	| [$07d3: ld   hl,$2C7D] -  "A 1 PLAYER 1 COIN" script * C0797
	jbsr	ldir                              	| [$07d6: ldir]
	lea	unknown_E05B,a0                	| [$07d8: ld   hl,unknown_E05B]
	jra	l_07a7                             	| [$07db: jr   $07A7]
l_07dd:
	jbsr	l_07e8                            	| [$07dd: call $07E8] -  * C079A
	lea	unknown_E05B,a0                	| [$07e0: ld   hl,unknown_E05B]
	move.b	slot_modeB_e042,d0                 	| [$07e3: ld   a,(slot_modeB_e042)]
	jra	l_07aa                             	| [$07e6: jr   $07AA]
l_07e8:
	lea	continue_timer_E054,a0                	| [$07e8: ld   hl,continue_timer_E054] -  * C0766,C07DD
	jbsr	write_text_to_screen_at_xy_with_delay_034e                            	| [$07eb: call $034E]
	LOAD_LEW	continue_timer_E054,d5             	| [$07ee: ld   hl,(continue_timer_E054)]
	                      	| [$07f1: ld   de,$0040] 64
	add.w	#0x40,d5                            	| [$07f4: add  hl,de]
	STORE_LEW	d5,continue_timer_E054                 	| [$07f5: ld   (continue_timer_E054),hl]
	lea	unknown_E057,a0                	| [$07f8: ld   hl,unknown_E057]
	addq.b	#1,(a0)                         	| [$07fb: inc  (hl)]
	rts                                    	| [$07fc: ret]
l_07fd:
	lea	unknown_E277,a0                	| [$07fd: ld   hl,unknown_E277] -  * C0E48
	move.b	#0x07,d1                        	| [$0800: ld   b,$07]
l_0802:
	move.b	(a0),d0                         	| [$0802: ld   a,(hl)] -  * J0807,J080F
	                               	| [$0803: and  a]
	jeq	l_0811                             	| [$0804: jr   z,$0811]
	subq.w	#1,a0                           	| [$0806: dec  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_0802                             	| [$0807: djnz $0802]
	rts                                    	| [$0809: ret]

l_080a:
	* jotd: seems that L register is used to do stuff
	* we have to emulate that
	lea	unknown_E261,a0                	| [$080a: ld   hl,unknown_E261] -  * C1C54
	move.b	#0x12,d1                        	| [$080d: ld   b,$12]
	jra	l_0802                             	| [$080f: jr   $0802]
l_0811:
	addq.b	#1,(a0)                         	| [$0811: inc  (hl)] -  * J0804
	move.l	a0,d7
	sub.l	#ground_y_array_E200,d7				| compute "L" in D7
	move.b	d7,d0                           	| [$0812: ld   a,l]
	sub.b	#0x50,d0                         	| [$0813: sub  $50]
	add.b	d0,d0                            	| [$0815: add  a,a]
	add.b	d0,d0                            	| [$0816: add  a,a]
	* d0 is the sprite slot offset
	move.b	d0,(0x01,a2)                    	| [$0817: ld   (ix+$01),a]
	rts                                    	| [$081a: ret]
	
* > D7: screen address
compute_screen_address_081b:
	move.b	(obj_y,a2),d0                    	| [$081b: ld   a,(ix+$07)] -  Get the Y coordinate * C1670,C168F
	and.b	#0xF8,d0                         	| [$081e: and  $F8] -  Drop the divide-by-eight remainder (1111_1000)
	move.w	#0x2000,d5                        	| [$0821: ld   h,$20] -  Will be 40xx ... tile memory
	move.b	d0,d5                           	| [$0820: ld   l,a] -  To HL
	add.w	d5,d5                            	| [$0823: add  hl,hl] -  Original Y value of 8 become 16
	add.w	d5,d5                            	| [$0824: add  hl,hl] -  Value 8 becomes 32 ... multiply by 32 (bytes per row)
	move.b	(obj_x,a2),d0                    	| [$0825: ld   a,(ix+$03)] -  Get X coordinate
	roxr.b	#1,d0                           	| [$0828: rra] -  Divide by 2
	move.b	d0,d3                           	| [$0829: ld   d,a] -  Hold this for use in drawing shot
	roxr.b	#2,d0                           	| [$082a: rra] * 2 -  Divide by 4
	and.b	#0x1F,d0                         	| [$082c: and  $1F] -  Only keep the row offset
	add.b	d5,d0                            	| [$082e: add  a,l] -  Add in the offset on the tile row
	move.b	d0,d5                           	| [$082f: ld   l,a] -  Back to L
	move.w	d5,d7
	rts                                    	| [$0830: ret] -  Return pointer in HL
	
* < A2: object structure
update_surface_object_0831:
	* set sprite coords & type for above ground objects & move them
	* rocks
	* tanks
	* mines
	*
	* also check for falls in holes
	* with this routine disabled:
	* - surface objects sprites don't appear (holes still appear)
	* - no collision with objects or falling in holes
	*
	move.b	jeep_params_E300,d0                 	| [$0831: ld   a,(jeep_params_E300)] -  * C162D,C18E0,C1957,C195E,C1A2F,C1E25
	cmp.b	#STATE_FALL_IN_HOLE_06,d0                         	| [$0834: cp   $06]
	jcc	l_08b2                             	| [$0836: jr   nc,$08B2]
update_surface_object_0838:
	* not falling (or called without the check to save cpu time? or to update no matter what?)
	move.b	scroll_logical_delta_x_E1E2,d0                 	| [$0838: ld   a,(unknown_E1E2)] -  * C1950,C1A22,C1A73
	sub.b	(obj_absolute_x,a2),d0                     	| [$083b: sub  (ix+$0f)] object "absolute" X
	neg.b	d0                               	| [$083e: neg]
	move.b	d0,(obj_x,a2)                    	| [$0840: ld   (ix+$03),a] update object screen X
	cmp.b	#0xE0,d0                         	| [$0843: cp   $E0]
	jcs	l_08b4                             	| [$0845: jr   c,$08B4]
	* hole/rock disappearing/appearing in screen
	move.b	(0x0b,a2),d2                    	| [$0847: ld   c,(ix+$0b)]
	subq.b	#1,d2                           	| [$084a: dec  c]
	jne	draw_object_08b8                             	| [$084b: jr   nz,$08B8]
	cmp.b	#0xE8,d0                         	| [$084d: cp   $E8]
	jcc	draw_object_08b8                             	| [$084f: jr   nc,$08B8]
	move.l	(sp)+,a0                        	| [$0851: pop  hl] we'll skip the caller
l_0852:
	clr.b	(a2)                        	| [$0852: ld   (ix+$00),$00] -  * J143E,J1639,J163E,C1711,J177C,J1B13,J1CE0,C1D98,J1E11,J1E30,J1E38,J1E45,J1E55,J1E9E,J2028,J2039,J20BB,J20CF
l_0856:
	move.b	(obj_type,a2),d0                    	| [$0856: ld   a,(ix+$0d)] -  A = object.layoutIndex * C1794,J17C1,J1D20,C1E8B
												| [$0859: scf] -  A = 2 * object.layoutIndex ...
	lsl.b	#1,d0                           	| [$085a: rla] -  ... + 1
	bcc.b	0f                               	| [...]
	rts                                    	| [$085b: ret  c] [...] -  A was >= 0x80 ... not valid
0:
	addq.b	#1,d0                           	| [$085c: scf] -  A = 4 * object.layoutIndex ...
	lea	game_rom+0x2E18,a0                      	| [$085e: ld   hl,$2E18]
	lsl.b	#1,d0                           	| [$085d: rla] -  ... + 3
	jcc	l_0864                             	| [$0861: jr   nc,$0864]
	addq.b	#1,d0
	add.w	#0x100,a0                           	| [$0863: inc  h]
	jra		0f
l_0864:
	addq.b	#1,d0
0:
	clr.w	d3                               	| [$0865: ld   d,$00] -  ... 4 * object.layoutIndex + 3
	move.b	d0,d3                           	| [$0864: ld   e,a] -  DE = ... * J0861
	add.w	d3,a0                            	| [$0867: add  hl,de]
	move.b	(a0),d1                         	| [$0868: ld   b,(hl)] -  B = ObjectLayout[object.layoutIndex].numberOfTiles
l_0869:
	moveq	#0,d3                        	| [$086c: ld   d,$E1]
	move.b	(0x01,a2),d3                    	| [$0869: ld   e,(ix+$01)] -  * J20D8
	move.b	d1,d0                           	| [$086e: ld   a,b]
	roxl.b	#1,d0                           	| [$086f: rla]
	jcc	l_0882                             	| [$0870: jr   nc,$0882]
	move.b	#0x01,d1                        	| [$0872: ld   b,$01]
	roxl.b	#1,d0                           	| [$0874: rla]
	jcs	l_089e                             	| [$0875: jr   c,$089E]
	move.b	d3,d0                           	| [$0877: ld   a,e]
	cmp.b	#0x60,d0                         	| [$0878: cp   $60]
	jcs	l_0882                             	| [$087a: jr   c,$0882]
	* set to E100 plus offset
	lea		 sprite_shadow_E100,a0                          	| [$087c: ld   h,d]
	and.w	#0xFF,d0
	sub.b	#0x5E,d0                         	| [$087d: sub  $5E]
	                           	| [$087f: ld   l,a]
	add.w	d0,a0
	clr.b	(a0)                             	| [$0880: ld   (hl),$00]
l_0882:
	lea		 sprite_shadow_E100,a3                      	| [$0882: ld   iy,$0000] 0 -  * J0870,J087A,C089E
	add.w	d3,a3                            	| [$0886: add  iy,de]
	move.b	d3,d0                           	| [$0888: ld   a,e]
	roxr.b	#2,d0                           	| [$0889: rra] * 2
	and.b	#0x3F,d0                         	| [$088b: and  $3F]
	add.b	#0x50,d0                         	| [$088d: add  a,$50]
	lea		ground_y_array_E200,a0					| [$0890: ld   h,$E2]
	and.w	#0xFF,d0
	add.w	d0,a0                           	| [$088f: ld   l,a]
	                        	
	move.w	#0x0004,d3                      	| [$0892: ld   de,$0004] 4
l_0895:
	clr.b	(0x02,a3)                    	| [$0895: ld   (iy+$02),d] -  * J089A d contains 0: clear
	add.w	d3,a3                            	| [$0898: add  iy,de]
	subq.b	#1,d1                           	| [...]
	jne	l_0895                             	| [$089a: djnz $0895]
	clr.b	(a0)                         	| [$089c: ld   (hl),d]	d contains 0: clear
	rts                                    	| [$089d: ret]
l_089e:
	jbsr	l_0882                            	| [$089e: call $0882] -  * J0875
l_08a1:
	lea	unknown_E174,a0                	| [$08a1: ld   hl,unknown_E174] -  * C1746
	move.b	#0x18,d1                        	| [$08a4: ld   bc,$1800] 6144
	move.b	#0x00,d2                        	| [$08a4: ld   bc,$1800] 6144
l_08a7:
	move.b	d2,(a0)+                         	| [$08a7: ld   (hl),c] -  * J08A9
											| [$08a8: inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_08a7                             	| [$08a9: djnz $08A7]
	lea	unknown_E1D1,a0                	| [$08ab: ld   hl,unknown_E1D1]
	move.b	d1,(a0)+                         	| [$08ae: ld   (hl),b]
												| [$08af: inc  hl]
	move.b	d1,(a0)                         	| [$08b0: ld   (hl),b]
	rts                                    	| [$08b1: ret]
l_08b2:
	move.l	(sp)+,a0                        	| [$08b2: pop  hl] -  * J0836
	rts                                    	| [$08b3: ret]
	* a2: object params (ex: jeep E300)
l_08b4:
	move.b	#0x01,(0x0b,a2)                 	| [$08b4: ld   (ix+$0b),$01] -  * J0845
	
* < A2: object structure
draw_object_08b8:
	moveq	#0,d0
	* when game running, every second update, value is 0x80
	* which makes game return immediately. Rest of the time it's 0
	move.b	(obj_type,a2),d0                    	| [$08b8: ld   a,(ix+$0d)] -  Object number * J084B,J084F,J1360,J13B9,C13D8,C13FF,J1419,C1484,J1615,J1AED,J1D3F,J1D7F,J1D8D,J1D95,J1EA1,J20AF,J20C1,J20C7
	rol.b	#1,d0                            	| [$08bb: rlca] -  Was upper bit set (Thus A*4>=512)?
	bcc.b	0f                               	| [...]
	rts                                    	| [$08bc: ret  c] [...] -  Yes ... skip
0:
	lea	game_rom+0x2E18,a0                      	| [$08be: ld   hl,$2E18] -  Base pointer
	add.w	d0,d0                           	| [$08bd: rla] -  Now *4, on word (simpler & faster on 68000!)
	                             	| [$08c1: jr   nc,$08C4] -  The *4 was all within LSB ... skip
	                           	| [$08c3: inc  h] -  The *4 overflowed ... bump MSB (there is no shift-left-into-H)
l_08c4:
	moveq	#0,d3                               	| [$08c5: ld   d,$00] -  ... now in DE
												| [$08c4: ld   e,a] -  A*4 ... * J08C1
	add.w	d0,a0                            	| [$08c7: add  hl,de] -  HL = 2E18 + A*4 ( A*4 must be less than 512 )
	move.b	(0x01,a2),d3                    	| [$08c8: ld   e,(ix+$01)] -  LSB of object mirror pointer (4 bytes each)
	                        	| [$08cb: ld   d,$E1] -  Sprite mirror
	lea		sprite_shadow_E100,a3                      	| [$08cd: ld   iy,$0000] 0 -  Sprite mirror object ...
	add.w	d3,a3                            	| [$08d1: add  iy,de] -  ... pointer to IY
	move.b	(a0)+,d3                         	| [$08d3: ld   d,(hl)] -  Get starting tile number
	                           	| [$08d4: inc  hl] -  Next
	move.b	(a0)+,d4                         	| [$08d5: ld   e,(hl)] -  Get flips/color
	                           	| [$08d6: inc  hl] -  Next
	clr.w	d1                               	| [$08d8: ld   b,$00] -  Now in BC
	move.b	(a0),d1                         	| [$08d7: ld   c,(hl)] -  Get draw routine, d1 is even!
	lea	jump_table_08F5,a0             	| [$08da: ld   hl,jump_table_08F5] -  Offset into table
	add.w	d1,a0                            	| [$08dd: add  hl,bc] -  Point to jump address
	add.w	d1,a0			| 32 bit: add once more

	move.l	(a0),a0                         	| [$08de: ld   c,(hl)] -  Get jump LSB
									| [$08df: inc  hl] -  Next
									| [$08e0: ld   h,(hl)] -  Get jump MSB
									| [$08e1: ld   l,c] -  Now in HL
	* load jeep X
	move.b	(obj_x,a2),d2                    	| [$08e2: ld   c,(ix+$03)] -  X coordinate to C
	* load jeep Y (relative to ground)
	move.b	(obj_y,a2),d0                    	| [$08e5: ld   a,(ix+$07)] -  Y coordinate to A
	jbsr	compute_jeep_horizon_object_y_08ed                            	| [$08e8: call $08ED] -  ?? adjusted Y coordinate to B
	clr.b	d0                               	| [$08eb: xor  a] -  Clear A ... many handlers need a zero
	* called with d1,d2 as Y,X, d3,d4 as misc parameters
	* draw_exploding_jeep_0af5: d3: start of explosion sprite series, d4 = ?
	jra	(a0)                               	| [$08ec: jp   (hl)] -  Jump to the draw routine


* < D0: delta Y
compute_jeep_horizon_object_y_08ed:
	not.b	d0                               	| [$08ed: cpl] -  * C08E8,C159D,C15CA
	move.b	d0,d1                           	| [$08ee: ld   b,a]
	move.b	jeep_base_y_e03c,d0             	| [$08ef: ld   a,(jeep_base_y_e03c)]
	add.b	d1,d0                            	| [$08f2: add  a,b]
	move.b	d0,d1                           	| [$08f3: ld   b,a]
	rts                                    	| [$08f4: ret]

jump_table_08F5:
	.long	draw_rock_0969                        | 00
	.long	draw_rear_missile_095a                | 02
	.long	draw_volcano_flat_09cf                | 04
	.long	draw_volcano_low_09cd                 | 06
	.long	draw_exploding_jeep_0af5              | 08
	.long	update_jeep_explosion_0943            | 10
	.long	update_jeep_explosion_0ae2            | 12  disappearing explosion
	.long	update_jeep_movement_0a90             | 14
	.long	draw_hole_making_explosion_0a56       | 16
	.long	draw_hole_making_explosion_end_0ab7   | 18
	.long	draw_bomb_smoke_0a52                  | 20
	.long	draw_explosion_smoke_0a9f             | 22
	.long	draw_volcano_medium_09c9              | 24
	.long	draw_ufo_0b25                         | 26
	.long	write_sprite_data_0976                | 28 when shooting
	.long	draw_bomb_explosion_0997 		      | 30
	.long	draw_volcano_high_09ba                | 32
	.long	draw_volcano_kill_score_0a1e          | 34
	.long	draw_jeep_falling_in_hole_0a44        | 36
	.long	draw_rear_missile_attacking_0934      | 38
	.long	draw_mine_0925                        | 40
	.long	draw_hole_making_bomb_0b1d            | 42
	.long	update_exploding_wheels_09b0          | 44 not sure, but it occurs when jeep explodes
	.long	draw_enemy_kill_score_0983            | 46


draw_mine_0925:
	addq.b	#1,(obj_next_frame_timeout,a2)                    	| [$0925: inc  (ix+$0a)]
	move.b	(obj_next_frame_timeout,a2),d0                    	| [$0928: ld   a,(ix+$0a)]
	and.b	#0x1F,d0                         	| [$092b: and  $1F]
	cmp.b	#0x0B,d0                         	| [$092d: cp   $0B]
	jcs	draw_rock_0969                             	| [$092f: jr   c,$0969]
	addq.b	#1,d4                           	| [$0931: inc  e] -  Next color set
	jra	draw_rock_0969                             	| [$0932: jr   $0969]
draw_rear_missile_attacking_0934:
	move.b	timer_8bit_E04E,d0                 	| [$0934: ld   a,(timer_8bit_E04E)]
	and.b	#0x03,d0                         	| [$0937: and  $03]
	jeq	l_093c                             	| [$0939: jr   z,$093C]
	addq.b	#1,d3                           	| [$093b: inc  d]
l_093c:
	jbsr	draw_rock_0969                            	| [$093c: call $0969] -  * J0939
	move.b	#0x3B,d3                        	| [$093f: ld   d,$3B]
	jra	l_095e                             	| [$0941: jr   $095E]
update_jeep_explosion_0943:
	lea	wheels_sprites_shadow_ram_E1A4,a3                	| [$0943: ld   iy,wheels_sprites_shadow_ram_E1A4]
	move.b	d0,(0x0a,a3)                    	| [$0947: ld   (iy+$0a),a]
	move.b	d0,(0x0e,a3)                    	| [$094a: ld   (iy+$0e),a]
	move.b	d0,(0x12,a3)                    	| [$094d: ld   (iy+$12),a]
	move.b	d0,(0x16,a3)                    	| [$0950: ld   (iy+$16),a]
	jbsr	trns_spr_color_0a95                            	| [$0953: call $0A95]
	move.b	#0xF8,d0                        	| [$0956: ld   a,$F8]
	add.b	d1,d0                            	| [$0958: add  a,b]
	move.b	d0,d1                           	| [$0959: ld   b,a]
draw_rear_missile_095a:
	jbsr	draw_rock_0969                            	| [$095a: call $0969]
	addq.b	#1,d3                           	| [$095d: inc  d]
l_095e:
	move.b	#0x10,d0                        	| [$095e: ld   a,$10] -  * J0941
	add.b	d2,d0                            	| [$0960: add  a,c]
	move.b	d0,d2                           	| [$0961: ld   c,a]
										| [$0962: ld   hl,$0004] 4
	                              	| [$0965: ex   de,hl]
	addq.w	#4,a3                            	| [$0966: add  iy,de]
	                              	| [$0968: ex   de,hl]
draw_rock_0969:
	                               	| [$096c: and  a]
	move.b	d2,d0                           	| [$096d: ld   a,c]
	tst.b	(0x0b,a2)                    	| [$0969: ld   a,(ix+$0b)] -  * J092F,J0932,C093C,C095A,C09E4
	jne	l_09a5                             	| [$096e: jr   nz,$09A5]
	add.b	#0x08,d0                         	| [$0970: add  a,$08]
	cmp.b	#0x20,d0                         	| [$0972: cp   $20]
	jcs	l_09ab                             	| [$0974: jr   c,$09AB] -  Blank the tile number

* < A3: sprite shadow ram
* < D1: sprite Y
* < D2: sprite X
* < D3: sprite code
* < D4: sprite attributes

write_sprite_data_0976:
	.ifndef		RELEASE
	* sanity check, make sure that A3 is within bounds
	cmp.l	#sprite_shadow_E100,a3
	bcc.b	0f
	* A3 is too low
	illegal
	jbsr	osd_break
0:
	cmp.l	#scroll_x_value_ground_layer_E1C0,a3
	bcs.b	0f
	* A3 is too high
	illegal
	jbsr	osd_break
0:
	.endif
	
	move.b	d1,(a3)                    	| [$0976: ld   (iy+$00),b] -  Set Y coordinate * J0995,J09A3,J09A9,J09B5,J09B8,J0AF2,C0B25,J0B35,J15A9,J15DD
	move.b	d4,(0x01,a3)                    	| [$0979: ld   (iy+$01),e] -  Set tile flips/color
	move.b	d3,(0x02,a3)                    	| [$097c: ld   (iy+$02),d] -  Set tile number
	move.b	d2,(0x03,a3)                    	| [$097f: ld   (iy+$03),c] -  Set X coordinate
	rts                                    	| [$0982: ret] -  Done
	
draw_enemy_kill_score_0983:
	move.b	(0x08,a2),d0                    	| [$0983: ld   a,(ix+$08)] -  3->300 5->500 8->800, 10->1000 * C0A2D
	move.b	#0x07,d4                        	| [$0986: ld   e,$07] -  Color set (will be 14)
	lsr.b	#1,d0                            	| [$0988: srl  a] -  Lower bit to C
	roxl.b	#1,d4                           	| [$098a: rl   e] -  Now either 14 or 15 ... correct color set
	add.b	#0x7A,d0                         	| [$098c: add  a,$7A] -  Offset to either 7D or 7E
	move.b	d0,d3                           	| [$098e: ld   d,a] -  Tile number
	move.b	d1,d0                           	| [$098f: ld   a,b] -  Y coordinate
	cmp.b	#0x80,d0                         	| [$0990: cp   $80] -  ?? Duplicate if on lower half of screen ??
	jcc	draw_ufo_0b25                             	| [$0992: jp   nc,$0B25]
	jra	write_sprite_data_0976                             	| [$0995: jr   $0976] -  Store the image
draw_bomb_explosion_0997:
	move.b	#0x08,d0                        	| [$0997: ld   a,$08]
	add.b	d1,d0                            	| [$0999: add  a,b]
	move.b	d0,d1                           	| [$099a: ld   b,a]
	lea	unknown_E174,a3                	| [$099b: ld   iy,unknown_E174] -  ?? change to object ??
	move.b	d2,d0                           	| [$099f: ld   a,c]
	cmp.b	#0xF8,d0                         	| [$09a0: cp   $F8]
	bcs.b	0f                               	| [...]
	rts                                    	| [$09a2: ret  nc] [...]
0:
	jra	write_sprite_data_0976                             	| [$09a3: jr   $0976]
l_09a5:
	add.b	#0x08,d0                         	| [$09a5: add  a,$08] -  * J096E
	cmp.b	#0xF0,d0                         	| [$09a7: cp   $F0]
	jcs	write_sprite_data_0976                             	| [$09a9: jr   c,$0976]
l_09ab:
	clr.b	(0x02,a3)                        	| [$09ab: ld   (iy+$02),$00] -  Blank the tile number * J0974
	rts                                    	| [$09af: ret]
update_exploding_wheels_09b0:
	move.b	timer_8bit_E04E,d0                 	| [$09b0: ld   a,(timer_8bit_E04E)] -  ISR1 up counter
	btst.b	#2,d0                           	| [$09b3: bit  2,a] -  Chance ...
	jeq	write_sprite_data_0976                             	| [$09b5: jr   z,$0976] -  ... to use ...
	addq.b	#1,d3                           	| [$09b7: inc  d] -  ... next image
	jra	write_sprite_data_0976                             	| [$09b8: jr   $0976] -  Store sprite details

draw_volcano_high_09ba:
	move.b	#0x0E,d0                        	| [$09ba: ld   a,$0E]
	add.b	d1,d0                            	| [$09bc: add  a,b]
	move.b	d1,d5                           	| [$09bd: ld   h,b]
	move.b	d0,d1                           	| [$09be: ld   b,a]
	move.b	#0x01,d6                        	| [$09bf: ld   l,$01]
	jbsr	l_09e4                            	| [$09c1: call $09E4]
	move.b	#0x76,d3
	move.b	#0x08,d4                      	| [$09c4: ld   de,$7608]
	jra	l_09da                             	| [$09c7: jr   $09DA]
draw_volcano_medium_09c9:
	move.b	#0x0A,d0                        	| [$09c9: ld   a,$0A]
	jra	draw_volcano_flat_09cf                             	| [$09cb: jr   $09CF]
draw_volcano_low_09cd:
	move.b	#0x05,d0                        	| [$09cd: ld   a,$05]
draw_volcano_flat_09cf:
	add.b	d1,d0                            	| [$09cf: add  a,b] -  * J09CB
	move.b	d1,d5                           	| [$09d0: ld   h,b]
	move.b	d0,d1                           	| [$09d1: ld   b,a]
	move.b	#0x01,d6                        	| [$09d2: ld   l,$01]
	jbsr	l_09e4                            	| [$09d4: call $09E4]
	move.b	#0x71,d3
	move.b	#0x08,d4                      	| [$09d7: ld   de,$7108]
l_09da:
	move.b	d5,d1                           	| [$09da: ld   b,h] -  * J09C7
	                    	| [$09db: ld   hl,$0008] 8
	                   	| [$09de: ex   de,hl]
	addq.w	#8,a3                            	| [$09df: add  iy,de]
	                              	| [$09e1: ex   de,hl]
	clr.b	d6                               	| [$09e2: ld   l,$00]
l_09e4:
	jbsr	draw_rock_0969                            	| [$09e4: call $0969] -  * C09C1,C09D4,J0A3C
	move.b	d1,(0x04,a3)                    	| [$09e7: ld   (iy+$04),b]
	subq.b	#1,d6                           	| [$09ea: dec  l]
	jne	l_0a16                             	| [$09eb: jr   nz,$0A16]
	move.b	#0x40,d0                        	| [$09ed: ld   a,$40]
	eor.b	d4,d0                            	| [$09ef: xor  e]
	move.b	d0,(0x05,a3)                    	| [$09f0: ld   (iy+$05),a]
	move.b	#0x08,d0                        	| [$09f3: ld   a,$08]
l_09f5:
	move.b	d3,(0x06,a3)                    	| [$09f5: ld   (iy+$06),d] -  * J0A1C
	add.b	d2,d0                            	| [$09f8: add  a,c]
	move.b	d0,(0x07,a3)                    	| [$09f9: ld   (iy+$07),a]
	add.b	#0x08,d0                         	| [$09fc: add  a,$08]
	cmp.b	#0xF8,d0                         	| [$09fe: cp   $F8]
	jcc	l_0a0c                             	| [$0a00: jr   nc,$0A0C]
	cmp.b	#0x20,d0                         	| [$0a02: cp   $20]
	bcs.b	0f                               	| [...]
	rts                                    	| [$0a04: ret  nc] [...]
0:
	move.b	(0x0b,a2),d0                    	| [$0a05: ld   a,(ix+$0b)]
	                               	| [$0a08: and  a]
	jeq	l_0a11                             	| [$0a09: jr   z,$0A11]
	rts                                    	| [$0a0b: ret]
l_0a0c:
	move.b	(0x0b,a2),d0                    	| [$0a0c: ld   a,(ix+$0b)] -  * J0A00
	                               	| [$0a0f: and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [$0a10: ret  z] [...]
0:
l_0a11:
	clr.b	(0x06,a3)                        	| [$0a11: ld   (iy+$06),$00] -  * J0A09
	rts                                    	| [$0a15: ret]
l_0a16:
	addq.b	#1,d3                           	| [$0a16: inc  d] -  * J09EB
	move.b	d4,(0x05,a3)                    	| [$0a17: ld   (iy+$05),e]
	move.b	#0x10,d0                        	| [$0a1a: ld   a,$10]
	jra	l_09f5                             	| [$0a1c: jr   $09F5]
draw_volcano_kill_score_0a1e:
	movem.w	d1/d2,-(sp)                    	| [$0a1e: push bc]
	movem.w	d3/d4,-(sp)                    	| [$0a1f: push de]
	move.l	a1,-(sp)                        	| [$0a1f: push de]
	move.w	#0x0802,d5                   	| [$0a20: ld   hl,$0802]
	lsl.w	#8,d1
	move.b	d2,d1
	add.w	d1,d5                            	| [$0a23: add  hl,bc]


	move.w	d5,d1                           	| [$0a24: ld   b,h]
	lsr.w	#8,d1
	move.b	d5,d2                           	| [$0a25: ld   c,l]
	move.b	d2,d0                           	| [$0a26: ld   a,c]
	add.b	#0x08,d0                         	| [$0a27: add  a,$08]
	cmp.b	#0xD0,d0                         	| [$0a29: cp   $D0]
	jcc	l_0a3e                             	| [$0a2b: jr   nc,$0A3E]
	jbsr	draw_enemy_kill_score_0983                            	| [$0a2d: call $0983]
l_0a30:
	move.w	#0x0004,d3                      	| [$0a30: ld   de,$0004] 4 -  * J0A42
	add.w	d3,a3                            	| [$0a33: add  iy,de]
	move.l	(sp)+,a1                        	| [$0a35: pop  de]
	movem.w	(sp)+,d3/d4                    	| [$0a35: pop  de]

	movem.w	(sp)+,d1/d2                    	| [$0a36: pop  bc]
	clr.b	d6                               	| [$0a37: ld   l,$00]
	move.b	d6,(0x0a,a3)                    	| [$0a39: ld   (iy+$0a),l]
	jra	l_09e4                             	| [$0a3c: jr   $09E4]
l_0a3e:
	clr.b	(0x02,a3)                        	| [$0a3e: ld   (iy+$02),$00] -  * J0A2B
	jra	l_0a30                             	| [$0a42: jr   $0A30]
draw_jeep_falling_in_hole_0a44:
	move.b	d0,unknown_E1A6                 	| [$0a44: ld   (unknown_E1A6),a]
	move.b	d0,unknown_E1AA                 	| [$0a47: ld   (unknown_E1AA),a]
	move.b	d0,unknown_E1AE                 	| [$0a4a: ld   (unknown_E1AE),a]
	jbsr	trns_spr_color_0a95                            	| [$0a4d: call $0A95]
	jra	l_0a62                             	| [$0a50: jr   $0A62]
draw_bomb_smoke_0a52:
	move.b	#0x18,d0                        	| [$0a52: ld   a,$18] -  Offset by -$18 when drawing
	jra	l_0a58                             	| [$0a54: jr   $0A58] -  Draw the 2x2
draw_hole_making_explosion_0a56:
	move.b	#0x0D,d0                        	| [$0a56: ld   a,$0D] -  Offset by -$0D when drawing
l_0a58:
	lea	unknown_E174,a3                	| [$0a58: ld   iy,unknown_E174] -  * J0A54
	add.b	d1,d0                            	| [$0a5c: add  a,b] -  Offset ...
	move.b	d0,d1                           	| [$0a5d: ld   b,a] -  ... Y coordinate
	move.b	#0xF8,d0                        	| [$0a5e: ld   a,$F8] -  Offset X ...
	add.b	d2,d0                            	| [$0a60: add  a,c] -  ... back 8 ...
	move.b	d0,d2                           	| [$0a61: ld   c,a] -  ... to center on X
l_0a62:
	* update jeep sprite
	clr.b	d0                               	| [$0a62: xor  a] -  X coordinate offset is 0 * J0A50,J0A93
	* first row
	jbsr	update_jeep_sprite_row_0a6f                            	| [$0a63: call $0A6F] -  Do top and bottom tiles
	
	                   	| [$0a66: ex   de,hl] -  Skip over ...
	                    	| [$0a67: ld   de,$0008] 8 -  ... the two ...
	* second row
	addq.w	#8,a3                            	| [$0a6a: add  iy,de] -  ... sprite ...
	                              	| [$0a6c: ex   de,hl] -  ... slots
	move.b	#0x10,d0                        	| [$0a6d: ld   a,$10] -  X coordinate offset is 16
update_jeep_sprite_row_0a6f:
	add.b	d2,d0                            	| [$0a6f: add  a,c] -  Add the X coordinate offset * C0A63,C0AB0,C0ACD,C0B13
	move.b	d0,d6                           	| [$0a70: ld   l,a] -  Hold in L
	* set sprite X for 2 first sprites (jeep rear)
	move.b	d0,(obj_x,a3)                    	| [$0a71: ld   (iy+$03),a] -  Set the X coordinate for top sprite
	move.b	d0,(obj_y,a3)                    	| [$0a74: ld   (iy+$07),a] -  Set the X coordinate for the bottom sprite
	* set sprite Y
	move.b	d1,(a3)                    	| [$0a77: ld   (iy+$00),b] -  Set the Y coordinate for top sprite
	move.b	#0xF0,d0                        	| [$0a7a: ld   a,$F0] -  Back up ...
	add.b	d1,d0                            	| [$0a7c: add  a,b] -  ... 8
	* set sprite Y
	move.b	d0,(0x04,a3)                    	| [$0a7d: ld   (iy+$04),a] -  Set the Y coordinate for the bottom sprite
	* set attributes
	move.b	d4,(0x01,a3)                    	| [$0a80: ld   (iy+$01),e] -  Set the color/flip for top sprite
	move.b	d4,(0x05,a3)                    	| [$0a83: ld   (iy+$05),e] -  Set the color/flip for bottom sprite
	* set sprite code
	move.b	d3,(0x02,a3)                    	| [$0a86: ld   (iy+$02),d] -  Store tile number
	addq.b	#2,d3                           	| [$0a89: inc  d] * 2 -  Add 2 for ...
	move.b	d3,(0x06,a3)                    	| [$0a8b: ld   (iy+$06),d] -  Set next tile
	subq.b	#1,d3                           	| [$0a8e: dec  d] -  Now back to just tile+1
	rts                                    	| [$0a8f: ret] -  Done
update_jeep_movement_0a90:
	* called during the demo & game to update jeep movement
	jbsr	trns_spr_color_0a95                            	| [$0a90: call $0A95]
	jra	l_0a62                             	| [$0a93: jr   $0A62]
trns_spr_color_0a95:
	move.b	champ_colors_e0f9,d0                 	| [$0a95: ld   a,(champ_colors_e0f9)] -  Are we on ... * C0953,C0A4D,C0A90,C0AE9,C0AFD
	ror.b	#1,d0                           	| [$0a98: rra] -  ... the champion course?
	bcs.b	0f                               	| [...]
	rts                                    	| [$0a99: ret  nc] [...] -  No ... leave color set 0
0:
	move.b	d4,d0                           	| [$0a9a: ld   a,e] -  Get the color set value
	or.b	#0x0C,d0                          	| [$0a9b: or   $0C] -  Transform to C
	move.b	d0,d4                           	| [$0a9d: ld   e,a] -  Back to color set value
	rts                                    	| [$0a9e: ret] -  Done
draw_explosion_smoke_0a9f:
	lea	unknown_E174,a3                	| [$0a9f: ld   iy,unknown_E174]
	clr.b	(0x0a,a3)                        	| [$0aa3: ld   (iy+$0a),$00]
	clr.b	(0x0e,a3)                        	| [$0aa7: ld   (iy+$0e),$00]
	move.b	#0x18,d0                        	| [$0aab: ld   a,$18]
	add.b	d1,d0                            	| [$0aad: add  a,b]
	move.b	d0,d1                           	| [$0aae: ld   b,a]
	clr.b	d0                               	| [$0aaf: xor  a]
	jbsr	update_jeep_sprite_row_0a6f                            	| [$0ab0: call $0A6F]
	move.b	d3,(0x06,a3)                    	| [$0ab3: ld   (iy+$06),d]
	rts                                    	| [$0ab6: ret]
draw_hole_making_explosion_end_0ab7:
	move.b	#0x18,d0                        	| [$0ab7: ld   a,$18]
	add.b	d1,d0                            	| [$0ab9: add  a,b]
	move.b	d0,d1                           	| [$0aba: ld   b,a]
	lea	unknown_E174,a3                	| [$0abb: ld   iy,unknown_E174]
	move.b	#0xF8,d0                        	| [$0abf: ld   a,$F8]
	jbsr	l_0acd                            	| [$0ac1: call $0ACD]
										| [$0ac4: ld   hl,$000C] 12
	                              	| [$0ac7: ex   de,hl]
	add.w	#0xC,a3                            	| [$0ac8: add  iy,de]
	                              	| [$0aca: ex   de,hl]
	move.b	#0x08,d0                        	| [$0acb: ld   a,$08]
l_0acd:
	jbsr	update_jeep_sprite_row_0a6f                            	| [$0acd: call $0A6F] -  * C0AC1
	move.b	d6,(0x0b,a3)                    	| [$0ad0: ld   (iy+$0b),l]
	sub.b	#0x10,d0                         	| [$0ad3: sub  $10]
	move.b	d0,(0x08,a3)                    	| [$0ad5: ld   (iy+$08),a]
	move.b	d0,(0x09,a3)                    	| [$0ad8: ld   (iy+$09),a]
	move.b	d3,d0                           	| [$0adb: ld   a,d]
	addq.b	#0x03,d0                        	| [$0adc: add  a,$03]
	move.b	d0,(0x0a,a3)                    	| [$0ade: ld   (iy+$0a),a]
	rts                                    	| [$0ae1: ret]
	
update_jeep_explosion_0ae2:
	lea	wheels_sprites_shadow_ram_E1A4,a3                	| [$0ae2: ld   iy,wheels_sprites_shadow_ram_E1A4]
	move.b	d0,(0x06,a3)                    	| [$0ae6: ld   (iy+$06),a]
	jbsr	trns_spr_color_0a95                            	| [$0ae9: call $0A95]
	LOAD_D1_16_FROM_D1D2
	sub.w	#0x7f8,d1                      	| [$0aec: ld   hl,-$7f8]
	                            	| [$0aef: add  hl,bc]
	                           	| [$0af0: ld   b,h]	
	LOAD_D1D2_FROM_D1_16                           	| [$0af1: ld   c,l]
	jra	write_sprite_data_0976                             	| [$0af2: jp   $0976]

draw_exploding_jeep_0af5:
	lea	wheels_sprites_shadow_ram_E1A4,a3                	| [$0af5: ld   iy,wheels_sprites_shadow_ram_E1A4]
	clr.b	(0x1a,a3)                        	| [$0af9: ld   (iy+$1a),$00]
	jbsr	trns_spr_color_0a95                            	| [$0afd: call $0A95]
	move.b	#0xF8,d0                        	| [$0b00: ld   a,$F8]
	jbsr	l_0b13                            	| [$0b02: call $0B13]
	move.b	#0x08,d0                        	| [$0b05: ld   a,$08]
	jbsr	l_0b0c                            	| [$0b07: call $0B0C]
	move.b	#0x18,d0                        	| [$0b0a: ld   a,$18]
l_0b0c:
												| [$0b0c: ex   de,hl] -  * C0B07
												| [$0b0d: ld   de,$0008] 8
	addq.w	#8,a3                            	| [$0b10: add  iy,de]
												| [$0b12: ex   de,hl]
l_0b13:
	jbsr	update_jeep_sprite_row_0a6f                            	| [$0b13: call $0A6F] -  * C0B02
	move.b	d3,d0                           	| [$0b16: ld   a,d]
	addq.b	#0x02,d0                        	| [$0b17: add  a,$02]
	move.b	d0,(0x06,a3)                    	| [$0b19: ld   (iy+$06),a]
	rts                                    	| [$0b1c: ret]
draw_hole_making_bomb_0b1d:
	move.b	timer_8bit_E04E,d0                 	| [$0b1d: ld   a,(timer_8bit_E04E)]
	btst.b	#1,d0                           	| [$0b20: bit  1,a]
	jeq	draw_ufo_0b25                             	| [$0b22: jr   z,$0B25]
	addq.b	#1,d4                           	| [$0b24: inc  e]
	* used to draw UFOs and UFO bombs
draw_ufo_0b25:
	jbsr	write_sprite_data_0976                            	| [$0b25: call $0976] -  * J0992,J0B22
	move.b	(0x01,a2),d0                    	| [$0b28: ld   a,(ix+$01)] -  LSB of object pointer
	cmp.b	#0x60,d0                         	| [$0b2b: cp   $60] -  Less than 96?
	bcc.b	0f                               	| [...]
	rts                                    	| [$0b2d: ret  c] [...] -  Yes ... done
0:
	                              	| [$0b2e: ex   de,hl] -  Hold DE
											| [$0b2f: ld   de,-$60] -  Value -96
	sub.w	#0x60,a3                            	| [$0b32: add  iy,de] -  IY = IY - 96
												| [$0b34: ex   de,hl] -  Restore DE
	jra	write_sprite_data_0976                             	| [$0b35: jp   $0976] -  ?? Initialize "other" object to same
l_0b38:
	jbsr	l_0c8e                            	| [$0b38: call $0C8E] -  * C0112
	jbsr	l_0cbf                            	| [$0b3b: call $0CBF]
	jbsr	osd_read_dsw_2                       	| [$0b3e: ld   a,($D004)]
	btst.b	#5,d0                           	| [$0b41: bit  5,a]
	beq.b	0f                               	| [...]
	rts                                    	| [$0b43: ret  nz] [...]
0:
	lea	game_rom+0x2AA9,a0                      	| [$0b44: ld   hl,$2AA9] -  "PICTURE NUMBER SET" message
	jbsr	write_to_screen_possible_typing_effect_300                            	| [$0b47: call $0300]
l_0b4a:
	st.b	d0                                	| [$0b4a: ld   a,$FF] -  * J0B68,J0B88
	move.b	d0,isr_count4_e051                 	| [$0b4c: ld   (isr_count4_e051),a]
	lea	coin_start_e053,a0                	| [$0b4f: ld   hl,coin_start_e053]
	move.b	(a0),d0                         	| [$0b52: ld   a,(hl)]
l_0b53:
	move.b	(a0),d2                         	| [$0b53: ld   c,(hl)] -  * J0B5E
	eor.b	d2,d0                            	| [$0b54: xor  c]
	and.b	d2,d0                            	| [$0b55: and  c]
	ror.b	#1,d0                           	| [$0b56: rra]
 	jcs	l_0b61                             	| [$0b57: jr   c,$0B61]
	move.b	isr_count4_e051,d0                 	| [$0b59: ld   a,(isr_count4_e051)]
	move.b	d0,d1                           	| [$0b5c: ld   b,a]
	move.b	d2,d0                           	| [$0b5d: ld   a,c]
	subq.b	#1,d1                           	| [...]
	jne	l_0b53                             	| [$0b5e: djnz $0B53]
	rts                                    	| [$0b60: ret]
l_0b61:
	lea	cur_point_e50e,a0                	| [$0b61: ld   hl,cur_point_e50e] -  Current passed point * J0B57
	move.b	(a0),d0                         	| [$0b64: ld   a,(hl)] -  Get the current point
	addq.b	#1,d0                           	| [$0b65: inc  a] -  Increment to next
	cmp.b	#0x34,d0                         	| [$0b66: cp   $34]
	jcc	l_0b4a                             	| [$0b68: jr   nc,$0B4A]
	move.b	d0,(a0)                         	| [$0b6a: ld   (hl),a] -  New passed point
	move.l	track_events_data_pointer_E516,a0             	| [$0b6b: ld   hl,(track_events_data_pointer_E516)]
l_0b6e:
	move.b	(a0)+,d1                         	| [$0b6e: ld   b,(hl)] -  * J0B76
	                           	| [$0b6f: inc  hl]
	move.b	(a0)+,d0                         	| [$0b70: ld   a,(hl)]
	and.b	#0x7F,d0                         	| [$0b71: and  $7F]
	                           	| [$0b73: inc  hl]
	cmp.b	#0x06,d0                         	| [$0b74: cp   $06]
	jne	l_0b6e                             	| [$0b76: jr   nz,$0B6E]
	move.b	d1,d0                           	| [$0b78: ld   a,b]
	move.b	d0,fine_position_on_track_E50B                 	| [$0b79: ld   (fine_position_on_track_E50B),a]
	move.l	a0,track_events_data_pointer_E516                 	| [$0b7c: ld   (track_events_data_pointer_E516),hl]
	move.b	d0,unknown_E523                 	| [$0b7f: ld   (unknown_E523),a]
	move.l	a0,unknown_pointer_E52E                 	| [$0b82: ld   (unknown_pointer_E52E),hl]
	jbsr	l_0d12                            	| [$0b85: call $0D12]
	jra	l_0b4a                             	| [$0b88: jr   $0B4A]

display_status_bar_0b8a:
	jbsr	l_0cb1                            	| [$0b8a: call $0CB1] -  * C0069,C0089
	lea	game_rom+0x2694,a0                      	| [$0b8d: ld   hl,$2694]
	move.l	a0,track_events_data_pointer_E516                 	| [$0b90: ld   (track_events_data_pointer_E516),hl]
	jra	l_0cbf                             	| [$0b93: jp   $0CBF]
l_0b96:
	move.l	track_events_data_pointer_E516,a0             	| [$0b96: ld   hl,(track_events_data_pointer_E516)] -  * C0123,C0BE8
l_0b99:
	                           	| [$0b99: dec  hl] -  * J0BA0,J0BAB
	move.b	-(a0),d0                         	| [$0b9a: ld   a,(hl)]
	subq.w	#1,a0                           	| [$0b9b: dec  hl]
	and.b	#0x7F,d0                         	| [$0b9c: and  $7F]
	cmp.b	#0x06,d0                         	| [$0b9e: cp   $06]
	jne	l_0b99                             	| [$0ba0: jr   nz,$0B99]
	lea	unknown_E1DC,a1                	| [$0ba2: ld   de,unknown_E1DC]
	exg	a1,a0                              	| [$0ba5: ex   de,hl]
	move.b	(a0),d0                         	| [$0ba6: ld   a,(hl)]
	clr.b	(a0)                             	| [$0ba7: ld   (hl),$00]
	exg	a1,a0                              	| [$0ba9: ex   de,hl]
	tst.b	d0                               	| [$0baa: and  a]
	jne	l_0b99                             	| [$0bab: jr   nz,$0B99]
	move.b	(a0),d0                         	| [$0bad: ld   a,(hl)]
	move.b	d0,fine_position_on_track_E50B                 	| [$0bae: ld   (fine_position_on_track_E50B),a]
	addq.w	#2,a0                           	| [$0bb1: inc  hl] * 2
	move.l	a0,track_events_data_pointer_E516                 	| [$0bb3: ld   (track_events_data_pointer_E516),hl]
	rts                                    	| [$0bb6: ret]
	
start_new_section_0bb7:
	lea	sprite_shadow_E100,a0          	| [$0bb7: ld   hl,sprite_shadow_E100] -  Clear sprite mirror ... * J0078,J008C,J0115,J0138,J0142,J0148,J0173,J01CF,J28A7,J28B7
	move.w	#0x400,d1                        	| [$0bba: ld   bc,$0400] 1024 -  ... and game objects ...
	jbsr	clear_area_05fa                   	| [$0bbd: call clear_area_05fa] -  ... up to high-score
	lea	jeep_params_E300,a2                	| [$0bc0: ld   ix,jeep_params_E300] -  Moon buggy ISRObject 00
	move.b	#STATE_REPOSITION_DEFAULT_01,(a2)                 	| [$0bc4: ld   (ix+$00),$01] -  Moon buggy's start-game handler
	move.b	#0x09,(0x10,a2)                 	| [$0bc8: ld   (ix+$10),$09] -  ?? handler
	move.b	#0xB0,(0x01,a2)                 	| [$0bcc: ld   (ix+$01),$B0] -  Moon buggy uses sprites B0
	move.b	#0xA0,(0x21,a2)                 	| [$0bd0: ld   (ix+$21),$A0] -  ?? uses sprites A0
	lea	ufo_objects_e370,a2                	| [$0bd4: ld   ix,ufo_objects_e370]
	move.b	#0x60,d0                        	| [$0bd8: ld   a,$60]
	move.b	#MAX_NB_UFOS_2,d1                        	| [$0bda: ld   b,$09]
	move.w	#0x0010,d3                      	| [$0bdc: ld   de,$0010] 16
l_0bdf:
	move.b	d0,(0x01,a2)                    	| [$0bdf: ld   (ix+$01),a] -  * J0BE6
	add.w	d3,a2                            	| [$0be2: add  ix,de]
	addq.b	#0x04,d0                        	| [$0be4: add  a,$04]
	subq.b	#1,d1                           	| [...]
	jne	l_0bdf                             	| [$0be6: djnz $0BDF]
	jbsr	l_0b96                            	| [$0be8: call $0B96]
									| [$0beb: dec  hl]
	move.b	-(a0),d1                         	| [$0bec: ld   b,(hl)]
	move.b	#0x04,d0                        	| [$0bed: ld   a,$04]
	move.b	#0xC0,d5                      	| [$0bef: ld   hl,$C000]
	move.b	#0x00,d6                      	| [$0bef: ld   hl,$C000]
	subq.b	#1,d1                           	| [$0bf2: dec  b]
	jpl	l_0bfa                             	| [$0bf3: jp   p,$0BFA]
	move.b	#0x07,d0                        	| [$0bf6: ld   a,$07]
	move.b	#0xA8,d5                        	| [$0bf8: ld   h,$A8]
l_0bfa:
	move.b	d0,terrain_height_in_tiles_E514                 	| [$0bfa: ld   (terrain_height_in_tiles_E514),a] -  * J0BF3
	move.b	d6,unknown_16bit_E306                 	| [$0bfd: ld   (unknown_16bit_E306),hl]
	move.b	d5,jeep_y_offset_E307                 	| [$0bfd: ld   (unknown_16bit_E306),hl]
	move.b	#TERRAIN_BUMPY_02,d0                        	| [$0c00: ld   a,$02]
	move.b	d0,terrain_slope_type_E508                 	| [$0c02: ld   (terrain_slope_type_E508),a]
	jbsr	draw_ground_0d8d                  	| [$0c05: call draw_ground_0d8d]
	move.b	unknown_E513,d0                 	| [$0c08: ld   a,(unknown_E513)]
	subq.b	#1,d0                           	| [$0c0b: dec  a]
	cmp.b	#0x05,d0                         	| [$0c0c: cp   $05]
	SET_X_FROM_C
	moveq	#0,d7
	addx.b	d7,d0			| [adc  a,$00]
	move.b	#0xFB,d1                        	| [$0c10: ld   b,$FB]
	roxr.b	#1,d0                           	| [$0c12: rra]
	jcs	l_0c16                             	| [$0c13: jr   c,$0C16]
	addq.b	#1,d1                           	| [$0c15: inc  b]
l_0c16:
	move.b	d1,d0                           	| [$0c16: ld   a,b] -  * J0C13
	* can write 0 (no layers), FB: green mountain, FC: green city
	move.b	d0,background_layer_control_E1C5   	| [$0c17: ld   (background_layer_control_E1C5),a]
	jbsr	current_point_modulus_26_2981                            	| [$0c1a: call $2981]
	tst.b	d0                               	| [$0c1d: and  a]
	jne	skip_moonbase_display_0c7f                             	| [$0c1e: jr   nz,$0C7F]
	lea	moonbase_already_displayed_E50F,a0                	| [$0c20: ld   hl,moonbase_already_displayed_E50F]
	btst.b	#0,(a0)                         	| [$0c23: bit  0,(hl)]
	jne	skip_moonbase_display_0c7f                             	| [$0c25: jr   nz,$0C7F] moonbase already displayed: skip intro
	addq.b	#1,(a0)                         	| [$0c27: inc  (hl)]
	move.b	current_level_E510,d0                	| [$0c28: ld   a,(current_level_E510)] -  Get the course number
	                               	| [$0c2b: and  a] -  Is this the first time?
	jeq	l_0c86                             	| [$0c2c: jr   z,$0C86]  0: beginners course -  Yes ... go start "BEGINNER" course
	* CHAMPION COURSE text followed by number
	lea	game_rom+0x2A5F,a0                      	| [$0c2e: ld   hl,$2A5F] -  "CHAMPION COURSE 1 GO" script
	jbsr	write_to_screen_possible_typing_effect_300                            	| [$0c31: call $0300] -  Print the banner
	move.b	current_level_E510,d0                	| [$0c34: ld   a,(current_level_E510)] -  Get the champion course number
	cmp.b	#0x04,d0                         	| [$0c37: cp   $04] -  Is it a 1, 2, or 3?
	jcs	l_0c3d                             	| [$0c39: jr   c,$0C3D] -  Yes keep it
	* max 3
	move.b	#0x03,d0                        	| [$0c3b: ld   a,$03] -  No ... cap the number at 3
l_0c3d:
	add.b	#0x30,d0                         	| [$0c3d: add  a,$30] -  Convert to number * J0C39
	move.w	#0x8156,d7
	jbsr	osd_w_videoram                       	| [$0c3f: ld   ($8156),a] -  Change the "1" in the message just printed to the right number
	
	
display_moon_base_0c42:
	* for some reason, intro music doesn't start if sound isn't stopped first...
	jbsr	osd_sound_stop
	move.b	#0x1C,d0                        	| [$0c42: ld   a,$1C] -  Play intro ... * J0C8C
	jbsr	queue_sound_effect_0d6f                            	| [$0c44: call $0D6F] -  ... song

	move.b	#0x40,d0                        	| [$0c47: ld   a,$40] -  Set timer for ...
	move.b	d0,unknown_E30A                 	| [$0c49: ld   (unknown_E30A),a] -  ... intro song to end
	* moon base start character
	move.b	#0x68,d2                        	| [$0c4c: ld   c,$68]
	* kind of RLE encoded sequence: attribute,start address,end address
	* here character increases each time
	lea	game_rom+0x30B6,a0                      	| [$0c4e: ld   hl,$30B6]
l_0c51:
	* character attribute
	move.b	(a0),d1                         	| [$0c51: ld   b,(hl)] -  * J0C68
	btst.b	#7,d1                           	| [$0c52: bit  7,b]
	jne	l_0c6a                             	| [$0c54: jr   nz,$0C6A] end of sequence
	addq.w	#1,a0                           	| [$0c56: inc  hl]
	* start address 
	move.b	(a0)+,d7                         	| [$0c57: ld   e,(hl)]
	                           	| [$0c58: inc  hl]
	* end address LSB
	move.b	(a0)+,d0                         	| [$0c59: ld   a,(hl)]
	                           	| [$0c5a: inc  hl]
	
	* save HL in DE not needed                       	| [$0c5b: ex   de,hl]
l_0c5c:
	ror.w	#8,d7
	move.b	#0x83,d7                        	| [$0c5f: ld   h,$87] -  In screen color memory ??
	ror.w	#8,d7
	move.w	d0,-(sp)
	move.b	d2,d0                         	| [$0c5e: ld   (hl),c]
	jbsr	osd_w_videoram
	move.w	(sp)+,d0
	ror.w	#8,d7
	move.b	#0x87,d7                        	| [$0c5f: ld   h,$87] -  In screen color memory ??
	ror.w	#8,d7
	move.w	d0,-(sp)
	move.b	d1,d0                         	| [$0c61: ld   (hl),b]
	jbsr	osd_w_colorram
	move.w	(sp)+,d0
	addq.b	#1,d2                           	| [$0c62: inc  c] next moonbase character
	addq.b	#1,d7                           	| [$0c63: inc  l]
	cmp.b	d7,d0                            	| [$0c64: cp   l]
	jne	l_0c5c                             	| [$0c65: jr   nz,$0C5C]
	* restore HL not needed                              	| [$0c67: ex   de,hl]
	jra	l_0c51                             	| [$0c68: jr   $0C51]
l_0c6a:
	move.b	#0xD3,d0                        	| [$0c6a: ld   a,$D3] -  * J0C54
	lea	game_rom+0x30D8,a0                      	| [$0c6c: ld   hl,$30D8]
	lea	unknown_E210,a1                	| [$0c6f: ld   de,unknown_E210]
l_0c72:
	move.b	(a0),d1                         	| [$0c72: ld   b,(hl)] -  * J0C7D
	btst.b	#7,d1                           	| [$0c73: bit  7,b]
	jne	skip_moonbase_display_0c7f                             	| [$0c75: jr   nz,$0C7F]
l_0c77:
	move.b	d0,(a1)+                         	| [$0c77: ld   (de),a] -  * J0C79
	                           	| [$0c78: inc  de]
	subq.b	#1,d1                           	| [...]
	jne	l_0c77                             	| [$0c79: djnz $0C77]
	addq.b	#1,d0                           	| [$0c7b: inc  a]
	addq.w	#1,a0                           	| [$0c7c: inc  hl]
	jra	l_0c72                             	| [$0c7d: jr   $0C72]
skip_moonbase_display_0c7f:
	lea	game_status_bits_E046,a0                	| [$0c7f: ld   hl,game_status_bits_E046] -  * J0C1E,J0C25,J0C75
	addq.b	#1,(a0)                         	| [$0c82: inc  (hl)]
	jra	game_mainloop_026e                             	| [$0c83: jp   $026E] -  ?? Main text loop for game
l_0c86:
	lea	game_rom+0x2A47,a0                      	| [$0c86: ld   hl,$2A47] -  "BEGINNER COURSE GO" script * J0C2C
	jbsr	write_to_screen_possible_typing_effect_300                            	| [$0c89: call $0300] -  Print the banner
	jra	display_moon_base_0c42                             	| [$0c8c: jr   $0C42] -  Back to start-course sequence
l_0c8e:
	clr.b	d0                               	| [$0c8e: xor  a] -  * C0B38
	clr.b	title_display_timer_E04D                 	| [$0c8f: ld   (title_display_timer_E04D),a]
	jbsr	l_0c95                            	| [$0c92: call $0C95]
l_0c95:
	jbsr	swap_players_0603                            	| [$0c95: call $0603] -  * C0C92
	* reset player score, level ...
	lea	player_score_E500,a0                	| [$0c98: ld   hl,player_score_E500]
	move.w	#0x16,d1                        	| [$0c9b: ld   bc,$0016] 22
l_0c9e:
	jbsr	clear_area_05fa                   	| [$0c9e: call clear_area_05fa] -  * J0CBD
	clr.b	moonbase_already_displayed_E50F   | [$0ca1: ld   (moonbase_already_displayed_E50F),a] reuse zeroed a value after clear_area_05fa, bad!!!!
	move.b	start_level_flag,d0
	beq.b	0f
	* start level not zero
	move.b	#0x1A,cur_point_e50e
	move.b	d0,current_level_E510
0:
	move.b	lives_per_credit_e040,d0                 	| [$0ca4: ld   a,(lives_per_credit_e040)]
	move.b	d0,nb_lives_E515                	| [$0ca7: ld   (nb_lives_E515),a]
	* beginner course data
	lea	game_rom+0x2162,a0                      	| [$0caa: ld   hl,$2162]
	tst.b	start_level_flag
	beq.b	0f
	* better cheat than MAME: REALLY selects champion course, not just red car
	lea	game_rom+0x23A2,a0
0:
	move.l	a0,track_events_data_pointer_E516                 	| [$0cad: ld   (track_events_data_pointer_E516),hl]
	rts                                    	| [$0cb0: ret]
l_0cb1:
	lea	game_rom+0x26DE,a0                      	| [$0cb1: ld   hl,$26DE] -  * C0B8A
	move.l	a0,demo_fake_inputs_pointer_E0F7                 	| [$0cb4: ld   (demo_fake_inputs_pointer_E0F7),hl]
	lea	unknown_E503,a0                	| [$0cb7: ld   hl,unknown_E503]
	move.w	#0x11,d1                        	| [$0cba: ld   bc,$0011] 17
	jra	l_0c9e                             	| [$0cbd: jr   $0C9E]
l_0cbf:
	jbsr	l_0d29                            	| [$0cbf: call $0D29] -  * C01CC,C0B3B,J0B93
l_0cc2:
	* displays status bar .. continued
	move.w	#0x8421,d7                      	| [$0cc2: ld   hl,$8421] -  * C0D90
	move.b	#0x06,d2                        	| [$0cc5: ld   c,$06]
	move.b	cur_point_e50e,d0                 	| [$0cc7: ld   a,(cur_point_e50e)] -  Current passed point
	cmp.b	#0x1A,d0                         	| [$0cca: cp   $1A] -  Is this the "champion" course
	jcs	l_0cd1                             	| [$0cce: jr   c,$0CD1] -  ... normal colors
	addq.b	#1,d0                           	| [$0cd0: inc  a] -  Yes ... flat champ colors
	bra.b	l_0cd1_2
l_0cd1:
	clr.b	d0                               	| [$0ccc: ld   a,$00] -  No ... use
l_0cd1_2:
	move.b	d0,champ_colors_e0f9                 	| [$0cd1: ld   (champ_colors_e0f9),a] -  Store champion colors flag * J0CCE
	movem.w	d1/d2,-(sp)                    	| [$0cd4: push bc]
	move.b	#0x01,d2                        	| [$0cd5: ld   c,$01]
	jbsr	trans_color_03e7                            	| [$0cd7: call $03E7]
	move.b	d2,d0                           	| [$0cda: ld   a,c]

	movem.w	(sp)+,d1/d2                    	| [$0cdb: pop  bc]
	* status bar background color (blue rectangle on top)
l_0cdc:
	move.b	#0x1E,d1                        	| [$0cdc: ld   b,$1E] -  * J0CE5
l_0cde:
	* writes 0 or 1
	jbsr	osd_w_colorram                         	| [$0cde: ld   (hl),a] -  * J0CE0
	addq.w	#1,d7                           	| [$0cdf: inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_0cde                             	| [$0ce0: djnz $0CDE]
	* next line
	addq.w	#2,d7                           	| [$0ce2: inc  hl] * 2
	subq.b	#1,d2                           	| [$0ce4: dec  c]
	jne	l_0cdc                             	| [$0ce5: jr   nz,$0CDC]
	
	* now fill the rectangle with shit
	lea	game_rom+0x2B0F,a0                      	| [$0ce7: ld   hl,$2B0F] -  Status box script
* displays "TIME", "POINT", "caution",
* williams logo, 1P, milestone letters...
	jbsr	write_to_screen_possible_typing_effect_300                            	| [$0cea: call $0300]

	jbsr	display_score_0668                            	| [$0ced: call $0668]
	jbsr	print_high_0685                            	| [$0cf0: call $0685]
	move.b	game_status_bits_E046,d0                 	| [$0cf3: ld   a,(game_status_bits_E046)]
	btst.b	#4,d0                           	| [$0cf6: bit  4,a]
	jeq	l_0d09                             	| [$0cf8: jr   z,$0D09] only one player
	* 2 players: display player 2 score
	jbsr	swap_players_0603                            	| [$0cfa: call $0603]
	jbsr	display_score_0668                            	| [$0cfd: call $0668]
	jbsr	swap_players_0603                            	| [$0d00: call $0603]
	lea	game_rom+0x2B72,a0                      	| [$0d03: ld   hl,$2B72] -  "P2 " status box script
	jbsr	write_to_screen_possible_typing_effect_300                            	| [$0d06: call $0300]
l_0d09:
	jbsr	display_nb_lives_06d5                            	| [$0d09: call $06D5] -  * J0CF8
	jbsr	display_time_212c                            	| [$0d0c: call $212C]
	jbsr	display_position_in_map_298a                            	| [$0d0f: call $298A]
l_0d12:
	* display "point " letter
	move.b	cur_point_e50e,d0                 	| [$0d12: ld   a,(cur_point_e50e)] -  * C0B85,J152B,C2866
	move.b	#0x02,d2                        	| [$0d15: ld   c,$02]
	cmp.b	#0x1A,d0                         	| [$0d17: cp   $1A]
	jcs	l_0d1f                             	| [$0d19: jr   c,$0D1F]
	sub.b	#0x1A,d0                         	| [$0d1b: sub  $1A]
	move.b	#0x07,d2                        	| [$0d1d: ld   c,$07]
l_0d1f:
	add.b	#0x40,d0                         	| [$0d1f: add  a,$40] -  * J0D19
	
	move.w	#0x8052,d7                       	| [$0d21: ld   ($8052),a] -  Put "point letter" ... * C0271
    jbsr	osd_w_videoram
	move.b	d2,d0                           	| [$0d24: ld   a,c] -  ... in top center ...
	move.w	#0x8452,d7                       	| [$0d25: ld   ($8452),a] -  ... status area
    jbsr	osd_w_colorram
	
	rts                                    	| [$0d28: ret] -  Done

l_0d29:
	* clear screen
	move.w	#0x8000,d7                      	| [$0d29: ld   hl,$8000] -  * C0013,C010A,C0187,C0745,C0CBF
	move.w	#0x0400,d1                        	| [$0d2c: ld   bc,$0800] 2048
	jbsr	clear_video_area
	move.w	#0x0400,d1
	jbsr	clear_color_area
	
	                   	| [$0d2f: call clear_area_05fa] clear screen
	lea	sprite_shadow_E100,a0          	| [$0d32: ld   hl,sprite_shadow_E100]
	move.w	#0xc6,d1                        	| [$0d35: ld   bc,$00C6] 198
	jbsr	clear_area_05fa                   	| [$0d38: call clear_area_05fa] clear part of RAM

l_0d3b:
	move.b	cocktail_mode_E043,d0                 	| [$0d3b: ld   a,(cocktail_mode_E043)] -  Cabinet mode * J0DA3
	subq.b	#1,d0                           	| [$0d3e: dec  a]
	jeq	l_0d4a                             	| [$0d3f: jr   z,$0D4A]
	lea	game_status_bits_E046,a0                	| [$0d41: ld   hl,game_status_bits_E046]
	clr.b	d0                               	| [$0d44: xor  a]
	btst.b	#3,(a0)                         	| [$0d45: bit  3,(hl)]
	jeq	l_0d4a                             	| [$0d47: jr   z,$0D4A]
	addq.b	#1,d0                           	| [$0d49: inc  a]
l_0d4a:
	move.b	d0,flip_value_e04c                 	| [$0d4a: ld   (flip_value_e04c),a] -  * J0D3F,J0D47
	move.w	d0,-(sp)
	jbsr	osd_read_dsw_2                      	| [$0d4d: ld   hl,$D004]
	move.b	d0,d7
	move.w	(sp)+,d0
	eor.b	d7,d0                            	| [$0d50: xor  (hl)]
	lea	jeep_base_y_e03c,a0            	| [$0d51: ld   hl,jeep_base_y_e03c]
	move.b	#0xEF,(a0)                      	| [$0d54: ld   (hl),$EF]
	st.b	d3                                	| [$0d56: ld   d,$FF]
	ror.b	#1,d0                           	| [$0d58: rra]
	jcc	l_0d5e                             	| [$0d59: jr   nc,$0D5E]
	addq.b	#1,d3                           	| [$0d5b: inc  d]
	move.b	#0xF1,(a0)                      	| [$0d5c: ld   (hl),$F1]
l_0d5e:
	addq.w	#1,a0                           	| [$0d5e: inc  hl] -  * J0D59
	move.b	d3,(a0)                         	| [$0d5f: ld   (hl),d]
	move.b	#0x40,d1                        	| [$0d60: ld   bc,$4000] 16384 -  B=40, C=0
	move.b	#0x00,d2                        	| [$0d60: ld   bc,$4000] 16384 -  B=40, C=0
	clr.b	d0                               	| [$0d63: xor  a] -  A is now 0
l_0d64:
* set scroll value??? sound??
**out  (c),a
	addq.b	#1,d2                           	| [$0d66: inc  c] -  ... to ports ...
	subq.b	#1,d1                           	| [...]
	jne	l_0d64                             	| [$0d67: djnz $0D64] -  ... 00 through 3F
    jbsr  osd_disable_interrupts  | [di]
	jbsr	queue_sound_effect_0d7d                            	| [$0d6a: call $0D7D] -  Queue up a stop-sound command
    jbsr  osd_enable_interrupts  | [ei]
	rts                                    	| [$0d6e: ret]

queue_sound_effect_0d6f:
    jbsr  osd_disable_interrupts  | [di]
	jbsr	queue_sound_effect_if_game_playing_0d75                            	| [$0d70: call $0D75]
    jbsr  osd_enable_interrupts  | [ei]
	rts                                    	| [$0d74: ret]

queue_sound_effect_if_game_playing_0d75:
	                        	| [$0d75: push hl] -  Save HL * C014D,C0D70,C132C,C1375,J13E8,C1522,C1571,J174B,C1768,C1D1D,C1DCC,C27D7,C2854,C2860
	                	| [$0d76: ld   hl,game_status_bits_E046]
	tst.b	game_status_bits_E046                         	| [$0d79: bit  7,(hl)]
	                        	| [$0d7b: pop  hl]
	bmi.b	0f                               	| [...]
	rts                                    	| [$0d7c: ret  p] [...]
0:
* stores d0 in E000-E007
queue_sound_effect_0d7d:
	move.l	a0,-(sp)                        	| [$0d7d: push hl] -  * C0456,C0D6A
	lea		sfx_index_table,a0
	and.w	#0xFF,d0
	move.b	(a0,d0.w),d0
	cmp.b	#JEEP_EXPLOSION_SND,d0
	bne.b	0f
	jbsr	osd_sound_stop			| stop music before some sounds
0:
	jbsr	osd_sound_start
	move.l	(sp)+,a0                        	| [$0d8b: pop  hl] -  Restore HL
	rts                                    	| [$0d8c: ret] -  Done

sfx_index_table:
	dc.b	-1				   | 0
	dc.b	EXPLOSION_SND	   | 1
	dc.b	-1                 | 2 does something but what?
	dc.b	BOMB_EXPLOSION_SND | 3
	dc.b	-1                 | 4
	dc.b	-1                 | 5
	dc.b	-1                 | 6
	dc.b	-1                 | 7
	dc.b	-1                 | 8
	dc.b	-1                 | 9
	dc.b	-1                 | 10
	dc.b	-1                 | 11
	dc.b	-1                 | 12
	dc.b	-1                 | 13
	dc.b	-1                 | 14
	dc.b	-1                 | 15
	dc.b	PING_SND           | 16
	dc.b	UFO_EXPLOSION_SND  | 17
	dc.b	SHOOT_SND          | 18
	dc.b	COIN_SND           | 19
	dc.b	JEEP_JUMP_SND      | 20
	dc.b	STOP_LOOP_SND      | 21
	dc.b	SPACE_PLANT_SND    | 22
	dc.b	UFO_ATTACK_SND     | 23
	dc.b	MAIN_TUNE_SND      | 24
	dc.b	-1                 | 25
	dc.b	-1                 | 26
	dc.b	GAME_OVER_SND      | 27
	dc.b	COURSE_START_SND   | 28
	dc.b	SECTION_END_SND    | 29
	dc.b	COURSE_END_SND     | 30
	dc.b	JEEP_EXPLOSION_SND | 31

	
	
	
*	move.l	a0,-(sp)                        	| [$0d7d: push hl] -  * C0456,C0D6A
*	moveq	#0,d7
*	move.b	offset_to_E000_E1DE,d7             	| [$0d7e: ld   hl,(offset_to_E000_E1DE)] -  Get the back (next to store) of the sound queue
*	lea		revolving_buffer_8_E000,a0                        	| [$0d81: ld   h,$E0] -  Sound queue is at $E000..$E007
*	move.b	d0,(a0,d7.w)                         	| [$0d83: ld   (hl),a] -  Store next sound effect to play
*	move.b	d7,d0                           	| [$0d84: ld   a,l] -  Bump the ...
*	addq.b	#1,d0                           	| [$0d85: inc  a] -  ... back
*	and.b	#0x07,d0                         	| [$0d86: and  $07] -  And wrap it (only 8 bytes in queue)
*	move.b	d0,offset_to_E000_E1DE                 	| [$0d88: ld   (offset_to_E000_E1DE),a] -  Store the new back
*	move.l	(sp)+,a0                        	| [$0d8b: pop  hl] -  Restore HL
*	rts                                    	| [$0d8c: ret] -  Done

draw_ground_0d8d:
	jbsr	l_2948                            	| [$0d8d: call $2948] -  * C0C05
	jbsr	l_0cc2                            	| [$0d90: call $0CC2]
	move.b	#0x20,d1                        	| [$0d93: ld   b,$20]
l_0d95:
	movem.w	d1/d2,-(sp)                    	| [$0d95: push bc] -  * J0DA1
	jbsr	draw_ground_block_1106                            	| [$0d96: call $1106]
	lea	scroll_logical_delta_x_E1E2,a0                	| [$0d99: ld   hl,unknown_E1E2]
	move.b	(a0),d0                         	| [$0d9c: ld   a,(hl)]
	add.b	#0x08,d0                         	| [$0d9d: add  a,$08]
	move.b	d0,(a0)                         	| [$0d9f: ld   (hl),a]

	movem.w	(sp)+,d1/d2                    	| [$0da0: pop  bc]
	subq.b	#1,d1                           	| [...]
	jne	l_0d95                             	| [$0da1: djnz $0D95]
	jra	l_0d3b                             	| [$0da3: jp   $0D3B]
	
	
ufo_bomb_creates_hole_0da6:
	* below contains impact screen address
	move.b	(0x02,a2),d4                    	| [$0da6: ld   e,(ix+$02)] -  Get ...
	move.b	(0x03,a2),d3                    	| [$0da9: ld   d,(ix+$03)] -  ... text script
	LOAD_D3_16_FROM_D3D4
	* this is a screen address
	
	lea		game_rom+0x304A,a4					| [$0dac: ld   bc,$304A] 12362
	and.w	#0xFF00,d0                            	| [$0daf: add  a,c]
	add.w	d0,a4									| [$0db0: ld   c,a]
	move.b	(a4),d0                         	| [$0db1: ld   a,(bc)]
	* magic shit to change pointer lsb... I hate that	| [$0db2: ld   c,a]
	lea		game_rom+0x3000,a4		| emulate pointer msb
	add.w	d0,a4					| add offset read from rom
	exg	d3,d7                              	| [$0db3: ex   de,hl]
	move.w	#0x0020,d3                      	| [$0db4: ld   de,$0020] 32
l_0db7:
	jbsr	osd_r_videoram                   	| [$0db7: ld   a,(hl)] -  * J0DBC
	                               	| [$0db8: and  a]
	jne	l_0dbe                             	| [$0db9: jr   nz,$0DBE]
	* next row
	add.w	d3,d7                            	| [$0dbb: add  hl,de]
	jra	l_0db7                             	| [$0dbc: jr   $0DB7]
l_0dbe:
	STORE_LEW	d7,continue_timer_E054                 	| [$0dbe: ld   (continue_timer_E054),hl] -  * J0DB9,J0DD4,J0DDA
l_0dc1:
	move.b	(a4)+,d0                         	| [$0dc1: ld   a,(bc)] -  * J0DCB
												| [$0dc2: inc   bc]
	subq.b	#1,d0                           	| [$0dc3: dec  a]
	bne.b	0f                               	| [...]
	rts                                    	| [$0dc4: ret  z] [...]
0:
	jpl	l_0dcd                             	| [$0dc5: jp   p,$0DCD]
	addq.b	#1,d0                           	| [$0dc8: inc  a]
	jbsr	osd_w_videoram                         	| [$0dc9: ld   (hl),a]
	add.w	d3,d7                            	| [$0dca: add  hl,de]
	jra	l_0dc1                             	| [$0dcb: jr   $0DC1]
l_0dcd:
	move.b	continue_timer_E054,d0                 	| [$0dcd: ld   a,(continue_timer_E054)] -  * J0DC5
	addq.b	#1,d0                           	| [$0dd0: inc  a]
	move.b	d0,d7                           	| [$0dd1: ld   l,a]
	and.b	#0x1F,d0                         	| [$0dd2: and  $1F]
	jne	l_0dbe                             	| [$0dd4: jr   nz,$0DBE]
	* up a row
	                           	| [$0dd6: ld   a,l]
	sub.b	#0x20,d7                         	| [$0dd7: sub  $20]
	                           	| [$0dd9: ld   l,a]
	jra	l_0dbe                             	| [$0dda: jr   $0DBE]
	
* not sure of what it does, but comment that out and the landscape
* is never updated: it scrolls in loop without advancing
handle_path_advance_0ddc:
	jbsr	l_125b                            	| [$0ddc: call $125B] -  * C026E,C0280
	move.b	scroll_logical_delta_x_E1E2,d0                 	| [$0ddf: ld   a,(unknown_E1E2)]
	lea	unknown_E509,a0                	| [$0de2: ld   hl,unknown_E509]
	move.b	d0,d1                           	| [$0de5: ld   b,a]
	move.b	(a0),d7
	eor.b	d7,d0                            	| [$0de6: xor  (hl)]
	and.b	#0xF8,d0                         	| [$0de7: and  $F8]
	bne.b	0f                               	| [...]
	rts                                    	| [$0de9: ret  z] [...]
0:
	move.b	d1,d0                           	| [$0dea: ld   a,b]
	and.b	#0xF8,d0                         	| [$0deb: and  $F8]
	move.b	d0,(a0)                         	| [$0ded: ld   (hl),a]
	jbsr	draw_ground_block_1106                            	| [$0dee: call $1106]
	move.b	title_display_timer_E04D,d0                 	| [$0df1: ld   a,(title_display_timer_E04D)]
	                               	| [$0df4: and  a]
	beq.b	0f                               	| [...]
	rts                                    	| [$0df5: ret  nz] [...]
0:
	* not in title sequence: increment track position
	lea	fine_position_on_track_E50B,a0                	| [$0df6: ld   hl,fine_position_on_track_E50B]
	addq.b	#1,(a0)                         	| [$0df9: inc  (hl)]
	move.b	(a0),d0                         	| [$0dfa: ld   a,(hl)]
	move.b	d0,d4                           	| [$0dfb: ld   e,a]
	                               	| [$0dfc: and  a]
	jeq	l_0e06                             	| [$0dfd: jr   z,$0E06]
	and.b	#0x1F,d0                         	| [$0dff: and  $1F]
	jne	l_0e06                             	| [$0e01: jr   nz,$0E06]
	jbsr	l_29d6                            	| [$0e03: call $29D6]
l_0e06:
	move.b	d4,d0                           	| [$0e06: ld   a,e] -  * J0DFD,J0E01
	move.l	track_events_data_pointer_E516,a0             	| [$0e07: ld   hl,(track_events_data_pointer_E516)]
	cmp.b	(a0),d0                          	| [$0e0a: cp   (hl)]
	jne	l_0e18                             	| [$0e0b: jr   nz,$0E18]
	addq.w	#1,a0                           	| [$0e0d: inc  hl]
	move.b	(a0),d0                         	| [$0e0e: ld   a,(hl)]
	and.b	#0x7F,d0                         	| [$0e0f: and  $7F]
	move.b	d0,unknown_E1D7                 	| [$0e11: ld   (unknown_E1D7),a]
	addq.w	#1,a0                           	| [$0e14: inc  hl]
	move.l	a0,track_events_data_pointer_E516                 	| [$0e15: ld   (track_events_data_pointer_E516),hl]
l_0e18:
	lea	unknown_E1D7,a0                	| [$0e18: ld   hl,unknown_E1D7] -  * J0E0B
	move.b	(a0),d0                         	| [$0e1b: ld   a,(hl)]
	subq.b	#1,d0                           	| [$0e1c: dec  a]
	bpl.b	0f                               	| [...]
	rts                                    	| [$0e1d: ret  m] [...]
0:
	clr.b	(a0)                             	| [$0e1e: ld   (hl),$00]
	cmp.b	#0x18,d0                         	| [$0e20: cp   $18]
	jcc	ufos_on_approach_0f45                             	| [$0e22: jp   nc,$0F45]
	cmp.b	#0x17,d0                         	| [$0e25: cp   $17]
	jeq	enter_rear_missile_0e4f                             	| [$0e27: jr   z,$0E4F]
	subq.b	#0x06,d0                        	| [$0e29: sub  $06]
	jmi	change_slope_type_0e8a                             	| [$0e2b: jp   m,$0E8A]
	subq.b	#0x07,d0                        	| [$0e2e: sub  $07]
	jmi	draw_hole_on_right_0ef0                             	| [$0e30: jp   m,$0EF0]
	add.b	d0,d0                            	| [$0e33: add  a,a]
	add.b	d0,d0                            	| [$0e34: add  a,a]
	add.b	d0,d0                            	| [$0e35: add  a,a]
	clr.w	d3                               	| [$0e37: ld   d,$00]
	move.b	d0,d3                           	| [$0e36: ld   e,a]
	lea		game_rom+0x1000,a3                      	| [$0e39: ld   iy,$1000]
	add.w	d3,a3                            	| [$0e3d: add  iy,de]
	jbsr	l_0e93                            	| [$0e3f: call $0E93]
	move.b	(0x06,a3),d0                    	| [$0e42: ld   a,(iy+$06)]
	                               	| [$0e45: and  a]
	jeq	l_0e4b                             	| [$0e46: jr   z,$0E4B]
	jbsr	l_07fd                            	| [$0e48: call $07FD]
l_0e4b:
	move.b	d2,(a2)                    	| [$0e4b: ld   (ix+$00),c] -  * J0E46
	rts                                    	| [$0e4e: ret]

enter_rear_missile_0e4f:
	move.b	#0x19,d0                        	| [$0e4f: ld   a,$19] -  * J0E27
	move.b	d0,ufo_objects_e370                 	| [$0e51: ld   (ufo_objects_e370),a]
	rts                                    	| [$0e54: ret]

* called when rock is hit
l_0e55:
	move.b	#0x01,d0                        	| [$0e55: ld   a,$01] -  * J0E8B
	move.b	d0,unknown_E1DC                 	| [$0e57: ld   (unknown_E1DC),a]
	move.w	screen_address_E0E4,d7             	| [$0e5a: ld   hl,(screen_address_E0E4)]
	                           	| [$0e5d: ld   a,l]
	and.b	#0x1F,d7                         	| [$0e5e: and  $1F]
	or.w	#0xC0,d7                          	| [$0e60: or   $C0]
	                           	| [$0e62: ld   l,a]
	move.b	#0x0A,d0
	jbsr	osd_w_videoram                      	| [$0e63: ld   (hl),$0A]
	move.w	#0x20,d1											| [$0e65: ld   bc,$0020] 32
												| [$0e65: ld   bc,$0020] 32
	move.b	d7,d4                           	| [$0e68: ld   e,l]
	add.w	d1,d7                            	| [$0e69: add  hl,bc]
	
	move.b	#0x0B,d0
	jbsr	osd_w_videoram                      	| [$0e6a: ld   (hl),$0B]
	move.b	d4,d0                           	| [$0e6c: ld   a,e]
	subq.b	#1,d0                           	| [$0e6d: dec  a]
	and.b	#0x1F,d0                         	| [$0e6e: and  $1F]
	or.b	#0xC0,d0                          	| [$0e70: or   $C0]
	move.b	d0,d7                           	| [$0e72: ld   l,a]
	jbsr	current_point_modulus_26_2981                            	| [$0e73: call $2981]
	add.b	#0x41,d0                         	| [$0e76: add  a,$41]
	* write current point letter into scroll strip (at $83DE)
	jbsr	osd_w_videoram                         	| [$0e78: ld   (hl),a]
	
	move.w	d7,screen_address_E1DA                 	| [$0e79: ld   (screen_address_E1DA),hl]
	add.w	d1,d7                            	| [$0e7c: add  hl,bc]
	move.b	#0xF2,d0
	jbsr	osd_w_videoram                      	| [$0e7d: ld   (hl),$F2]
	                        	| [$0e7f: ld   bc,$03E0] 992
	                        	| [$0e7f: ld   bc,$03E0] 992
	add.w	#0x03E0,d7                            	| [$0e82: add  hl,bc]
	move.b	champ_colors_e0f9,d0                 	| [$0e83: ld   a,(champ_colors_e0f9)]
	addq.b	#0x05,d0                        	| [$0e86: add  a,$05]
	jbsr	osd_w_colorram                         	| [$0e88: ld   (hl),a]
	rts                                    	| [$0e89: ret]

change_slope_type_0e8a:
	addq.b	#1,d0                           	| [$0e8a: inc  a] -  * J0E2B
	jeq	l_0e55                             	| [$0e8b: jr   z,$0E55]
	* make up for negative value by adding 5
	addq.b	#0x05,d0                        	| [$0e8d: add  a,$05]
	move.b	d0,terrain_slope_type_E508                 	| [$0e8f: ld   (terrain_slope_type_E508),a]
	rts                                    	| [$0e92: ret]

l_0e93:
	move.b	(a3),d0                    	| [$0e93: ld   a,(iy+$00)] -  * C0E3F
	cmp.b	#0x02,d0                         	| [$0e96: cp   $02]
	jeq	l_0eb5                             	| [$0e98: jr   z,$0EB5]
	cmp.b	#0x07,d0                         	| [$0e9a: cp   $07]
	jcs	l_0eba                             	| [$0e9c: jr   c,$0EBA]
l_0e9e:
	clr.w	d3                               	| [$0e9e: ld   d,$00] -  * C0F2D
	move.b	(0x05,a3),d3                    	| [$0ea0: ld   e,(iy+$05)]
	lea	ufo_objects_e370,a2                	| [$0ea3: ld   ix,ufo_objects_e370]
l_0ea7:
	move.b	(0x04,a3),d1                    	| [$0ea7: ld   b,(iy+$04)] -  * J0EC1
l_0eaa:
	move.b	(a2),d0                    	| [$0eaa: ld   a,(ix+$00)] -  * J0EB2
	                               	| [$0ead: and  a]
	jeq	l_0ec3                             	| [$0eae: jr   z,$0EC3]
	add.w	d3,a2                            	| [$0eb0: add  ix,de]
	subq.b	#1,d1                           	| [...]
	jne	l_0eaa                             	| [$0eb2: djnz $0EAA]
	rts                                    	| [$0eb4: ret]

l_0eb5:
	lea	unknown_E1D7,a0                	| [$0eb5: ld   hl,unknown_E1D7] -  * J0E98
	move.b	#0x11,(a0)                      	| [$0eb8: ld   (hl),$11]
l_0eba:
	move.w	#-0x10,d3                       	| [$0eba: ld   de,-$10] -  * J0E9C,C0EF9
	lea	unknown_E4F0,a2                	| [$0ebd: ld   ix,unknown_E4F0]
	jra	l_0ea7                             	| [$0ec1: jr   $0EA7]
l_0ec3:
	move.b	(a3),d0                    	| [$0ec3: ld   a,(iy+$00)] -  * J0EAE
	move.b	d0,(0x0c,a2)                    	| [$0ec6: ld   (ix+$0c),a]
	move.b	(0x01,a3),d0                    	| [$0ec9: ld   a,(iy+$01)]
	move.b	d0,(obj_type,a2)                    	| [$0ecc: ld   (ix+$0d),a]
	move.b	unknown_E509,d0                 	| [$0ecf: ld   a,(unknown_E509)]
	subq.b	#0x02,d0                        	| [$0ed2: sub  $02]
	move.b	d0,(obj_timeout,a2)                    	| [$0ed4: ld   (ix+$0f),a]
	jbsr	l_153d                            	| [$0ed7: call $153D]
	add.b	(obj_x,a3),d0                     	| [$0eda: add  a,(iy+$03)]
	move.b	d0,(obj_y,a2)                    	| [$0edd: ld   (ix+$07),a]
	clr.b	(0x0b,a2)                        	| [$0ee0: ld   (ix+$0b),$00]
	clr.b	(0x03,a2)                        	| [$0ee4: ld   (ix+$03),$00]
	clr.b	(0x0e,a2)                        	| [$0ee8: ld   (ix+$0e),$00]
	move.b	(0x02,a3),d2                    	| [$0eec: ld   c,(iy+$02)]
	rts                                    	| [$0eef: ret]

* responsible for drawing the holes that scroll to the player
* (the holes caused by blue ship bombs are done somewhere else)
draw_hole_on_right_0ef0:
	addq.b	#1,d0                           	| [$0ef0: inc  a] -  * J0E30
	jeq	l_0f40                             	| [$0ef1: jp   z,$0F40]
	move.w	d0,-(sp)                        	| [$0ef4: push af]
	lea	game_rom+0x104E,a3                      	| [$0ef5: ld   iy,$104E]
	jbsr	l_0eba                            	| [$0ef9: call $0EBA]
	move.w	(sp)+,d0                        	| [$0efc: pop  af]
	add.b	#0x86,d0                         	| [$0efd: add  a,$86]
	move.b	d0,(0x0d,a2)                    	| [$0eff: ld   (ix+$0d),a]
	move.b	d2,(a2)                    	| [$0f02: ld   (ix+$00),c]
	lea	game_rom+0x304A,a0                      	| [$0f05: ld   hl,$304A]
	and.w	#0xFF,d0                            	| [$0f08: add  a,l]
	add.b	#0x80,d0                         	| [$0f09: add  a,$80]
	add.w	d0,a0                           	| [$0f0b: ld   l,a]
	moveq	#0,d7
	move.b	(a0),d7                         	| [$0f0c: ld   l,(hl)]
	* jotd: I have to emulate HL address lower nibble
	lea	game_rom+0x3000,a0
	add.w	d7,a0
l_0f0d:
	* in game!
	move.w	screen_address_E0E4,d7             	| [$0f0d: ld   iy,(screen_address_E0E4)] -  * J0F43
	move.w	#0x0020,d3                      	| [$0f11: ld   de,$0020] 32
l_0f14:
	* read data from ROM
	move.b	(a0)+,d0                         	| [$0f14: ld   a,(hl)] -  * J0F20
	                           	| [$0f15: inc  hl]
	subq.b	#1,d0                           	| [$0f16: dec  a]
	jpl	l_0f22                             	| [$0f17: jp   p,$0F22]
	addq.b	#1,d0                           	| [$0f1a: inc  a]
	jbsr	osd_w_videoram                    	| [$0f1b: ld   (iy+$00),a]
	add.w	d3,d7                            	| [$0f1e: add  iy,de]
	jra	l_0f14                             	| [$0f20: jr   $0F14]
l_0f22:
	bne.b	0f                               	| [...]
	rts                                    	| [$0f22: ret  z] [...] -  * J0F17
0:
	move.l	a0,unknown_pointer_E0E6                 	| [$0f23: ld   (unknown_pointer_E0E6),hl]
	subq.b	#1,d0                           	| [$0f26: dec  a]
	jeq	l_0f3a                             	| [$0f27: jr   z,$0F3A]
	lea	game_rom+0x1055,a3                      	| [$0f29: ld   iy,$1055]
	jbsr	l_0e9e                            	| [$0f2d: call $0E9E]
	clr.b	(obj_next_frame_timeout,a2)                        	| [$0f30: ld   (ix+$0a),$00]
	addq.b	#1,(0x0e,a2)                    	| [$0f34: inc  (ix+$0e)]
	move.b	d2,(a2)                    	| [$0f37: ld   (ix+$00),c]
l_0f3a:
	move.b	#0x0D,d0                        	| [$0f3a: ld   a,$0D] -  * J0F27
	move.b	d0,unknown_E1D7                 	| [$0f3c: ld   (unknown_E1D7),a]
	rts                                    	| [$0f3f: ret]

l_0f40:
	move.l	unknown_pointer_E0E6,a0             	| [$0f40: ld   hl,(unknown_pointer_E0E6)] -  * J0EF1
	jra	l_0f0d                             	| [$0f43: jr   $0F0D]
ufos_on_approach_0f45:
	sub.b	#0x1F,d0                         	| [$0f45: sub  $1F] -  * J0E22
	jmi	shoot_hole_making_bomb_0fb7                             	| [$0f47: jp   m,$0FB7]
	lea	background_layer_control_E1C5,a0                	| [$0f4a: ld   hl,background_layer_control_E1C5]
	st.b	d2                                	| [$0f4d: ld   c,$FF]
l_0f4f:
	addq.w	#1,a0                           	| [$0f4f: inc  hl] -  * J0F53
	addq.b	#1,d2                           	| [$0f50: inc  c]
	sub.b	#0x08,d0                         	| [$0f51: sub  $08]
	jpl	l_0f4f                             	| [$0f53: jp   p,$0F4F]
	add.b	#0x08,d0                         	| [$0f56: add  a,$08]
	jeq	l_0f6a                             	| [$0f58: jr   z,$0F6A]
	move.b	d0,(a0)                         	| [$0f5a: ld   (hl),a]
	addq.w	#3,a0                           	| [$0f5b: inc  hl] * 3
	move.b	d0,(a0)                         	| [$0f5e: ld   (hl),a]
	addq.w	#3,a0                           	| [$0f5f: inc  hl] * 3
	move.b	d0,(a0)                         	| [$0f62: ld   (hl),a]
	subq.b	#1,d2                           	| [$0f63: dec  c]
	bpl.b	0f                               	| [...]
	rts                                    	| [$0f64: ret  m] [...]
0:
	lea	unknown_E1D6,a0                	| [$0f65: ld   hl,unknown_E1D6]
	addq.b	#1,(a0)                         	| [$0f68: inc  (hl)]
	rts                                    	| [$0f69: ret]
l_0f6a:
	move.b	d0,(a0)                         	| [$0f6a: ld   (hl),a] -  * J0F58
	lea	ufo_objects_e370,a3                	| [$0f6b: ld   iy,ufo_objects_e370]
	move.w	#0x0010,d3                      	| [$0f6f: ld   de,$0010] 16
	move.b	#0x19,d1                        	| [$0f72: ld   b,$19]
	subq.b	#1,d2                           	| [$0f74: dec  c]
	jmi	l_0fa5                             	| [$0f75: jp   m,$0FA5]
l_0f78:
	move.b	(a3),d0                    	| [$0f78: ld   a,(iy+$00)] -  * J0F9C
	sub.b	#0x22,d0                         	| [$0f7b: sub  $22]
	cmp.b	#0x06,d0                         	| [$0f7d: cp   $06]
	jcc	l_0f9a                             	| [$0f7f: jr   nc,$0F9A]
	move.b	d0,d6                           	| [$0f81: ld   l,a]
	btst.b	#1,d6                           	| [$0f82: bit  1,l]
	jne	l_0f9a                             	| [$0f84: jr   nz,$0F9A]
	move.b	d2,d5                           	| [$0f86: ld   h,c]
	move.b	(obj_type,a3),d0                    	| [$0f87: ld   a,(iy+$0d)]
	cmp.b	#0x2A,d0                         	| [$0f8a: cp   $2A]
	jne	l_0f8f                             	| [$0f8c: jr   nz,$0F8F]
	addq.b	#1,d5                           	| [$0f8e: inc  h]
l_0f8f:
	subq.b	#1,d5                           	| [$0f8f: dec  h] -  * J0F8C
	jne	l_0f9a                             	| [$0f90: jr   nz,$0F9A]
	btst.b	#2,d6                           	| [$0f92: bit  2,l]
	jne	l_0f9f                             	| [$0f94: jr   nz,$0F9F]
	move.b	#0x24,(a3)                 	| [$0f96: ld   (iy+$00),$24]
l_0f9a:
	add.w	d3,a3                            	| [$0f9a: add  iy,de] -  * J0F7F,J0F84,J0F90,J0FA3
	subq.b	#1,d1                           	| [...]
	jne	l_0f78                             	| [$0f9c: djnz $0F78]
	rts                                    	| [$0f9e: ret]
l_0f9f:
	move.b	#0x01,(0x0f,a3)                 	| [$0f9f: ld   (iy+$0f),$01] -  * J0F94
	jra	l_0f9a                             	| [$0fa3: jr   $0F9A]
l_0fa5:
	move.b	(a3),d0                    	| [$0fa5: ld   a,(iy+$00)] -  * J0F75,J0FB4
	sub.b	#0x1E,d0                         	| [$0fa8: sub  $1E]
	cmp.b	#0x02,d0                         	| [$0faa: cp   $02]
	jcc	l_0fb2                             	| [$0fac: jr   nc,$0FB2]
	move.b	#0x24,(a3)                 	| [$0fae: ld   (iy+$00),$24]
l_0fb2:
	add.w	d3,a3                            	| [$0fb2: add  iy,de] -  * J0FAC
	subq.b	#1,d1                           	| [...]
	jne	l_0fa5                             	| [$0fb4: djnz $0FA5]
	rts                                    	| [$0fb6: ret]
	
shoot_hole_making_bomb_0fb7:
	add.b	#0x08,d0                         	| [$0fb7: add  a,$08] -  * J0F47
	cmp.b	#0x04,d0                         	| [$0fb9: cp   $04]
	jcc	l_0fc5                             	| [$0fbb: jr   nc,$0FC5]
	lea	fine_position_on_track_E50B,a0                	| [$0fbd: ld   hl,fine_position_on_track_E50B]
	move.b	(a0)+,d1                         	| [$0fc0: ld   b,(hl)]
												| [$0fc1: inc  hl]
	move.b	d1,(a0)+                         	| [$0fc2: ld   (hl),b]
												| [$0fc3: inc  hl]
	move.b	d0,(a0)                         	| [$0fc4: ld   (hl),a]
l_0fc5:
	move.b	unknown_E1D5,d0                 	| [$0fc5: ld   a,(unknown_E1D5)] -  * J0FBB
	                               	| [$0fc8: and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [$0fc9: ret  z] [...]
0:
	clr.w	d3                               	| [$0fcb: ld   d,$00]
	move.b	d0,d3                           	| [$0fca: ld   e,a]
	lea	unknown_E3FF,a3                	| [$0fcd: ld   iy,unknown_E3FF]
	add.w	d3,a3                            	| [$0fd1: add  iy,de]
	lea	ufo_objects_e370,a0                	| [$0fd3: ld   hl,ufo_objects_e370]
	move.b	#0x10,d3                        	| [$0fd6: ld   e,$10]
	move.b	#MAX_NB_UFOS_1,d1                        	| [$0fd8: ld   bc,$053A] 1338
	move.b	#0x3a,d2                        	| [$0fd8: ld   bc,$053A] 1338
	* look for free slot?
l_0fdb:
	move.b	(a0),d0                         	| [$0fdb: ld   a,(hl)] -  * J0FE1
	                               	| [$0fdc: and  a]
	jeq	l_105d                             	| [$0fdd: jp   z,$105D]
	add.w	d3,a0					| [$0FE0:  add  hl,de]
	subq.b	#1,d1					| [...]
	bne.b	l_0fdb					| [$0FE1: djnz $0FDB]
	rts								| [$0FE3: ret]
	
l_105d:
	                              	| [$105d: ex   de,hl] -  * J0FDD
	                      	| [$105e: ld   ix,$0000] 0
	move.l	a0,a2
	                            	| [$1062: add  ix,de]
									
* < A2: shot structure
* < A3: shooting ufo structure
initialize_ufo_shot_1064:
	move.b	d2,(obj_type,a2)                    	| [$1064: ld   (ix+$0d),c] -  * J1BBD
	clr.b	(obj_y_speed,a2)                        	| [$1067: ld   (ix+$09),$00]
	clr.b	(0x08,a2)                        	| [$106b: ld   (ix+$08),$00]
	move.b	(obj_y,a3),d3                    	| [$106f: ld   d,(iy+$07)]
	move.b	d3,(obj_y,a2)                    	| [$1072: ld   (ix+$07),d]
	move.b	(a3),d0                    	| [$1075: ld   a,(iy+$00)]
	sub.b	#0x1E,d0                         	| [$1078: sub  $1E]
	cmp.b	#0x0A,d0                         	| [$107a: cp   $0A]
	bcs.b	0f                               	| [...]
	rts                                    	| [$107c: ret  nc] [...]
0:
	btst.b	#1,d0                           	| [$107d: bit  1,a]
	beq.b	0f                               	| [...]
	rts                                    	| [$107f: ret  nz] [...]
0:
	move.b	(obj_x,a3),d0                    	| [$1080: ld   a,(iy+$03)]
	sub.b	#0x10,d0                         	| [$1083: sub  $10]
	cmp.b	#0xE0,d0                         	| [$1085: cp   $E0]
	bcs.b	0f                               	| [...]
	rts                                    	| [$1087: ret  nc] [...]
0:
	move.b	d2,d0                           	| [$1088: ld   a,c]
	cmp.b	#0x3A,d0                         	| [$1089: cp   $3A]
	jeq	l_10c3                             	| [$108b: jr   z,$10C3]
	jbsr	l_2092                            	| [$108d: call $2092]
	jbsr	osd_get_random                           	| [$1090: ld   a,r]
	and.b	#0x7F,d0                         	| [$1092: and  $7F]
	move.b	d0,d1                           	| [$1094: ld   b,a]
	* aim point around the jeep
	move.b	jeep_x_E303,d0                 	| [$1095: ld   a,(buggy_x_e303)]
	add.b	d1,d0                            	| [$1098: add  a,b]
	sub.b	#0x2F,d0                         	| [$1099: sub  $2F]
	move.b	d0,d2                           	| [$109b: ld   c,a]
	sub.b	(obj_x,a2),d0                     	| [$109c: sub  (ix+$03)]
	add.b	#0x08,d0                         	| [$109f: add  a,$08]
	cmp.b	#0x11,d0                         	| [$10a1: cp   $11]
	jcc	l_10a9                             	| [$10a4: jr   nc,$10A9]
	move.b	d2,d0                           	| [$10a3: ld   a,c]
	eor.b	#0x10,d0                         	| [$10a6: xor  $10]
	move.b	d0,d2                           	| [$10a8: ld   c,a]
	bra.b	l_10a9_2
l_10a9:
	move.b	d2,d0                           	| [$10a3: ld   a,c]
l_10a9_2:
	cmp.b	(obj_x,a3),d0                     	| [$10a9: cp   (iy+$03)] -  * J10A4
	SET_X_FROM_C
	roxl.b	#1,d0                           	| [$10ac: rla]
	move.b	d0,(0x0c,a2)                    	| [$10ad: ld   (ix+$0c),a]
	move.b	d2,d0                           	| [$10b0: ld   a,c]
	jbsr	compute_ground_object_y_from_x_1538                            	| [$10b1: call $1538]
	sub.b	d3,d0                            	| [$10b4: sub  d]
	roxr.b	#3,d0                           	| [$10b5: rra] * 3
	and.b	#0x1F,d0                         	| [$10b8: and  $1F]
	addq.b	#0x02,d0                        	| [$10ba: add  a,$02]
	move.b	d2,d1                           	| [$10bc: ld   b,c]
	lsr.b	#1,d1                            	| [$10bd: srl  b]
	* change 2E to 2A for a good laugh!!! all bombs will create holes!!
	move.b	#0x2E,d2                        	| [$10bf: ld   c,$2E] shoot a ufo standard bomb command
	jra	l_10d2                             	| [$10c1: jr   $10D2]
l_10c3:
	move.b	#0x8f,d1                        	| [$10c3: ld   bc,$8F2A] 36650 -  * J108B
	move.b	#0x2a,d2                        	| [$10c3: ld   bc,$8F2A] 36650 -  * J108B shoot a ufo hole making bomb command
	lsr.b	#3,d3                            	| [$10c6: srl  d] * 3
	move.b	terrain_height_in_tiles_E514,d0                 	| [$10cc: ld   a,(terrain_height_in_tiles_E514)]
	eor.b	#0x1F,d0                         	| [$10cf: xor  $1F]
	sub.b	d3,d0                            	| [$10d1: sub  d]
l_10d2:
	and.w	#0xFF,d0
	lea	game_rom+0x3100,a0                      	| [$10d2: ld   hl,$3100] -  * J10C1
	add.w	d0,a0                            	| [$10d5: add  a,l]
												| [$10d6: ld   l,a]
	move.b	(a0),d3                         	| [$10d7: ld   d,(hl)]
	* set bomb X from ufo X
	move.b	(obj_x,a3),d0                    	| [$10d8: ld   a,(iy+$03)]
	move.b	d0,(obj_x,a2)                    	| [$10db: ld   (ix+$03),a]
	* from now on magic Z80 code to compute maybe direction of bomb???
	* by performing a division between a value in ROM and X
	lsr.b	#1,d0                            	| [$10de: srl  a]
	sub.b	d1,d0                            	| [$10e0: sub  b]
	jcc	l_10e5                             	| [$10e1: jr   nc,$10E5]
	neg.b	d0                               	| [$10e3: neg]
l_10e5:
	st.b	d4                                	| [$10e5: ld   e,$FF] -  * J10E1
l_10e7:
	addq.b	#1,d4                           	| [$10e7: inc  e] -  * J10E9
	sub.b	d3,d0                            	| [$10e8: sub  d]
	jcc	l_10e7                             	| [$10e9: jr   nc,$10E7]
	add.b	d3,d0                            	| [$10eb: add  a,d]
	move.b	d4,(0x05,a2)                    	| [$10ec: ld   (ix+$05),e]
	
	* the following loop divides D0*0x100 by D3 to compute slope
	* it seems to behave the same way between MAME & this version but probably
	* costs a lot more than a simple divide
	move.b	#0x08,d1                        	| [$10ef: ld   b,$08]
l_10f1:
	asl.b	#1,d0                            	| [$10f1: sla  a] -  * J10FB
	cmp.b	d3,d0                            	| [$10f3: cp   d]
	SET_X_FROM_C
	roxl.b	#1,d4                           	| [$10f4: rl   e]
 	btst.b	#0,d4                           	| [$10f6: bit  0,e]
	jne	l_10fb                             	| [$10f8: jr   nz,$10FB]
	sub.b	d3,d0                            	| [$10fa: sub  d]
l_10fb:
	subq.b	#1,d1                           	| [...]
	jne	l_10f1                             	| [$10fb: djnz $10F1] -  * J10F8
	move.b	d4,d0                           	| [$10fd: ld   a,e]
	not.b	d0                               	| [$10fe: cpl]
		
	* we could have replaced by simpler & faster operations! mul by 256 then divide
	* but the case where the code loops in 10e7 isn't clear, d4 could start at !=0.
	* Since code works the same
	* I'm leaving that here, but at least I know what this does
	*lsl.w	#8,d0
	*divu	d3,d0
	
	move.b	d0,(0x04,a2)                    	| [$10ff: ld   (ix+$04),a] slope?
	move.b	d2,(obj_command,a2)                    	| [$1102: ld   (ix+$00),c]
	rts                                    	| [$1105: ret]
	
draw_ground_block_1106:
	lea	unknown_E1D9,a0                	| [$1106: ld   hl,unknown_E1D9] -  * C0D96,C0DEE
	move.b	(a0),d0                         	| [$1109: ld   a,(hl)]
	                               	| [$110a: and  a]
	jne	l_119a                             	| [$110b: jp   nz,$119A]
	moveq	#0,d0
	move.b	terrain_slope_type_E508,d0                 	| [$110e: ld   a,(terrain_slope_type_E508)]
	cmp.b	#TERRAIN_RISING_03,d0                         	| [$1111: cp   $03]
	jcc	is_slope_118e                             	| [$1113: jr   nc,$118E]
	move.b	d0,d1                           	| [$1115: ld   b,a]
	subq.b	#1,d1                           	| [$1116: dec  b]
	lea	game_rom+0x2CB4,a0                      	| [$1117: ld   hl,$2CB4]
	*SET_XC_FLAGS								| C is set from not branching on jcs (no effect, as is masked)
	move.b	scroll_logical_delta_x_E1E2,d0                 	| [$111a: ld   a,(unknown_E1E2)]
	ror.b	#3,d0                           	| [$111d: rra] * 3
	and.b	#0x1F,d0                         	| [$1120: and  $1F] masks upper bits (carry goes away)
	* will be done below						| [$1122: add  a,l]
	subq.b	#1,d1                           	| [...]
	jne	l_1127                             	| [$1123: djnz $1127]
	* maybe can get past 0x100 offset??
	add.w	#0x20,d0                         	| [$1125: add  a,$20]
l_1127:											| [$1127: ld   l,a] -  * J1123
	move.b	(a0,d0.w),d2                         	| [$1128: ld   c,(hl)] get tile to write next in scrolling
write_ground_tile_1129:
	move.b	scroll_logical_delta_x_E1E2,d0                 	| [$1129: ld   a,(unknown_E1E2)] -  * J11CE,J11D5,J11E7
	ror.b	#3,d0                           	| [$112c: rra] * 3
	and.b	#0x1F,d0                         	| [$112f: and  $1F]
	                           	| [$1131: ld   e,a]
	* start address where to write new ground tiles to scroll
	* (on the right of the screen) taking account for the hardware scroll value
	move.l	#0x8300,d3                        	| [$1132: ld   d,$83]
	move.b	d0,d3
	lea	0x0400,a3                      	| [$1134: ld   iy,$0400]
	add.w	d3,a3                            	| [$1138: add  iy,de]
	exg	d3,d7                              	| [$113a: ex   de,hl]
	move.w	#0x0020,d3                      	| [$113b: ld   de,$0020] 32
	move.b	#0x07,d1                        	| [$113e: ld   b,$07]  max height in tiles
	* fill the terrain column
	move.b	terrain_height_in_tiles_E514,d0     | [$1140: ld   a,(terrain_height_in_tiles_E514)]
l_1143:
	cmp.b	d1,d0                            	| [$1143: cp   b] -  * J114B
	jeq	l_114d                             	| [$1144: jr   z,$114D] height reached, exit
	move.w	d0,-(a7)
	moveq	#0,d0                             	| [$1146: ld   (hl),$00]
	jbsr	osd_w_videoram
	move.w	(a7)+,d0
	add.w	d3,d7                            	| [$1148: add  hl,de]
	add.w	d3,a3                            	| [$1149: add  iy,de] next row of terrain tiles
	subq.b	#1,d1                           	| [...]
	jne	l_1143                             	| [$114b: djnz $1143]
l_114d:
	move.w	d7,screen_address_E0E4                 	| [$114d: ld   (screen_address_E0E4),hl] -  * J1144
	move.b	d2,d0
	jbsr	osd_w_videoram			| [$1150: ld   (hl),c]
	move.b	#4,d0       
	exg		d7,a3
	jbsr	osd_w_colorram                 	| [$1151: ld   (iy+$00),$04]                         	
	exg		d7,a3
l_1155:
	add.w	d3,d7                            	| [$1155: add  hl,de] -  * J115E
	add.w	d3,a3                            	| [$1156: add  iy,de]
	cmp.w	#0x8400,d7
	bcc.b	0f			| probably an overflow in the game too
	move.b	#0xF3,d0
	jbsr	osd_w_videoram                      	| [$1158: ld   (hl),$F3]
	move.b	#0x04,d0
	exg		d7,a3
	jbsr	osd_w_colorram                 	| [$115a: ld   (iy+$00),$04]
	exg		d7,a3
	subq.b	#1,d1                           	| [...]
	jne	l_1155                             	| [$115e: djnz $1155]
0:
	move.b	scroll_logical_delta_x_E1E2,d0                 	| [$1160: ld   a,(unknown_E1E2)]
	ror.b	#2,d0                           	| [$1163: rra] * 2
 	and.b	#0x3E,d0                         	| [$1165: and  $3E]
	                        	| [$1167: add  a,$00]
	moveq	#0,d7
	move.b	d0,d7                           	| [$1169: ld   l,a]
	lea 	ground_y_array_E200,a0                        	| [$116a: ld   h,$E2]
	add.w	d7,a0
	move.b	terrain_height_in_tiles_E514,d0                 	| [$116c: ld   a,(terrain_height_in_tiles_E514)]
	eor.b	#0x1F,d0                         	| [$116f: xor  $1F]
	move.b	d0,d3                           	| [$1171: ld   d,a]
	lea	game_rom+0x2C24,a3                      	| [$1172: ld   iy,$2C24]
	LOAD_D1_16_FROM_D1D2
	add.w	d1,a3                            	| [$1176: add  iy,bc]
	move.b	(a3),d0                    	| [$1178: ld   a,(iy+$00)]
	move.b	d0,d4                           	| [$117b: ld   e,a]
	and.b	#0x70,d0                         	| [$117c: and  $70]
	rol.b	#1,d0                            	| [$117e: rlca]
	or.b	d3,d0                             	| [$117f: or   d]
	rol.b	#3,d0                            	| [$1180: rlca] * 3
	move.b	d0,(a0)+                         	| [$1183: ld   (hl),a]
	and.b	#0xF8,d0                         	| [$1184: and  $F8]
	move.b	d0,d3                           	| [$1186: ld   d,a]
	move.b	d4,d0                           	| [$1187: ld   a,e]
	and.b	#0x07,d0                         	| [$1188: and  $07]
	or.b	d3,d0                             	| [$118a: or   d]
												| [$118b: inc  hl]
	move.b	d0,(a0)                         	| [$118c: ld   (hl),a]
	rts                                    	| [$118d: ret]
	
	
is_slope_118e:
	* initialize slope, d0 = slope type, ex 3
	add.b	d0,d0                            	| [$118e: add  a,a] -  * J1113
	add.b	#0x7A,d0                         	| [$118f: add  a,$7A]
	move.b	d0,(a0)                         	| [$1191: ld   (hl),a]
	add.b	d0,d0                            	| [$1192: add  a,a]
	jeq	l_1197                             	| [$1193: jr   z,$1197]
	move.b	#0x0A,d0                        	| [$1195: ld   a,$0A]
l_1197:
	move.b	d0,unknown_E1D8                 	| [$1197: ld   (unknown_E1D8),a] -  * J1193
l_119a:
	move.b	(a0),d2                         	| [$119a: ld   c,(hl)] -  * J110B
	roxr.b	#1,d2                           	| [$119b: rr   c]
	bcc.b	0f                               	| [...]
	rts                                    	| [$119d: ret  c] [...]
0:
	roxr.b	#1,d2                           	| [$119e: rr   c]
	scs		d7

 	lea	unknown_E1D8,a0                	| [$11a0: ld   hl,unknown_E1D8]
	subq.b	#1,(a0)                         	| [$11a3: dec  (hl)]
	jpl	l_11b6                             	| [$11a4: jp   p,$11B6]
	* here we don't test C result of subq (dec doesn't change C but sub does change X!)
	* but previous roxr result
	tst.b	d7
	jne	l_11ea                             	| [$11ac: jr   c,$11EA]
	move.b	#0x0B,(a0)                      	| [$11a7: ld   (hl),$0B]
	move.b	terrain_height_in_tiles_E514,d0                 	| [$11a9: ld   a,(terrain_height_in_tiles_E514)]
	cmp.b	#0x07,d0                         	| [$11ae: cp   $07]
	jeq	l_11f0                             	| [$11b0: jr   z,$11F0]
	move.b	#0x0B,d0                        	| [$11b2: ld   a,$0B]
	jra	l_11dd                             	| [$11b4: jr   $11DD]
l_11b6:
	move.b	(a0),d0                         	| [$11b6: ld   a,(hl)] -  * J11A4
	lea	terrain_height_in_tiles_E514,a0                	| [$11b7: ld   hl,terrain_height_in_tiles_E514]
	* here we don't test C result of subq (dec doesn't change C but sub does change X!)
	* but previous roxr result, code needs some adaptation
	tst.b	d7
	jeq	l_11d8                             	| [$11ba: jr   nc,$11D8]
	tst.b	d0                               	| [$11bc: and  a]
	jne	l_11c0                             	| [$11bd: jr   nz,$11C0]
	subq.b	#1,(a0)                         	| [$11bf: dec  (hl)] decrease terrain height by 1 tile
l_11c0:
	* tiles for slopes (actually various height rectangles)
	add.b	#0xF3,d0                         	| [$11c0: add  a,$F3] -  * J11BD,J11EE
	cmp.b	#0xFC,d0                         	| [$11c2: cp   $FC]
	jcs	l_11c8                             	| [$11c4: jr   c,$11C8]
	sub.b	#0x0C,d0                         	| [$11c6: sub  $0C]
l_11c8:
	move.b	d0,d2                           	| [$11c8: ld   c,a] -  * J11C4
l_11c9:
	addq.b	#0x03,d0                        	| [$11c9: add  a,$03] -  * J11CB
	jmi	l_11c9                             	| [$11cb: jp   m,$11C9]
	jne	write_ground_tile_1129                             	| [$11ce: jp   nz,$1129]
	* descending slope
	move.b	d2,d0                           	| [$11d1: ld   a,c]
	sub.b	#0x10,d0                         	| [$11d2: sub  $10]
	move.b	d0,d2                           	| [$11d4: ld   c,a]
	jra	write_ground_tile_1129                             	| [$11d5: jp   $1129]
l_11d8:
	cmp.b	#0x09,d0                         	| [$11d8: cp   $09] -  * J11BA
	jne	l_11dd                             	| [$11da: jr   nz,$11DD]
	addq.b	#1,(a0)                         	| [$11dc: inc  (hl)] increase terrain height by 1 tile
l_11dd:
	not.b	d0                               	| [$11dd: cpl] -  * J11B4,J11DA
	add.b	#0xF2,d0                         	| [$11de: add  a,$F2]
	cmp.b	#0xF0,d0                         	| [$11e0: cp   $F0]
	jcc	l_11e6                             	| [$11e2: jr   nc,$11E6]
	add.b	#0x0C,d0                         	| [$11e4: add  a,$0C]
l_11e6:
	* rising slope
	move.b	d0,d2                           	| [$11e6: ld   c,a] -  * J11E2
	jra	write_ground_tile_1129                             	| [$11e7: jp   $1129]
l_11ea:
	move.b	#0x0B,(a0)                      	| [$11a7: ld   (hl),$0B]
												| [$11a9: ld   a,(terrain_height_in_tiles_E514)]
	move.b	#0x0B,d0                        	| [$11ec: ld   a,$0B]
	cmp.b	#0x04,terrain_height_in_tiles_E514                         	| [$11ea: cp   $04] -  * J11AC
	jne	l_11c0                             	| [$11ee: jr   nz,$11C0]
l_11f0:
	lea	unknown_E1D9,a0                	| [$11f0: ld   hl,unknown_E1D9] -  * J11B0
	addq.b	#1,(a0)                         	| [$11f3: inc  (hl)]
	LOAD_LEW	unknown_16bit_E1E1,d5             	| [$11f4: ld   hl,(unknown_16bit_E1E1)]
	STORE_LEW	d5,unknown_16bit_E0F1                 	| [$11f7: ld   (unknown_16bit_E0F1),hl]
	clr.b	unknown_16bit_E0EF                 	| [$11fd: ld   (unknown_16bit_E0EF),hl]
	clr.b	unknown_16bit_E0EF+1                 	| [$11fd: ld   (unknown_16bit_E0EF),hl]
	rts                                    	| [$1200: ret]

l_1201:
	lea	game_rom+0x2D44,a0                      	| [$1201: ld   hl,$2D44] -  Data for splash text
l_1204:
	* D3+D4
	LOAD_D3_16_FROM_D3D4
	STORE_LEW	d3,title_screen_address_E0EB                 	| [$1204: ld   (title_screen_address_E0EB),de] -  Will be pointer to screen, but this isn't a pointer to screen memory yet * J1253
l_1208:
	move.l	a0,pointer_on_title_char_data_E0E9                 	| [$1208: ld   (pointer_on_title_char_data_E0E9),hl] -  Hold pointer to splash text data * J124D
	move.b	timer_8bit_E04E,d0                 	| [$120b: ld   a,(timer_8bit_E04E)] -  Current ISR
	addq.b	#0x03,d0                        	| [$120e: add  a,$03] -  Next action is in current+3
	move.b	d0,(0x01,a2)                    	| [$1210: ld   (ix+$01),a] -  Set trigger time
l_1213:
	move.b	#0x0B,(a2)                 	| [$1213: ld   (ix+$00),$0B] -  Transition to state 0B (running) * J121E
	rts                                    	| [$1217: ret] -  Done

display_title_1218:
	move.b	timer_8bit_E04E,d0                 	| [$1218: ld   a,(timer_8bit_E04E)] -  Current ISR
	cmp.b	(0x01,a2),d0                     	| [$121b: cp   (ix+$01)] -  Time to take action?
	jne	l_1213                             	| [$121e: jr   nz,$1213] -  No ... stay in state 0B and out
	LOAD_LEW	title_screen_address_E0EB,d5             	| [$1220: ld   hl,(title_screen_address_E0EB)] -  Pointer to screen
	addq.w	#1,d5                           	| [$1223: inc  hl] -  Next column ...
	STORE_LEW	d5,title_screen_address_E0EB                 	| [$1224: ld   (title_screen_address_E0EB),hl] -  ... over
	subq.w	#1,d5                           	| [$1227: dec  hl] -  But this column for now
	exg	d3,d5                              	| [$1228: ex   de,hl] -  To DE
	and.l	#0xFFFF,d3
	lea	0x0400,a3                      	| [$1229: ld   iy,$0400] -  Offset to Color set
	add.l	d3,a3                            	| [$122d: add  iy,de] -  IY now points to color memory
	
	move.l	pointer_on_title_char_data_E0E9,a0             	| [$122f: ld   hl,(pointer_on_title_char_data_E0E9)] -  Get data cursor
	                        	| [$1232: ld   bc,$0020] 32 -  Constant for down one row
	move.b	#0x0020,d1                        	| [$1232: ld   bc,$0020] 32 -  Constant for down one row
l_1235:
	move.b	(a0)+,d0                         	| [$1235: ld   a,(hl)] -  Get next data value * J1247
	                           	| [$1236: inc  hl] -  Next in script
	subq.b	#1,d0                           	| [$1237: dec  a] -  Is this ...
	cmp.b	#0x03,d0                         	| [$1238: cp   $03] -  ... a special byte?
	jcs	l_1249                             	| [$123a: jr   c,$1249] -  Yes ... go handle it
	addq.b	#1,d0                           	| [$123c: inc  a] -  No ... restore the value
* write "moon patrol" title loop
	* character
	move.l		d3,d7
	jbsr	osd_w_videoram_no_update                         	| [$123d: ld   (de),a] -  Character to screen
	* attribute
	move.l		a3,d7
	exg		d0,d6
	move.b	#0x80,d0
	jbsr	osd_w_colorram		| [$123e: ld   (iy+$00),$80] -  Color set to screen (plus upper tile bit = 1)
	exg		d0,d6
	                	
	                             	| [$1242: ex   de,hl] -  Add $20 ...
	add.w	d1,d3                            	| [$1243: add  hl,bc] -  ... to ...
	                             	| [$1244: ex   de,hl] -  ... next ...
	add.w	d1,a3                            	| [$1245: add  iy,bc] -  ... row ...
	jra	l_1235                             	| [$1247: jr   $1235] -  Continue with next byte
l_1249:
	subq.b	#1,d0                           	| [$1249: dec  a] -  Subtract 1 again * J123A
	jmi	l_1255                             	| [$124a: jp   m,$1255] -  Data byte is 1 or 0
	jeq	l_1208                             	| [$124d: jr   z,$1208] -  Jump if byte is 2 ... store cursor and continue
	move.b	(a0)+,d4                         	| [$124f: ld   e,(hl)] -  Screen pointer LSB
	                           	| [$1250: inc  hl] -  Next in script
	move.b	(a0)+,d3                         	| [$1251: ld   d,(hl)] -  Screen pointer MSB
	                           	| [$1252: inc  hl] -  Next in script
	jra	l_1204                             	| [$1253: jr   $1204] -  Save pointers and continue
l_1255:
	lea	game_rom+0x2C97,a0                      	| [$1255: ld   hl,$2C97] -  "1982 IREM CORP" script * J124A
	jra	write_to_screen_possible_typing_effect_300                             	| [$1258: jp   $0300] -  Print script and return

l_125b:
	move.b	unknown_E50D,d0                 	| [$125b: ld   a,(unknown_E50D)] -  * C0DDC
	subq.b	#1,d0                           	| [$125e: dec  a]
	bpl.b	0f                               	| [...]
	rts                                    	| [$125f: ret  m] [...] -  No indicator to print ... out
0:
	lea	game_rom+0x2CAB,a0                      	| [$1260: ld   hl,$2CAB] -  "CAUTION" script
	move.b	timer_8bit_E04E,d0                 	| [$1263: ld   a,(timer_8bit_E04E)]
	and.b	#0x3F,d0                         	| [$1266: and  $3F]
	jeq	print_caution_1285                             	| [$1268: jr   z,$1285] -  Print "CAUTION", show indicators, out
	and.b	#0x1F,d0                         	| [$126a: and  $1F]
	beq.b	0f                               	| [...]
	rts                                    	| [$126c: ret  nz] [...]
0:
	jbsr	erase_script_037b                            	| [$126d: call $037B] -  Erase "CAUTION"
	jbsr	l_1288                            	| [$1270: call $1288] -  Show caution indicators
	move.b	#0x02,(a0)                      	| [$1273: ld   (hl),$02]
	exg	a1,a0                              	| [$1275: ex   de,hl]
	move.b	#0x12,(a0)                      	| [$1276: ld   (hl),$12]
	lea	fine_position_on_track_E50B,a0                	| [$1278: ld   hl,fine_position_on_track_E50B]
	move.b	(a0)+,d0                         	| [$127b: ld   a,(hl)]
												| [$127c: inc  hl]
	sub.b	(a0),d0                          	| [$127d: sub  (hl)]
	cmp.b	#0x40,d0                         	| [$127e: cp   $40]
	bcc.b	0f                               	| [...]
	rts                                    	| [$1280: ret  c] [...]
0:
	addq.w	#1,a0                           	| [$1281: inc  hl]
	clr.b	(a0)                             	| [$1282: ld   (hl),$00]
	rts                                    	| [$1284: ret]
print_caution_1285:
	jbsr	write_to_screen_possible_typing_effect_300      	| [$1285: call $0300] -  Print "CAUTION" * J1268
l_1288:
	move.b	unknown_E50D,d0                 	| [$1288: ld   a,(unknown_E50D)] -  * C1270
	move.w	#0x8055,d7                      	| [$128b: ld   hl,$8055] -  Screen location for caution indicator
	move.b	#0x13,d1                        	| [$128e: ld   bc,$1302] 4866 -  Caution-bubble character, color set 2
	move.b	#0x02,d2                        	| [$128e: ld   bc,$1302] 4866 -  Caution-bubble character, color set 2
	move.w	#0x0020,d3                      	| [$1291: ld   de,$0020] 32 -  Offset for one row
	subq.b	#1,d0                           	| [$1294: dec  a] -  ??First row?
	jeq	l_129f                             	| [$1295: jr   z,$129F] -  Yes ... we are set up
	add.w	d3,d7                            	| [$1297: add  hl,de] -  Point to second row
	addq.b	#1,d2                           	| [$1298: inc  c] -  Color set 3
	subq.b	#1,d1                           	| [$1299: dec  b] -  1st bubble (character 18)
	subq.b	#1,d0                           	| [$129a: dec  a] -  ??Second row?
	jeq	l_129f                             	| [$129b: jr   z,$129F] -  Yes ... we are set up
	addq.b	#1,d1                           	| [$129d: inc  b] -  Back to 2nd bubble (character 19)
	add.w	d3,d7                            	| [$129e: add  hl,de] -  Next row
l_129f:
	move.w	d0,-(a7)
	move.b	d1,d0
	jbsr	osd_w_videoram
	move.w	(a7)+,d0
	                         	| [$129f: ld   (hl),b] -  Put bubble ... * J1295,J129B
	                     	| [$12a0: ld   de,$0400] -  ... on screen ...
	                         	| [$12a3: ex   de,hl] -  ... with ...
	add.w	#0x400,d7                            	| [$12a4: add  hl,de] -  ... desired ...
	move.w	d0,-(a7)
	move.b	d2,d0         	| [$12a5: ld   (hl),c] -  ... color
	jbsr	osd_w_colorram
	move.w	(a7)+,d0
	rts                                    	| [$12a6: ret] -  Done
update_alien_sounds_12a7:
	lea	ufo_objects_e370,a0                	| [$12a7: ld   hl,ufo_objects_e370] -  * C027A
	move.w	#0x0010,d3                      	| [$12aa: ld   de,$0010] 16
	move.b	#0x19,d1                        	| [$12ad: ld   bc,$1902] 6402
	move.b	#0x02,d2                        	| [$12ad: ld   bc,$1902] 6402
l_12b0:
	move.b	(a0),d0                         	| [$12b0: ld   a,(hl)] -  * J12D5
	cmp.b	#0x14,d0                         	| [$12b1: cp   $14]
	jeq	l_12df                             	| [$12b3: jr   z,$12DF]
	cmp.b	#0x1E,d0                         	| [$12b5: cp   $1E]
	jcs	l_12d4                             	| [$12b7: jr   c,$12D4]
	cmp.b	#0x20,d0                         	| [$12b9: cp   $20]
	jcs	l_12c5                             	| [$12bb: jr   c,$12C5]
	cmp.b	#0x22,d0                         	| [$12bd: cp   $22]
	jcs	l_12d4                             	| [$12bf: jr   c,$12D4]
	cmp.b	#0x2A,d0                         	| [$12c1: cp   $2A]
	jcc	l_12d4                             	| [$12c3: jr   nc,$12D4]
l_12c5:
	move.b	unknown_E1DF,d0                 	| [$12c5: ld   a,(unknown_E1DF)] -  * J12BB
	ror.b	#2,d0                           	| [$12c8: rra] * 2
	bcc.b	0f                               	| [...]
	rts                                    	| [$12ca: ret  c] [...]
0:
l_12cb:
	move.b	d2,d0                           	| [$12cb: ld   a,c] -  * J12E4
l_12cc:
	move.b	d0,unknown_E1DF                 	| [$12cc: ld   (unknown_E1DF),a] -  * J12DD
	add.b	#0x15,d0                         	| [$12cf: add  a,$15]
	jra	queue_sound_effect_0d6f                             	| [$12d1: jp   $0D6F] -  Make flying ship sound and out
l_12d4:
	add.w	d3,a0                            	| [$12d4: add  hl,de] -  * J12B7,J12BF,J12C3
	subq.b	#1,d1                           	| [...]
	jne	l_12b0                             	| [$12d5: djnz $12B0]
	move.b	unknown_E1DF,d0                 	| [$12d7: ld   a,(unknown_E1DF)]
	                               	| [$12da: and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [$12db: ret  z] [...]
0:
	clr.b	d0                               	| [$12dc: xor  a]
	jra	l_12cc                             	| [$12dd: jr   $12CC]
l_12df:
	move.b	unknown_E1DF,d0                 	| [$12df: ld   a,(unknown_E1DF)] -  * J12B3
	ror.b	#1,d0                           	| [$12e2: rra]
	subq.b	#1,d2                           	| [$12e3: dec  c]
	jcc	l_12cb                             	| [$12e4: jr   nc,$12CB]
	rts                                    	| [$12e6: ret]
l_12e7:
	move.b	unknown_E1DC,d0                 	| [$12e7: ld   a,(unknown_E1DC)] -  * C027D
	                               	| [$12ea: and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [$12eb: ret  z] [...]
0:
	move.b	timer_8bit_E04E,d0                 	| [$12ec: ld   a,(timer_8bit_E04E)]
	and.b	#0x0F,d0                         	| [$12ef: and  $0F]
	jeq	l_12f7                             	| [$12f1: jr   z,$12F7]
	and.b	#0x07,d0                         	| [$12f3: and  $07]
	beq.b	0f                               	| [...]
	rts                                    	| [$12f5: ret  nz] [...]
0:
	addq.b	#1,d0                           	| [$12f6: inc  a]
l_12f7:
	addq.b	#1,d0                           	| [$12f7: inc  a] -  * J12F1
	move.b	d0,d2                           	| [$12f8: ld   c,a]
	move.w	screen_address_E1DA,d7             	| [$12f9: ld   hl,(screen_address_E1DA)]
 	jbsr	osd_r_videoram                         	| [$12fc: ld   a,(hl)]
	sub.b	#0x5A,d0                         	| [$12fd: sub  $5A]
	jeq	l_130b                             	| [$12ff: jr   z,$130B]
	addq.b	#1,d0                           	| [$1301: inc  a]
	move.b	#0x04,d1                        	| [$1302: ld   b,$04]
l_1304:
	addq.b	#0x05,d0                        	| [$1304: add  a,$05] -  * J1308
	jeq	l_130b                             	| [$1306: jr   z,$130B]
	subq.b	#1,d1                           	| [...]
	jne	l_1304                             	| [$1308: djnz $1304]
	rts                                    	| [$130a: ret]
l_130b:
										| [$130b: ld   de,$0400] -  * J12FF,J1306
	add.w	#0x400,d7                            	| [$130e: add  hl,de]
	move.b	d2,d0                         	| [$130f: ld   (hl),c]
	jbsr	osd_w_colorram
	rts                                    	| [$1310: ret]

* < A2: E300
* called just before the demo, then when game starts
course_start_1311:
	move.b	#0,jeep_damping_and_y_E302
	move.b	#0x40,jeep_x_E303                 	| [$1314: ld   (jeep_damping_and_y_E302),hl] -  Store ?? and initial X
	move.b	timer_8bit_E04E,d0                 	| [$1317: ld   a,(timer_8bit_E04E)] -  Decrement counter ...
	and.b	#0x03,d0                         	| [$131a: and  $03] -  ... at 1/4 ISR rate
	jne	l_1366                             	| [$131c: jr   nz,$1366] -  Not time to decrement
	subq.b	#1,(obj_next_frame_timeout,a2)                    	| [$131e: dec  (ix+$0a)] -  Decrement the counter for waiting to start
	jpl	l_1366                             	| [$1321: jp   p,$1366] -  Not time to start
	lea	game_rom+0x2A5F,a0                      	| [$1324: ld   hl,$2A5F] -  "CHAMPION COURSE 1 GO" script
	jbsr	erase_script_037b                            	| [$1327: call $037B] -  Erase the text
	move.b	#0x18,d0                        	| [$132a: ld   a,$18] -  Start ...
	jbsr	queue_sound_effect_if_game_playing_0d75     	| [$132c: call $0D75] -  ... background music
	move.l	a0,d5
	sub.l	#game_rom,d5
	jra	next_jeep_state_135a                             	| [$132f: jr   $135A]
	
jeep_moving_on_track_1331:
	jbsr	player_shot_1548                            	| [$1331: call $1548] -  Check starting player shot
	* returns 0x40 at some point (when jeep jumps in the intro)
	rol.b	#2,d0                            	| [$1334: rlca] * 2
	jcc	l_1363                             	| [$1336: jr   nc,$1363]
	LOAD_LEW	jeep_x_speed_E31A,d5             	| [$1338: ld   hl,(jeep_x_speed_E31A)]
										| [$133b: ld   de,-$87]
	sub.w	#0x87,d5                            	| [$133e: add  hl,de]
	move.w	d5,d0                           	| [$133f: ld   a,h]
	lsr.w	#8,d0
	tst.b	d0                               	| [$1340: and  a]
	jne	l_1348                             	| [$1341: jr   nz,$1348]
	move.b	d5,d0                           	| [$1343: ld   a,l]
	cmp.b	#0xD1,d0                         	| [$1344: cp   $D1]
	jcs	l_134a                             	| [$1346: jr   c,$134A]
l_1348:
	move.b	#0xD1,d0                        	| [$1348: ld   a,$D1] -  * J1341
l_134a:
	move.b	d0,d4                           	| [$134a: ld   e,a] -  * J1346
	lsr.b	#1,d4                            	| [$134b: srl  e]
	add.b	d4,d0                            	| [$134d: add  a,e]
	not.b	d0                               	| [$134e: cpl]
	move.b	d0,d5                           	| [$134f: ld   l,a]
	st.b	d0                                	| [$1350: ld   a,$FF]
	moveq	#0,d7
	subx.b	d7,d0                        	| [$1352: sbc  a,$00]
	rol.w	#8,d5
	move.b	d0,d5                           	| [$1354: ld   h,a]
	rol.w	#8,d5
	subq.w	#1,d5                           	| [$1355: dec  hl]
	rol.w	#8,d5
	move.b	d0,d5                           	| [$1356: ld   h,a]
	rol.w	#8,d5
	STORE_LEW	d5,unknown_16bit_E308                 	| [$1357: ld   (unknown_16bit_E308),hl]
next_jeep_state_135a:
	LOAD_D5D6_FROM_D5_16
	* starts jumping: E300 from STATE_NORMAL_02 => STATE_JUMP_START_03
	addq.b	#1,(a2)                    	| [$135a: inc  (ix+$00)] -  Transition buggy to "next" state (running or jumping) * J132F
l_135d:
	jbsr	compute_wheels_positions_1576                            	| [$135d: call $1576] -  * J136E
	jra	draw_object_08b8                             	| [$1360: jp   $08B8] -  Draw the buggy
l_1363:
	jbsr	l_148a                            	| [$1363: call $148A] -  * J1336
l_1366:
	jbsr	compute_jeep_y_1533                            	| [$1366: call $1533] -  * J131C,J1321
	sub.b	#0x1C,d0                         	| [$1369: sub  $1C]
l_136b:
	move.b	d0,jeep_y_offset_E307                 	| [$136b: ld   (buggy_y_e307),a] -  * J1386
	jra	l_135d                             	| [$136e: jr   $135D]
init_jump_1370:
	addq.b	#1,(a2)                    	| [$1370: inc  (ix+$00)] -  Player is now in state "jumping"
	move.b	#0x14,d0                        	| [$1373: ld   a,$14] -  Play ...
	jbsr	queue_sound_effect_if_game_playing_0d75                            	| [$1375: call $0D75] -  ... car jump
l_1378:
	jbsr	player_shot_1548                            	| [$1378: call $1548] -  Check starting player shot * J13C0
	LOAD_LEW	unknown_16bit_E30E,d5             	| [$137b: ld   hl,(unknown_16bit_E30E)]
	jbsr	l_14a4                            	| [$137e: call $14A4]
	jbsr	compute_jeep_y_1533                            	| [$1381: call $1533]
	sub.b	#0x1E,d0                         	| [$1384: sub  $1E] -  Initial Y offset to start jump
	jra	l_136b                             	| [$1386: jr   $136B] -  Set Y and draw buggy
jeep_jumping_1388:
	
	jbsr	player_shot_1548                            	| [$1388: call $1548] -  Check starting player shot
	LOAD_LEW	unknown_16bit_E30E,d5             	| [$138b: ld   hl,(unknown_16bit_E30E)]
	jbsr	l_14a4                            	| [$138e: call $14A4]
	LOAD_LEW	unknown_16bit_E306,d5             	| [$1391: ld   hl,(unknown_16bit_E306)]
	LOAD_LEW	unknown_16bit_E308,d3             	| [$1394: ld   de,(unknown_16bit_E308)]
 	add.w	d3,d5                            	| [$1398: add  hl,de]
	STORE_LEW	d5,unknown_16bit_E306                 	| [$1399: ld   (unknown_16bit_E306),hl]
	move.w	#0xC,d5                      	| [$139c: ld   hl,$000C] 12	
	add.w	d3,d5                            	| [$139f: add  hl,de]
	STORE_LEW	d5,unknown_16bit_E308                 	| [$13a0: ld   (unknown_16bit_E308),hl]
	rol.b	#8,d5
	rol.b	#1,d5                           	| [$13a3: rl   h]
 	jcs	l_13b6                             	| [$13a5: jr   c,$13B6]
	jbsr	compute_jeep_y_1533                            	| [$13a7: call $1533]
	sub.b	#0x1D,d0                         	| [$13aa: sub  $1D]
	move.b	d0,d1                           	| [$13ac: ld   b,a]
	move.b	jeep_y_offset_E307,d0                 	| [$13ad: ld   a,(buggy_y_e307)]
	cmp.b	d1,d0                            	| [$13b0: cp   b]
	jcs	l_13b6                             	| [$13b1: jr   c,$13B6]
	addq.b	#1,(a2)                    	| [$13b3: inc  (ix+$00)] -  Player is now in state "landing"
l_13b6:
	jbsr	l_15ac                            	| [$13b6: call $15AC] -  * J13A5,J13B1
	jra	draw_object_08b8                             	| [$13b9: jp   $08B8]
jeep_landing_13bc:
	move.b	#0x02,(a2)                 	| [$13bc: ld   (ix+$00),$02]
	jra	l_1378                             	| [$13c0: jr   $1378]
jeep_falling_in_hole_13c2:
	LOAD_LEW	jeep_damping_and_y_E302,d5             	| [$13c2: ld   hl,(jeep_damping_and_y_E302)]
	LOAD_LEW	jeep_damping_force_16bit_E304,d3             	| [$13c5: ld   de,(jeep_damping_force_16bit_E304)]
	add.w	d3,d5                            	| [$13c9: add  hl,de]
	STORE_LEW	d5,jeep_damping_and_y_E302                 	| [$13ca: ld   (jeep_damping_and_y_E302),hl]
	LOAD_LEW	unknown_16bit_E306,d5             	| [$13cd: ld   hl,(unknown_16bit_E306)]
	LOAD_LEW	unknown_16bit_E308,d3             	| [$13d0: ld   de,(unknown_16bit_E308)]
	add.w	d3,d5                            	| [$13d4: add  hl,de]
	STORE_LEW	d5,unknown_16bit_E306                 	| [$13d5: ld   (unknown_16bit_E306),hl]
	jbsr	draw_object_08b8                            	| [$13d8: call $08B8]
	subq.b	#1,(obj_next_frame_timeout,a2)                    	| [$13db: dec  (ix+$0a)]
	beq.b	0f                               	| [...]
	rts                                    	| [$13de: ret  nz] [...]
0:
	addq.b	#1,(a2)                    	| [$13df: inc  (ix+$00)]
	move.b	#0x03,(obj_type,a2)                 	| [$13e2: ld   (ix+$0d),$03]
	move.b	#0x1F,d0                        	| [$13e6: ld   a,$1F] -  Play ...
	jra	queue_sound_effect_if_game_playing_0d75                             	| [$13e8: jp   $0D75] -  ... car explosion then return
handle_jeep_explosion_13eb:
	clr.b	d0                               	| [$13eb: xor  a]
	move.b	d0,unknown_E1A2                 	| [$13ec: ld   (unknown_E1A2),a]
	subq.b	#1,(obj_next_frame_timeout,a2)                    	| [$13ef: dec  (ix+$0a)]
	bmi.b	0f                               	| [...]
	rts                                    	| [$13f2: ret  p] [...]
0:
	move.b	(obj_type,a2),d0                    	| [$13f3: ld   a,(ix+$0d)]
	cmp.b	#0x09,d0                         	| [$13f6: cp   $09]
	jcc	l_0118                             	| [$13f8: jp   nc,$0118]
	cmp.b	#0x05,d0                         	| [$13fb: cp   $05]
	jcs	l_140a                             	| [$13fd: jr   c,$140A]
	jbsr	draw_object_08b8                            	| [$13ff: call $08B8]
	addq.b	#1,(obj_type,a2)                    	| [$1402: inc  (ix+$0d)]
	move.b	#0x0E,(obj_next_frame_timeout,a2)                 	| [$1405: ld   (ix+$0a),$0E]
	rts                                    	| [$1409: ret]
l_140a:
	btst.b	#1,(obj_next_frame_timeout,a2)                    	| [$140a: bit  1,(ix+$0a)] -  * J13FD
	beq.b	0f                               	| [...]
	rts                                    	| [$140e: ret  nz] [...]
0:
	eor.b	#0x07,d0                         	| [$140f: xor  $07]
	move.b	d0,(obj_type,a2)                    	| [$1411: ld   (ix+$0d),a]
	move.b	(obj_next_frame_timeout,a2),d0                    	| [$1414: ld   a,(ix+$0a)]
	cmp.b	#0xC0,d0                         	| [$1417: cp   $C0]
	jcc	draw_object_08b8                             	| [$1419: jp   nc,$08B8]
	move.b	#0x05,(obj_type,a2)                 	| [$141c: ld   (ix+$0d),$05]
	rts                                    	| [$1420: ret]

* called when the jeep jumps just after "moon patrol" title
display_moon_patrol_title_1421:
	subq.b	#1,(obj_next_frame_timeout,a2)                    	| [$1421: dec  (ix+$0a)] -  Decrement the count-down timer
	move.b	(obj_next_frame_timeout,a2),d0                    	| [$1424: ld   a,(ix+$0a)] -  Has the counter ...
	cmp.b	#0x50,d0                         	| [$1427: cp   $50] -  ... dropped low enough?
	bcs.b	0f                               	| [...]
	rts                                    	| [$1429: ret  nc] [...] -  No ... stay in this state
0:
	lea	title_display_timer_E04D,a0                	| [$142a: ld   hl,title_display_timer_E04D] -  ??
	addq.b	#1,(a0)                         	| [$142d: inc  (hl)]
	move.b	#0x04,(a2)                 	| [$142e: ld   (ix+$00),$04] -  Transition to handling buggy jumping
	rts                                    	| [$1432: ret] -  Done
	
* jeep explosion animation: hitting a rock/mine or bombed
jeep_bombed_1433:
	jbsr	copy_object_to_temp_object_add_x_speed_20db                      	| [$1433: call $20DB]
	STORE_LEW	d5,temp_16bit_x_E0D6                 	| [$1436: ld   (temp_16bit_x_E0D6),hl]
	move.w	d5,d0                           	| [$1439: ld   a,h]
	lsr.w	#8,d0								| d0 now contains object X as it's displayed
	sub.b	#0x08,d0                         	| [$143a: sub  $08]
	cmp.b	#0xF0,d0                         	| [$143c: cp   $F0]
	jcc	l_0852                             	| [$143e: jp   nc,$0852]
	LOAD_LEW	temp_16bit_x_speed_E0D8,d5             	| [$1441: ld   hl,(temp_16bit_x_speed_E0D8)]
	addq.w	#1,d5                           	| [$1444: inc  hl]
												| [$1445: bit  7,h]
	jmi	l_144b                             	| [$1447: jr   nz,$144B]
	subq.w	#2,d5                           	| [$1449: dec  hl] * 2
l_144b:
	STORE_LEW	d5,temp_16bit_x_speed_E0D8                 	| [$144b: ld   (temp_16bit_x_speed_E0D8),hl] -  * J1447
	LOAD_LEW	temp_unknown_16bit_E0DA,d5             	| [$144e: ld   hl,(temp_unknown_16bit_E0DA)]
	LOAD_LEW	temp_16bit_y_E0DC,d3             	| [$1451: ld   de,(temp_16bit_y_E0DC)]
	add.w	d3,d5                            	| [$1455: add  hl,de]
	move.w	d5,d2                           	| [$1456: ld   c,h]
	lsr.w	#8,d2								| d2 now contains object Y
	STORE_LEW	d5,temp_unknown_16bit_E0DA                 	| [$1457: ld   (temp_unknown_16bit_E0DA),hl]
	move.w	#0x0024,d5                      	| [$145a: ld   hl,$0024] 36
	add.w	d3,d5                            	| [$145d: add  hl,de]
	STORE_LEW	d5,temp_16bit_y_E0DC                 	| [$145e: ld   (temp_16bit_y_E0DC),hl]
	rol.w	#1,d5                           	| [$1461: rl   h] rol word!!
	jcs	l_1484                             	| [$1463: jr   c,$1484]
	add.b	#0x0B,d0                         	| [$1465: add  a,$0B]
	jbsr	compute_ground_object_y_from_x_1538                            	| [$1467: call $1538]
	sub.b	#0x08,d0                         	| [$146a: sub  $08]
	cmp.b	d2,d0                            	| [$146c: cp   c]
	jcc	l_1484                             	| [$146d: jr   nc,$1484]
	SET_XC_FLAGS							| cmp just set carry!
	* wheel is touching the ground, make it bounce
	LOAD_LEW	temp_16bit_y_E0DC,d3             	| [$146f: ld   de,(temp_16bit_y_E0DC)]
	clr.w	d5                      	| [$1473: ld   hl,$0000] 0
	* negate D5 but with carry, probably intents to Y speed inversion: wheels bounce up!
	subx.w	d3,d5                            	| [$1476: sbc  hl,de]
	lsr.w	#2,d3                            	| [$1478: srl  d]
	                           	| [$147a: rr   e]
	                            	| [$147c: srl  d]
	                           	| [$147e: rr   e]
	add.w	d3,d5                            	| [$1480: add  hl,de]
	STORE_LEW	d5,temp_16bit_y_E0DC                 	| [$1481: ld   (temp_16bit_y_E0DC),hl]
l_1484:
	* draw the wheels that go in the air and bounce
	jbsr	draw_object_08b8                            	| [$1484: call $08B8] -  * J1463,J146D
	* commit changes into structure
	jra	copy_temp_object_structure_to_object_20ef                             	| [$1487: jp   $20EF]
	
l_148a:
	move.b	unknown_E049,d0                 	| [$148a: ld   a,(unknown_E049)] -  * C1363
	add.b	d0,d0                            	| [$148d: add  a,a]
	lea	game_rom+0x3028,a0                      	| [$148e: ld   hl,$3028]
	and.w	#0xFF,d0                            	| [$1491: add  a,l]
	add.w	d0,a0                           	| [$1492: ld   l,a]
	move.b	(a0)+,d4                         	| [$1493: ld   e,(hl)]
	                           	| [$1494: inc  hl]
	move.b	(a0),d5                         	| [$1495: ld   h,(hl)]
	lsl.w	#8,d5                               	| [$1496: ld   l,$00]
	STORE_LEW	d5,unknown_16bit_E30E                 	| [$1498: ld   (unknown_16bit_E30E),hl]
													| [$149b: xor  a]
	and.w	#0xFF,d4
	add.w	d4,d4				| [$149c: rl   e]
	                           	| [$149e: rla]
	                           	| [$149f: ld   d,a]
	STORE_LEW	d4,unknown_16bit_E31C                 	| [$14a0: ld   (unknown_16bit_E31C),de]

* < D5 (HL): 16 bit value
l_14a4:
	LOAD_LEW	jeep_damping_and_y_E302,d3             	| [$14a4: ld   de,(jeep_damping_and_y_E302)] -  * C137E,C138E
 	clr.b	d0                               	| [$14a8: xor  a]
	sub.w	d3,d5                            	| [$14a9: sbc  hl,de]
	jcc	l_14b2                             	| [$14ad: jr   nc,$14B2]
	* must duplicate moves else C would be clobbered
	move.b	d0,d2                           	| [$14ab: ld   c,a]
	move.w	d5,d0                           	| [$14ac: ld   a,h]
	lsr.w	#8,d0
	neg.b	d0                               	| [$14af: neg]
	addq.b	#1,d2                           	| [$14b1: inc  c]
	bra.b	l_14b2_2	| continue like original flow
l_14b2:
	* must duplicate moves else C would be clobbered
	move.b	d0,d2                           	| [$14ab: ld   c,a]
	move.w	d5,d0                           	| [$14ac: ld   a,h]
	lsr.w	#8,d0
l_14b2_2:
	cmp.b	#0x18,d0                         	| [$14b2: cp   $18] -  * J14AD
	jcs	l_14b8                             	| [$14b4: jr   c,$14B8]
	move.b	#0x18,d0                        	| [$14b6: ld   a,$18]
l_14b8:
	lea	game_rom+0x3030,a0                      	| [$14b8: ld   hl,$3030] -  * J14B4
	and.w	#0xff,d0                            	| [$14bb: add  a,l]
												| [$14bc: ld   l,a]
	clr.w	d3                               	| [$14be: ld   d,$00]
	move.b	(a0,d0.w),d3                         	| [$14bd: ld   e,(hl)]
	LOAD_LEW	jeep_damping_force_16bit_E304,d5             	| [$14c0: ld   hl,(jeep_damping_force_16bit_E304)]
	move.w	d5,d0                           	| [$14c3: ld   a,h]
	                               	| [$14c4: and  a]
	lsr.w	#8,d0
	tst.b	d0
	jpl	l_14d4                             	| [$14c5: jp   p,$14D4]
	subq.b	#1,d2                           	| [$14c8: dec  c]
	jne	l_14dc                             	| [$14c9: jr   nz,$14DC]
	not.b	d0                               	| [$14cb: cpl]
	move.b	d0,d7                           	| [$14cc: ld   h,a]
												| [$14cd: ld   a,l]
	not.b	d5                               	| [$14ce: cpl]
												| [$14cf: ld   l,a]
	* rebuild HL
	lsl.w	#8,d7
	move.b	d5,d7
	move.w	d7,d5
	addq.w	#1,d5                           	| [$14d0: inc  hl]
	exg	d3,d5                              	| [$14d1: ex   de,hl]
	jra	l_14d7                             	| [$14d2: jr   $14D7]
l_14d4:
	subq.b	#1,d2                           	| [$14d4: dec  c] -  * J14C5
	jeq	l_152e                             	| [$14d5: jr   z,$152E]
l_14d7:
											| [$14d7: and  a] -  * J14D2
	sub.w	d3,d5                            	| [$14d8: sbc  hl,de]
	jcc	l_152e                             	| [$14da: jr   nc,$152E]
l_14dc:
	move.w	#0x0002,d3                      	| [$14dc: ld   de,$0002] 2 -  * J14C9
l_14df:
	move.b	timer_8bit_E04E,d0                 	| [$14df: ld   a,(timer_8bit_E04E)] -  * J1531
	roxr.b	#1,d0                           	| [$14e2: rra]
	LOAD_LEW	jeep_damping_force_16bit_E304,d5   	| [$14e3: ld   hl,(jeep_damping_force_16bit_E304)]
	* adds 2 or -3 (plus carry) depdending on?
	addx.w	d3,d5								| adc  hl,de
	* this 16 bit operation affects LSB, but can make the 16 bit result negative or positive
	STORE_LEW	d5,jeep_damping_force_16bit_E304                 	| [$14e8: ld   (jeep_damping_force_16bit_E304),hl]
	LOAD_LEW	jeep_damping_and_y_E302,d3             	| [$14eb: ld   de,(jeep_damping_and_y_E302)]
	add.w	d3,d5                            	| [$14ef: add  hl,de]
	* this 16 bit operation affects LSB changes jeep Y plus
	* byte E302 looks like Y damp speed, varying between -1 (FF and 03) to simulate damping effect
	* for the jeep
	STORE_LEW	d5,jeep_damping_and_y_E302                 	| [$14f0: ld   (jeep_damping_and_y_E302),hl]
	rol.w	#8,d5
	move.b	d5,d3                           	| [$14f3: ld   d,h]
	lea	unknown_E1DC,a0                	| [$14f4: ld   hl,unknown_E1DC]
	move.b	(a0),d0                         	| [$14f7: ld   a,(hl)]
	subq.b	#1,d0                           	| [$14f8: dec  a]
	beq.b	0f                               	| [...]
	rts                                    	| [$14f9: ret  nz] [...]
0:
	move.b	fine_position_on_track_E50B,d0                 	| [$14fa: ld   a,(fine_position_on_track_E50B)]
	add.b	d0,d0                            	| [$14fd: add  a,a]
	add.b	d0,d0                            	| [$14fe: add  a,a]
	add.b	d0,d0                            	| [$14ff: add  a,a]
	add.b	#0x08,d0                         	| [$1500: add  a,$08]
	add.b	d3,d0                            	| [$1502: add  a,d]
	bcs.b	0f                               	| [...]
	rts                                    	| [$1503: ret  nc] [...]
0:
	clr.b	(a0)                             	| [$1504: ld   (hl),$00]
	lea	cur_point_e50e,a0                	| [$1506: ld   hl,cur_point_e50e]
	addq.b	#1,(a0)                         	| [$1509: inc  (hl)]
	move.b	(a0),d0                         	| [$150a: ld   a,(hl)]
	move.b	#0x09,d1                        	| [$150b: ld   b,$09]
	cmp.b	#0x19,d0                         	| [$150d: cp   $19]
	jeq	l_1520                             	| [$150f: jr   z,$1520]
	jcs	l_1514                             	| [$1511: jr   c,$1514]
	subq.b	#1,d0                           	| [$1513: dec  a]
l_1514:
	subq.b	#0x05,d0                        	| [$1514: sub  $05] -  * J1511,J1519
	jeq	section_completed_27c0                             	| [$1516: jp   z,$27C0]
	subq.b	#1,d1                           	| [...]
	jne	l_1514                             	| [$1519: djnz $1514]
	cmp.b	#0x06,d0                         	| [$151b: cp   $06]
	jeq	section_completed_27c0                             	| [$151d: jp   z,$27C0]
	tst.b	section_completed_flag
	jne		section_completed_27c0
l_1520:
	move.b	#0x10,d0                        	| [$1520: ld   a,$10] -  Play ... * J150F
	jbsr	queue_sound_effect_if_game_playing_0d75                            	| [$1522: call $0D75] -  ... passing point
	clr.b	d0                               	| [$1525: xor  a]
	move.b	#0x01,d2                        	| [$1526: ld   c,$01]
	jbsr	store_special_event_02c2                            	| [$1528: call $02C2]
	jra	l_0d12                             	| [$152b: jp   $0D12]
l_152e:
	move.w	#-3,d3                          	| [$152e: ld   de,-3] -3 -  * J14D5,J14DA
	jra	l_14df                             	| [$1531: jr   $14DF]
compute_jeep_y_1533:
	move.b	jeep_x_E303,d0                 	| [$1533: ld   a,(buggy_x_e303)] -  * C1366,C1381,C13A7,C18C3
	add.b	#0x20,d0                         	| [$1536: add  a,$20]
	
* computes exact ground Y projection given X
* < d0: object X
* > d0: Y projection of object
* > d5/d6: 
compute_ground_object_y_from_x_1538:
	move.b	d0,d1                           	| [$1538: ld   b,a] -  * C10B1,C1467,C157C,C1A83,C1AE5,C1CFA
	move.b	scroll_logical_delta_x_E1E2,d0                 	| [$1539: ld   a,(unknown_E1E2)]
	add.b	d1,d0                            	| [$153c: add  a,b]
l_153d:
	addq.b	#0x06,d0                        	| [$153d: add  a,$06] -  * C0ED7
	lsr.b	#2,d0                            	| [$153f: srl  a] * 2
	moveq	#0,d6
	move.b	d0,d6                           	| [$1543: ld   l,a]
	lea		ground_y_array_E200,a0                        	| [$1544: ld   h,$E2]
	add.w	d6,a0
	move.b	(a0),d0                         	| [$1546: ld   a,(hl)]
	* also update D5/D6, some calls expect that
	move.b	#0xE2,d5		| useful??
	rts                                    	| [$1547: ret]
	
* Check the fire button and initiate a player shot if
* there is room (only 1 forward shot and 4 air shots at
* a time).
*
	
player_shot_1548:
	move.b	current_input_E04A,d6             	| [$1548: ld   hl,(current_input_E04A)] -  Current inputs to L, last inputs to H * C1331,C1378,C1388
	move.b	current_input_E04A+1,d5             	| [$1548: ld   hl,(current_input_E04A)] -  Current inputs to L, last inputs to H * C1331,C1378,C1388
	
	move.b	d5,d0                           	| [$154b: ld   a,h] -  Last inputs to accumulator
	eor.b	d6,d0                            	| [$154c: xor  l] -  Bits are only "1" now if inputs have changed
	and.b	d6,d0                            	| [$154d: and  l] -  Bits are only "1" now if buttons have transitioned from off to on (pressed)
	rol.b	#1,d0                            	| [$154e: rlca] -  Upper bit is the "fire" button
	bcs.b	0f                               	| [...]
	rts                                    	| [$154f: ret  nc] [...] -  Fire button not pressed ... out
0:
	move.b	d0,d2                           	| [$1550: ld   c,a] -  Hold transition status
	move.b	forward_shot_indicator_E320,d0                 	| [$1551: ld   a,(forward_shot_indicator_E320)] -  Player forward shot
	                               	| [$1554: and  a] -  Object already active?
	jne	l_155c                             	| [$1555: jr   nz,$155C] -  Yes ... only allow one forward shot
	move.b	#0x0A,d0                        	| [$1557: ld   a,$0A] -  Init player ...
	move.b	d0,forward_shot_indicator_E320                 	| [$1559: ld   (forward_shot_indicator_E320),a] -  ... forward shot routine
l_155c:
	lea	player_air_shots_E330,a0                	| [$155c: ld   hl,player_air_shots_E330] -  Start of player air shot objects * J1555
	move.b	#0x04,d1                        	| [$155f: ld   b,$04] -  Maximum of 4 shots in the air
	move.w	#0x0010,d3                      	| [$1561: ld   de,$0010] 16 -  16 bytes per shot structure
l_1564:
	move.b	(a0),d0                         	| [$1564: ld   a,(hl)] -  Is slot ... * J1569
	                               	| [$1565: and  a] -  ... available?
	jeq	l_156d                             	| [$1566: jr   z,$156D] -  Yes ... use this one
	add.w	d3,a0                            	| [$1568: add  hl,de] -  Point to next slot
	subq.b	#1,d1                           	| [...]
	jne	l_1564                             	| [$1569: djnz $1564] -  Do all 4 slots
	move.b	d2,d0                           	| [$156b: ld   a,c] -  Restore A
	rts                                    	| [$156c: ret] -  Done ... no air shot
l_156d:
	move.b	#0x0E,(a0)                      	| [$156d: ld   (hl),$0E] -  Init player air shot routine * J1566
	move.b	#0x12,d0                        	| [$156f: ld   a,$12] -  Play ...
	jbsr	queue_sound_effect_if_game_playing_0d75                            	| [$1571: call $0D75] -  ... missile from car
	move.b	d2,d0                           	| [$1574: ld   a,c] -  Restore A
	rts                                    	| [$1575: ret] -  Done
	
* < D5,D6: ram address
compute_wheels_positions_1576:
	move.b	jeep_x_E303,d0                 	| [$1576: ld   a,(buggy_x_e303)] -  * C135D
	move.b	d0,d2                           	| [$1579: ld   c,a]
	addq.b	#0x04,d0                        	| [$157a: add  a,$04]
	jbsr	compute_ground_object_y_from_x_1538                            	| [$157c: call $1538]
	sub.b	#0x09,d0                         	| [$157f: sub  $09]
	jbsr	update_leftmost_jeep_wheel_15c9                            	| [$1581: call $15C9]
	                           	| [$1584: ld   a,d]
	eor.b	#0x03,d3                         	| [$1585: xor  $03]
	                           	| [$1587: ld   d,a]
	move.b	#0x09,d0                        	| [$1588: ld   a,$09]
	
	jbsr	update_other_jeep_wheel_1592                            	| [$158a: call $1592]
	addq.b	#1,d6                           	| [$158d: inc  l]
	addq.b	#2,d3                           	| [$158e: inc  d] * 2
	move.b	#0x0D,d0                        	| [$1590: ld   a,$0D]
	* pass through, effectively calling update for the 3rd wheel
update_other_jeep_wheel_1592:
	add.b	d2,d0                            	| [$1592: add  a,c] -  * C158A
	move.b	d0,d2                           	| [$1593: ld   c,a]
	* next ground column
	addq.b	#2,d6                           	| [$1594: inc  l] * 2
	                           	| [$1596: ld   a,l]
	* modulus 64
	and.b	#0x3F,d6                         	| [$1597: and  $3F]
	                           	| [$1599: ld   l,a]
	lea		ground_y_array_E200,a0
	* D5/D6 is E2xx with xx: 0->3F, don't consider D5
	moveq	#0,d0
	move.b	d6,d0
	move.b	(a0,d0.w),d0                         	| [$159a: ld   a,(hl)]

	sub.b	#0x09,d0                         	| [$159b: sub  $09]
	jbsr	compute_jeep_horizon_object_y_08ed                            	| [$159d: call $08ED]
	move.b	d0,d1                           	| [$15a0: ld   b,a]
l_15a1:
	* next wheel sprite (E1A4->E1AC)                           	| [$15a1: inc  iy] -  * J15C7
	addq.w	#4,a3                           	| [$15a3: inc  iy] * 4
	jra	write_sprite_data_0976                             	| [$15a9: jp   $0976]
l_15ac:
	move.b	jeep_x_E303,d0                 	| [$15ac: ld   a,(buggy_x_e303)] -  * C13B6
	move.b	d0,d2                           	| [$15af: ld   c,a]
	move.b	jeep_y_offset_E307,d0                 	| [$15b0: ld   a,(buggy_y_e307)]
	add.b	#0x11,d0                         	| [$15b3: add  a,$11]
	jbsr	update_leftmost_jeep_wheel_15c9                            	| [$15b5: call $15C9]
	move.b	d3,d0                           	| [$15b8: ld   a,d]
	eor.b	#0x03,d0                         	| [$15b9: xor  $03]
	move.b	d0,d3                           	| [$15bb: ld   d,a]
	move.b	#0x09,d0                        	| [$15bc: ld   a,$09]
	jbsr	l_15c5                            	| [$15be: call $15C5]
	addq.b	#2,d3                           	| [$15c1: inc  d] * 2
	move.b	#0x0D,d0                        	| [$15c3: ld   a,$0D]
l_15c5:
	add.b	d2,d0                            	| [$15c5: add  a,c] -  * C15BE
	move.b	d0,d2                           	| [$15c6: ld   c,a]
	jra	l_15a1                             	| [$15c7: jr   $15A1]
	
update_leftmost_jeep_wheel_15c9:
	addq.b	#1,d2                           	| [$15c9: inc  c] -  * C1581,C15B5
	jbsr	compute_jeep_horizon_object_y_08ed                            	| [$15ca: call $08ED]
	move.b	d0,d1                           	| [$15cd: ld   b,a]
	move.w	#0x0500,d3                      	| [$15ce: ld   de,$0500]
	move.b	scroll_logical_delta_x_E1E2,d0                 	| [$15d1: ld   a,(unknown_E1E2)]
	btst.b	#4,d0                           	| [$15d4: bit  4,a]
	jne	l_15d9                             	| [$15d6: jr   nz,$15D9]
	* change wheel angle
	add.w	#0x100,d3                           	| [$15d8: inc  d]
l_15d9:
	LOAD_D3D4_FROM_D3_16
	lea	wheels_sprites_shadow_ram_E1A4,a3                	| [$15d9: ld   iy,wheels_sprites_shadow_ram_E1A4] -  * J15D6
	jra	write_sprite_data_0976                             	| [$15dd: jp   $0976]
	
init_forward_shot_15e0:
	move.b	#0x0C,(obj_next_frame_timeout,a2)                 	| [$15e0: ld   (ix+$0a),$0C] -  12 movements before ending
	move.b	jeep_y_offset_E307,d0                 	| [$15e4: ld   a,(buggy_y_e307)] -  Moon buggy Y coordinate
	add.b	#0x0A,d0                         	| [$15e7: add  a,$0A] -  Start shot in front of gun
	move.b	d0,forward_shot_y_E327                 	| [$15e9: ld   (forward_shot_y_E327),a] -  Set the forward shot's Y coordinate
	LOAD_LEW	jeep_damping_and_y_E302,d5             	| [$15ec: ld   hl,(jeep_damping_and_y_E302)] -  X coordinate to H
	                      	| [$15ef: ld   de,$1C00] -  1C offset for Y
	add.w	#0x1C00,d5                            	| [$15f2: add  hl,de] -  Add 1C to H (Y coordinate of shot)
	STORE_LEW	d5,unknown_16bit_E322                 	| [$15f3: ld   (unknown_16bit_E322),hl] -  Store Y coordinate for forward shot (set ?? to 0)
	addq.b	#1,(a2)                    	| [$15f6: inc  (ix+$00)] -  Handler is now "0B Run player forward shot"
	rts                                    	| [$15f9: ret] -  Done
handle_forward_shot_15fa:
	subq.b	#1,(obj_next_frame_timeout,a2)                    	| [$15fa: dec  (ix+$0a)] -  Has the shot moved all of its allocated time?
	jeq	l_1618                             	| [$15fd: jr   z,$1618] -  Yes ... begin its death
	LOAD_LEW	unknown_16bit_E322,d5             	| [$15ff: ld   hl,(unknown_16bit_E322)] -  Forward shot X coordinate (and ???)
	                      	| [$1602: ld   de,$045D] -  +4 X forward rate
	add.w	#0x45D,d5                            	| [$1605: add  hl,de]
	STORE_LEW	d5,unknown_16bit_E322                 	| [$1606: ld   (unknown_16bit_E322),hl]
	move.b	(obj_next_frame_timeout,a2),d0                    	| [$1609: ld   a,(ix+$0a)] -  Count
	ror.b	#1,d0                           	| [$160c: rra] -  Is it odd or even?
	jcs	l_1612                             	| [$160f: jr   c,$1612] -  It is odd ... use first shot image
	move.b	#0x0A,d0                        	| [$160d: ld   a,$09] -  Object_09 First shot image
	                           	| [$1611: inc  a] -  It is even ... use Object_0A second shot image
	jra		l_1612_2
l_1612:
	move.b	#0x09,d0                        	| [$160d: ld   a,$09] -  Object_09 First shot image
l_1612_2:
	move.b	d0,(obj_type,a2)                    	| [$1612: ld   (ix+$0d),a] -  Set new shot image * J160F
	jra	draw_object_08b8                             	| [$1615: jp   $08B8]
l_1618:
	addq.b	#1,(a2)                    	| [$1618: inc  (ix+$00)] -  Transition to 0C to show the shot exploding * J15FD
	move.b	#0x03,(obj_next_frame_timeout,a2)                 	| [$161b: ld   (ix+$0a),$03] -  Three runs before changing sprite image
	move.b	#0x0B,(obj_type,a2)                 	| [$161f: ld   (ix+$0d),$0B] -  Start with first explosion Object_0B
l_1623:
	move.b	scroll_logical_delta_x_E1E2,d0                 	| [$1623: ld   a,(unknown_E1E2)] -  * C1DF7,C1E18
	add.b	(obj_x,a2),d0                     	| [$1626: add  a,(ix+$03)]
	move.b	d0,(obj_absolute_x,a2)                    	| [$1629: ld   (ix+$0f),a] -  ?? X offset accounting for speed ??
	rts                                    	| [$162c: ret]
forward_shot_exploding_162d:
	jbsr	update_surface_object_0831                            	| [$162d: call $0831] -  ?? changing X based on speed
	subq.b	#1,(obj_next_frame_timeout,a2)                    	| [$1630: dec  (ix+$0a)] -  Count down delay between image changes
	bmi.b	0f                               	| [...]
	rts                                    	| [$1633: ret  p] [...] -  Return ... not time to change image
0:
	move.b	(obj_type,a2),d0                    	| [$1634: ld   a,(ix+$0d)] -  Get image number
	cmp.b	#0x0D,d0                         	| [$1637: cp   $0D] -  Player shot miss explosion end Object_0D?
	jeq	l_0852                             	| [$1639: jp   z,$0852] -  Yes ... end the explosion
	cmp.b	#0x29,d0                         	| [$163c: cp   $29] -  Player shot hit explosion end Object_29?
	jeq	l_0852                             	| [$163e: jp   z,$0852] -  Yes ... end the explosion
	addq.b	#1,(obj_type,a2)                    	| [$1641: inc  (ix+$0d)] -  Next image
	move.b	#0x03,(obj_next_frame_timeout,a2)                 	| [$1644: ld   (ix+$0a),$03] -  Set new image delay
	rts                                    	| [$1648: ret] -  Done
init_vertical_shot_1649:
	move.b	jeep_x_E303,d0                 	| [$1649: ld   a,(buggy_x_e303)] -  Get the player-object X coordinate
	add.b	#0x0A,d0                         	| [$164c: add  a,$0A] -  Offset to where the up-gun is in the image
	move.b	d0,(obj_x,a2)                    	| [$164e: ld   (ix+$03),a] -  Set the air-shot's X coordinate
	move.b	jeep_y_offset_E307,d0                 	| [$1651: ld   a,(buggy_y_e307)] -  Get the player's Y coordinate
	addq.b	#0x02,d0                        	| [$1654: add  a,$02] -  Offset to where shot starts
	move.b	d0,(obj_y,a2)                    	| [$1656: ld   (ix+$07),a] -  Set shot Y coordinate
	addq.b	#1,(a2)                    	| [$1659: inc  (ix+$00)] -  Next command ... 0F (run the air shot)
	rts                                    	| [$165c: ret] -  Done
handle_vertical_shot_165d:
	move.b	jeep_params_E300,d0                 	| [$165d: ld   a,(jeep_params_E300)] -  Moon buggy command
	move.b	#0,0x200
	cmp.b	#STATE_FALL_IN_HOLE_06,d0                         	| [$1660: cp   $06] -  Is buggy crashing?
	jcc	clear_vertical_shot_168f                             	| [$1662: jr   nc,$168F] -  Yes ... command 6 or greater ... remove shot from active duty
	move.b	(obj_y,a2),d0                    	| [$1664: ld   a,(ix+$07)] -  Get shot Y coordinate
	subq.b	#0x03,d0                        	| [$1667: sub  $03] -  Move it up
	cmp.b	#0x3A,d0                         	| [$1669: cp   $3A] -  Less than 58 (status area) ?
	jcs	clear_vertical_shot_168f                             	| [$166b: jr   c,$168F] -  Shot has left the screen ... remove it
	move.b	d0,(obj_y,a2)                    	| [$166d: ld   (ix+$07),a] -  New shot Y coordinate
	jbsr	compute_screen_address_081b                            	| [$1670: call $081B] -  Get text screen pointer for X,Y coordinates
	move.b	(obj_y,a2),d0                    	| [$1673: ld   a,(ix+$07)] -  Get Y coordinate
	roxr.b	#3,d0                           	| [$1676: rra] * 3 -  Rotate ... (well, rather *8)
	move.b	d3,d0                           	| [$1679: ld   a,d] -  X coordinate divided by 2
	roxl.b	#1,d0                           	| [$167a: rla] -  Pull in Y bit to select top (0) or bottom (1) for shot's position in tile
	and.b	#0x07,d0                         	| [$167b: and  $07] -  Select picture tile 60..67 to match x remainder and y
	* vertical shot is a character, not a sprite, ranging from 0x60 to 0x67
	or.b	#0x60,d0                          	| [$167d: or   $60] -  8 shot tile pictures at x=0,2,4,6 for bottom and top of tile
	jbsr	osd_w_videoram             	| [$167f: ld   (hl),a] -  Store player shot tile on text screen
												| [$1680: ld   de,$0400] -  Offset ...
	add.w	#0x400,d7                            	| [$1683: add  hl,de] -  ... to tile color
	exg	d5,d0
	moveq	#0,d0
	jbsr	osd_w_colorram                             	| [$1684: ld   (hl),$00] -  Set the color-set to 0
	exg		d5,d0
	ror.b	#1,d0                           	| [$1686: rra] -  Picture is odd? (next picture is at the top of the same tile)
	bcs.b	0f                               	| [...]
	rts                                    	| [$1687: ret  nc] [...] -  No ... even picture ... no "old shot" to erase
0:
													| [$1688: ld   de,-$3e0] -  Back around to tile map and down a row
	sub.w	#0x3e0,d7                            	| [$168b: add  hl,de] -  Point to last shot position on the screen
	moveq	#0,d0
	jbsr	osd_w_videoram                             	| [$168c: ld   (hl),$00] -  Erase the last shot position on the screen
	rts                                    	| [$168e: ret] -  Done
clear_vertical_shot_168f:
	jbsr	compute_screen_address_081b                            	| [$168f: call $081B] -  Get text screen pointer for X,Y coordinates * J1662,J166B
	moveq	#0,d0
	jbsr	osd_w_videoram                             	| [$1692: ld   (hl),$00] -  Clear the shot from the screen
	clr.b	(a2)                        	| [$1694: ld   (ix+$00),$00] -  Remove the shot object from active duty
	rts                                    	| [$1698: ret] -  Done
	
* this routine seems to handle:
* - jeep horizontal shots colliding with rocks, tanks... (destroys object)
* - jeep colliding with rock, tanks... (kills jeep)
* this routine doesn't handle vertical shot collision or ship bomb vs jeep
* (disabling it only confers partial invulnerability, and less points)
*
* only called when a rock or other similar object is in the screen
*
* < A2: 
ground_objects_collision_checks_1699:
	moveq	#0,d0
	* load object screen X in D2
	move.b	(obj_x,a2),d2                    	| [$1699: ld   c,(ix+$03)] -  * C18E3,C1953,C195A,C1A2B,C1A8A,C1B16,C1B27
	
	move.b	(0x0c,a2),d0                    	| [$169c: ld   a,(ix+$0c)]
	lsl.b	#3,d0                            	| [$169f: add  a,a]
												| [$16a0: add  a,a]
												| [$16a1: add  a,a]  times 8
	lea	game_rom+0x311C,a0                      	| [$16a2: ld   hl,$311C]
	                            	| [$16a5: add  a,l]
	add.w	d0,a0                           	| [$16a6: ld   l,a]
	move.b	forward_shot_indicator_E320,d0                 	| [$16a7: ld   a,(forward_shot_indicator_E320)]
	move.w	#0xF804,d3                      	| [$16aa: ld   de,-$7fc]
	sub.b	#0x0B,d0                         	| [$16ad: sub  $0B]
	jeq	l_16b7                             	| [$16af: jr   z,$16B7]
	subq.b	#1,d0                           	| [$16b1: dec  a]
	jne	l_16cb                             	| [$16b2: jr   nz,$16CB]
	move.w	#0xF00A,d3                      	| [$16b4: ld   de,-$ff6]
l_16b7:
	* forward shot active
	LOAD_D3D4_FROM_D3_16			| decompose D3 into D3/D4
	move.b	unknown_16bit_E322+1,d0                 	| [$16b7: ld   a,(unknown_E323)] -  * J16AF
	add.b	d3,d0                            	| [$16ba: add  a,d]
	sub.b	d2,d0                            	| [$16bb: sub  c]
	cmp.b	#0xE8,d0                         	| [$16bc: cp   $E8]
	jcs	l_16cb                             	| [$16be: jr   c,$16CB]
	move.b	forward_shot_y_E327,d0                 	| [$16c0: ld   a,(forward_shot_y_E327)]
	sub.b	(obj_y,a2),d0                     	| [$16c3: sub  (ix+$07)]
	add.b	(a0),d0                          	| [$16c6: add  a,(hl)]
	add.b	d4,d0                            	| [$16c7: add  a,e]
	jpl	l_174e                             	| [$16c8: jp   p,$174E]
l_16cb:
	move.b	(0x0c,a2),d0                    	| [$16cb: ld   a,(ix+$0c)] -  * J16B2,J16BE
	                               	| [$16ce: and  a]
	bpl.b	0f                               	| [...]
	rts                                    	| [$16cf: ret  m] [...]
0:
	addq.w	#1,a0                           	| [$16d0: inc  hl]
	
	* probably bounding box intersection algorithm with X and Y
	move.b	jeep_x_E303,d0                 	| [$16d1: ld   a,(buggy_x_e303)]
	sub.b	d2,d0                            	| [$16d4: sub  c] sub object X with jeep X

	* object dimensions?
	add.b	(a0)+,d0                          	| [$16d5: add  a,(hl)]
												| [$16d6: inc  hl]
	move.b	(a0)+,d1                         	| [$16d7: ld   b,(hl)]
											| [$16d8: inc  hl]
	cmp.b	d1,d0                            	| [$16d9: cp   b]
	jcs	l_16e1                             	| [$16da: jr   c,$16E1]
	sub.b	(a0),d0                          	| [$16dc: sub  (hl)]
	jcc	l_16e0                             	| [$16dd: jr   nc,$16E0]
	clr.b	d0                               	| [$16df: xor  a]
l_16e0:
	add.b	d1,d0                            	| [$16e0: add  a,b] -  * J16DD
l_16e1:
	addq.w	#1,a0                           	| [$16e1: inc  hl] -  * J16DA
	cmp.b	(a0),d0                          	| [$16e2: cp   (hl)]
	jcc	l_17c4                             	| [$16e3: jp   nc,$17C4]
	addq.w	#1,a0                           	| [$16e6: inc  hl]
	move.b	(a0)+,d1                         	| [$16e7: ld   b,(hl)]
	                           	| [$16e8: inc  hl]
	add.b	(a0),d0                          	| [$16e9: add  a,(hl)]
	* a0 was pointing on ROM. Game changes lsb & adds 1 to msb
	* we have to do that emulator-style
	move.l	a0,d7
	sub.l	#game_rom,d7			| d7: 16 bit address (HL)
	move.b	d0,d7                           	| [$16ea: ld   l,a] change LSB
	add.w	#0x100,d7                           	| [$16eb: inc  h] add 1 to MSB
	add.l	#game_rom,d7			| recreate real address
	move.l	d7,a0
	
	
	move.b	jeep_y_offset_E307,d0                 	| [$16ec: ld   a,(buggy_y_e307)]
	add.b	(a0),d0                          	| [$16ef: add  a,(hl)]
	sub.b	(obj_y,a2),d0                     	| [$16f0: sub  (ix+$07)]
	subq.b	#1,d0                           	| [$16f3: dec  a]
	* collision with object (rock,...) or hit by bomb
	add.b	d1,d0                            	| [$16f4: add  a,b]
	bpl.b	0f                               	| [...]
	rts                                    	| [$16f5: ret  m] [...]
0:
	jbsr	osd_read_dsw_2                       	| [$16f6: ld   a,($D004)] -  Get DIP switches DSW2
	btst.b	#6,d0                           	| [$16f9: bit  6,a] -  Is invulnerable set?
	bne.b	0f                               	| [...]
	* cheat mode: don't die
	rts                                    	| [$16fb: ret  z] [...] -  Yes ... no crash
0:
	move.l	(sp)+,a0                        	| [$16fc: pop  hl] -  We won't be returning
jeep_killed_16fd:
	move.b	#STATE_EXPLODING_07,d0                        	| [$16fd: ld   a,$07] -  Set first command to ... * J1A1F,J1D9B
	move.b	d0,jeep_params_E300                 	| [$16ff: ld   (jeep_params_E300),a] -  ... handle player crash
	move.b	#0x03,d0                        	| [$1702: ld   a,$03]
	move.b	d0,unknown_E30D                 	| [$1704: ld   (unknown_E30D),a]
	clr.b	d0                               	| [$1707: xor  a]
	move.b	d0,unknown_E30A                 	| [$1708: ld   (unknown_E30A),a]
	move.b	d0,objectB_e3b0                 	| [$170b: ld   (objectB_e3b0),a]
	move.b	d0,unknown_E172                 	| [$170e: ld   (unknown_E172),a]
	jbsr	l_0852                            	| [$1711: call $0852]
	move.b	#0x03,d1                        	| [$1714: ld   b,$03]
	move.b	jeep_y_offset_E307,d0                 	| [$1716: ld   a,(buggy_y_e307)]
	add.b	#0x14,d0                         	| [$1719: add  a,$14]
	move.b	d0,d2                           	| [$171b: ld   c,a]
	move.b	jeep_x_E303,d0                 	| [$171c: ld   a,(buggy_x_e303)]
	lea	unknown_E1D3,a0                	| [$171f: ld   hl,unknown_E1D3]
	addq.b	#1,(a0)                         	| [$1722: inc  (hl)]
	lea	objectC_e3c0,a0                	| [$1723: ld   hl,objectC_e3c0]
	lea	game_rom+0x30DF,a3                      	| [$1726: ld   iy,$30DF]
l_172a:
	move.b	#0x1C,(a0)                      	| [$172a: ld   (hl),$1C] -  * J1744
	addq.w	#3,a0                           	| [$172c: inc  hl] * 3
	move.b	d0,(a0)                         	| [$172f: ld   (hl),a]
	add.b	#0x10,d0                         	| [$1730: add  a,$10]
	jbsr	l_17f8                            	| [$1732: call $17F8]
	move.b	d2,(a0)                         	| [$1735: ld   (hl),c]
	jbsr	l_17f8                            	| [$1736: call $17F8]
	addq.w	#2,a0                           	| [$1739: inc  hl] * 2
	move.b	(a3),d4                    	| [$173b: ld   e,(iy+$00)]
	move.b	d4,(a0)                         	| [$173e: ld   (hl),e]
	addq.w	#1,a3                           	| [$173f: inc  iy]
	addq.w	#3,a0                           	| [$1741: inc  hl] * 3
	subq.b	#1,d1                           	| [...]
	jne	l_172a                             	| [$1744: djnz $172A]
	jbsr	l_08a1                            	| [$1746: call $08A1]
	move.b	#0x1F,d0                        	| [$1749: ld   a,$1F] -  Play ...
	jra	queue_sound_effect_if_game_playing_0d75                             	| [$174b: jp   $0D75] -  ... car explosion
l_174e:
	move.b	scroll_logical_delta_x_E1E2,d0                 	| [$174e: ld   a,(unknown_E1E2)] -  * J16C8
	add.b	(obj_x,a2),d0                     	| [$1751: add  a,(ix+$03)]
	move.b	d0,unknown_E32F                 	| [$1754: ld   (unknown_E32F),a]
	move.b	#0x0D,d0                        	| [$1757: ld   a,$0D]
	move.b	d0,forward_shot_indicator_E320                 	| [$1759: ld   (forward_shot_indicator_E320),a]
	move.b	#0x26,d0                        	| [$175c: ld   a,$26]
	move.b	d0,unknown_E32D                 	| [$175e: ld   (unknown_E32D),a]
	move.b	#0x03,d0                        	| [$1761: ld   a,$03]
	move.b	d0,unknown_E32A                 	| [$1763: ld   (unknown_E32A),a]
	move.b	#0x01,d0                        	| [$1766: ld   a,$01] -  Play ...
	jbsr	queue_sound_effect_if_game_playing_0d75                            	| [$1768: call $0D75] -  ... shot a rock
	move.w	#0x0007,d3                      	| [$176b: ld   de,$0007] 7
	add.w	d3,a0                            	| [$176e: add  hl,de]
	move.b	(a0),d0                         	| [$176f: ld   a,(hl)]
	and.b	#0x0F,d0                         	| [$1770: and  $0F]
	move.b	#0x01,d2                        	| [$1772: ld   c,$01]
	cmp.b	#0x0E,d0                         	| [$1774: cp   $0E]
	jcc	l_177f                             	| [$1776: jr   nc,$177F]
	jbsr	store_special_event_02c2                            	| [$1778: call $02C2]
	move.l	(sp)+,a0                        	| [$177b: pop  hl]
	jra	l_0852                             	| [$177c: jp   $0852]
l_177f:
	jne	l_1794                             	| [$177f: jr   nz,$1794] -  * J1776
	jbsr	get_random_between_1_and_3_17f0                            	| [$1781: call $17F0]
	addq.b	#0x05,d0                        	| [$1784: add  a,$05]
	move.b	d0,(0x08,a2)                    	| [$1786: ld   (ix+$08),a]
	jbsr	store_special_event_02c2                            	| [$1789: call $02C2]
	addq.b	#1,(obj_command,a2)                    	| [$178c: inc  (ix+$00)] change state
	clr.b	(obj_next_frame_timeout,a2)                        	| [$178f: ld   (ix+$0a),$00]
	rts                                    	| [$1793: ret]
l_1794:
	jbsr	l_0856                            	| [$1794: call $0856] -  * J177F
	jbsr	get_random_between_1_and_3_17f0                            	| [$1797: call $17F0]
	move.w	#-0x4f0,d5                      	| [$179a: ld   hl,-$4f0]
l_179d:
	addq.b	#0x06,d0                        	| [$179d: add  a,$06] -  * J1DF0
	move.b	d0,(0x08,a2)                    	| [$179f: ld   (ix+$08),a]

	move.l	a0,-(sp)                        	| [$17a2: push hl]
	jbsr	store_special_event_02c2                            	| [$17a3: call $02C2]
	move.l	(sp)+,a0                        	| [$17a6: pop  hl]

	LOAD_D5D6_FROM_D5_16
	
	move.b	(obj_y,a2),d0                    	| [$17a7: ld   a,(ix+$07)]
	add.b	d5,d0                            	| [$17aa: add  a,h]
	move.b	d0,(obj_y,a2)                    	| [$17ab: ld   (ix+$07),a]
	move.b	(obj_x,a2),d0                    	| [$17ae: ld   a,(ix+$03)]
	add.b	d6,d0                            	| [$17b1: add  a,l]
	move.b	d0,(obj_x,a2)                    	| [$17b2: ld   (ix+$03),a]
	move.b	#0x54,(obj_type,a2)                 	| [$17b5: ld   (ix+$0d),$54]
	move.b	#0x21,(obj_command,a2)                 	| [$17b9: ld   (ix+$00),$21]
	move.b	#0x3B,(obj_next_frame_timeout,a2)                 	| [$17bd: ld   (ix+$0a),$3B]
	jra	l_0856                             	| [$17c1: jp   $0856]

l_17c4:
	move.b	d0,d1                           	| [$17c4: ld   b,a] -  * J16E3
	move.b	(0x0c,a2),d0                    	| [$17c5: ld   a,(ix+$0c)]
	add.b	#0x80,d0                         	| [$17c8: add  a,$80]
	move.b	d0,d2                           	| [$17ca: ld   c,a]
	cmp.b	#0x8B,d0                         	| [$17cb: cp   $8B]
	jeq	l_17ea                             	| [$17cd: jr   z,$17EA]
	cmp.b	#0x8E,d0                         	| [$17cf: cp   $8E]
	jeq	l_17ea                             	| [$17d1: jr   z,$17EA]
	move.b	d1,d0                           	| [$17d3: ld   a,b]
	sub.b	(a0),d0                          	| [$17d4: sub  (hl)]
	cmp.b	#0x04,d0                         	| [$17d5: cp   $04]
	bcs.b	0f                               	| [...]
	rts                                    	| [$17d7: ret  nc] [...]
0:
l_17d8:
	move.b	d2,(0x0c,a2)                    	| [$17d8: ld   (ix+$0c),c] -  * J17ED
	addq.w	#3,a0                           	| [$17db: inc  hl] * 3
	move.b	(a0),d0                         	| [$17de: ld   a,(hl)]
	ror.b	#4,d0                           	| [$17df: rra] * 4
	and.b	#0x0F,d0                         	| [$17e3: and  $0F]
	move.b	#0x01,d2                        	| [$17e5: ld   c,$01]
	jra	store_special_event_02c2                             	| [$17e7: jp   $02C2]
l_17ea:
	move.b	d1,d0                           	| [$17ea: ld   a,b] -  * J17CD,J17D1
	cmp.b	#0xFC,d0                         	| [$17eb: cp   $FC]
	jcc	l_17d8                             	| [$17ed: jr   nc,$17D8]
	rts                                    	| [$17ef: ret]
get_random_between_1_and_3_17f0:
	jbsr	osd_get_random                           	| [$17f0: ld   a,r] -  * C1781,C1797
	and.b	#0x03,d0                         	| [$17f2: and  $03]
	beq.b	0f                               	| [...]
	rts                                    	| [$17f4: ret  nz] [...]
0:
	* 0 isn't acceptable: select 2 in that case
	move.b	#0x02,d0                        	| [$17f5: ld   a,$02]
	rts                                    	| [$17f7: ret]
l_17f8:
	addq.w	#1,a0                           	| [$17f8: inc  hl] -  * C1732,C1736
	move.b	(a3),d4                    	| [$17f9: ld   e,(iy+$00)]
	move.b	d4,(a0)+                         	| [$17fc: ld   (hl),e]
	                           	| [$17fd: inc  hl]
	move.b	(0x01,a3),d4                    	| [$17fe: ld   e,(iy+$01)]
	move.b	d4,(a0)                         	| [$1801: ld   (hl),e]
	addq.w	#2,a0                           	| [$1802: inc  hl] * 2
	addq.w	#2,a3                           	| [$1804: inc  iy] * 2
	rts                                    	| [$1808: ret]
	* update mountains/city and also track scroll layers
update_scrolling_layers_1809:
	move.b	jeep_params_E300,d0                 	| [$1809: ld   a,(jeep_params_E300)] -  Buggy command
	cmp.b	#STATE_FALL_IN_HOLE_06,d0                         	| [$180c: cp   $06] -  Buggy running normally?
	bcs.b	0f                               	| [...]
	rts                                    	| [$180e: ret  nc] [...] -  No ... skip
0:
	clr.w	d5                               	| [$1811: ld   h,$00]
	cmp.b	#0x01,d0                         	| [$180f: cp   $01]
	jeq	l_188b                             	| [$1813: jr   z,$188B]
	LOAD_LEW	unknown_16bit_E31C,d5             	| [$1815: ld   hl,(unknown_16bit_E31C)]
	LOAD_LEW	jeep_x_speed_E31A,d3             	| [$1818: ld   de,(jeep_x_speed_E31A)]
	* test sign of D which amounts to test sign of D3.W
	tst.w	d3                           	| [$181c: ld   a,d]
	
	                          	| [$181d: and  a]
	* hacked workflow to preserve C flag, jr nc at 1826 would branch
	* with HL at 3
	jmi	l_182b                             	| [$181e: jp   m,$1823]
	sub.w	d3,d5                            	| [$1821: sbc  hl,de]
	jcc	l_182b                             	| [$1826: jr   nc,$182B]
	move.w	#-2,d5                          	| [$1828: ld   hl,-2] -2
	bra.b	l_182b_2
l_182b:
	moveq	#3,d5                      	| [$1823: ld   hl,$0003] 3 -  * J181E
l_182b_2:
	move.b	timer_8bit_E04E,d0                 	| [$182b: ld   a,(timer_8bit_E04E)] -  * J1826
	* just tests bit 0, we don't care about D0 value
	ror.b	#1,d0                           	| [$182e: rra]
	jcs	l_1832                             	| [$182f: jr   c,$1832]
	subq.b	#1,d3                           	| [$1831: dec  e]
l_1832:
	add.w	d3,d5                            	| [$1832: add  hl,de] -  * J182F
	STORE_LEW	d5,jeep_x_speed_E31A                 	| [$1833: ld   (jeep_x_speed_E31A),hl]
	LOAD_LEW	jeep_damping_force_16bit_E304,d3             	| [$1836: ld   de,(jeep_damping_force_16bit_E304)]
	                               	| [$183a: and  a]
	sub.w	d3,d5                            	| [$183b: sbc  hl,de]
	STORE_LEW	d5,jeep_x_speed_E314                 	| [$183d: ld   (jeep_x_speed_E314),hl]
	exg	d5,d3                              	| [$1840: ex   de,hl]
	* increase E1E1 counter faster if jeep is faster
	LOAD_LEW	unknown_16bit_E1E1,d5             	| [$1841: ld   hl,(unknown_16bit_E1E1)]
	add.w	d3,d5                            	| [$1844: add  hl,de]
	STORE_LEW	d5,unknown_16bit_E1E1                 	| [$1845: ld   (unknown_16bit_E1E1),hl]
	move.b	unknown_E1D9,d0                 	| [$1848: ld   a,(unknown_E1D9)]
	ror.b	#1,d0                           	| [$184b: rra]
	jcc	l_188b                             	| [$184c: jr   nc,$188B]
	LOAD_LEW	unknown_16bit_E0EF,d5             	| [$184e: ld   hl,(unknown_16bit_E0EF)]
 	add.w	d3,d5                            	| [$1851: add  hl,de]
	move.w	d5,d0                           	| [$1852: ld   a,h]
	lsr.w	#8,d0
	addq.b	#0x06,d0                        	| [$1853: add  a,$06]
	cmp.b	#0x0C,d0                         	| [$1855: cp   $0C]
	jcs	l_1870                             	| [$1857: jr   c,$1870]
	sub.b	#0x12,d0                         	| [$1859: sub  $12]
	rol.w	#8,d5
	move.b	d0,d5                           	| [$185b: ld   h,a]
	rol.w	#8,d5

	move.l	a0,-(sp)                        	| [$185c: push hl]
	lea	unknown_E23F,a0                	| [$185d: ld   hl,unknown_E23F]
	lea	unknown_E242,a1                	| [$1860: ld   de,unknown_E242]
	move.w	#0x40,d1                        	| [$1863: ld   bc,$0040] 64
	jbsr	lddr
	lea	unknown_E242,a0                	| [$1868: ld   hl,unknown_E242]
	move.w	#0x03,d1                        	| [$186b: ld   c,$03]
	jbsr	lddr
	move.l	(sp)+,a0                        	| [$186f: pop  hl]
l_1870:
	* reached constantly when slope fills the screen
	STORE_LEW	d5,unknown_16bit_E0EF                 	| [$1870: ld   (unknown_16bit_E0EF),hl] -  * J1857
	LOAD_LEW	unknown_16bit_E0F1,d3             	| [$1873: ld   de,(unknown_16bit_E0F1)]
	add.w	d3,d5                            	| [$1877: add  hl,de]
	move.b	terrain_slope_type_E508,d0                 	| [$1878: ld   a,(terrain_slope_type_E508)]
	cmp.b	#TERRAIN_RISING_03,d0                         	| [$187b: cp   $03]
	jcc	l_188b                             	| [$187d: jr   nc,$188B]
	move.b	scroll_logical_delta_x_E1E2,d0                 	| [$187f: ld   a,(unknown_E1E2)]
	rol.w	#8,d5
	sub.b	d5,d0                            	| [$1882: sub  h]
	rol.w	#8,d5
	cmp.b	#0xF4,d0                         	| [$1883: cp   $F4]
	jcs	l_188b                             	| [$1885: jr   c,$188B]
	clr.b	d0                               	| [$1887: xor  a]
	move.b	d0,unknown_E1D9                 	| [$1888: ld   (unknown_E1D9),a]
l_188b:
	rol.w	#8,d5
	move.b	d5,d0                           	| [$188b: ld   a,h] -  * J1813,J184C,J187D,J1885
	rol.w	#8,d5
	not.b	d0                               	| [$188c: cpl]
	lea	x_scroll_horizon_e03d,a0       	| [$188d: ld   hl,x_scroll_horizon_e03d]
	add.b	(a0),d0                          	| [$1890: add  a,(hl)]
	move.b	d0,scroll_x_value_ground_layer_E1C0	| [$1891: ld   (scroll_x_value_ground_layer_E1C0),a]
	LOAD_LEW	jeep_x_speed_E314,d5             	| [$1894: ld   hl,(jeep_x_speed_E314)]
 	* d5 times 1.5
	move.w	d5,d3                           	| [$1897: ld   d,h]
	                           	| [$1898: ld   e,l]
	lsr.w	#1,d5                            	| [$1899: srl  h]
	                           	| [$189b: rr   l]
	add.w	d3,d5                            	| [$189d: add  hl,de]

	* d5 times 0.375
	lsr.w	#2,d5                            	| [$189e: srl  h] * 2
	exg	d3,d5                              	| [$18a6: ex   de,hl]
	* update fine scroll x value for green layer
	move.w	fine_scroll_x_value_green_layer_E504,d5             	| [$18a7: ld   hl,(fine_scroll_x_value_green_layer_E504)]
	add.w	d3,d5                            	| [$18aa: add  hl,de]
 	move.w	d5,fine_scroll_x_value_green_layer_E504    | [$18ab: ld   (fine_scroll_x_value_green_layer_E504),hl]
	* pick higher part for slowly updating value for background scroll
	move.w	d5,d0                           	| [$18ae: ld   a,h]
	lsr.w	#8,d0
	not.b	d0                               	| [$18af: cpl]
	move.b	d0,scroll_x_value_green_layer_E1C1	| [$18b0: ld   (scroll_x_value_green_layer_E1C1),a]
	* blue layer is updated twice less often: divide increment by 2
	lsr.w	#1,d3                            	| [$18b3: srl  d]
	                           	| [$18b5: rr   e]
	move.w	fine_scroll_x_value_blue_layer_E506,d5             	| [$18b7: ld   hl,(fine_scroll_x_value_blue_layer_E506)]
	add.w	d3,d5                            	| [$18ba: add  hl,de]
 	move.w	d5,fine_scroll_x_value_blue_layer_E506                 	| [$18bb: ld   (fine_scroll_x_value_blue_layer_E506),hl]
	* pick higher part for slowly updating value for background scroll
	move.w	d5,d0                           	| [$18be: ld   a,h]
	lsr.w	#8,d0
	not.b	d0                               	| [$18bf: cpl]
	move.b	d0,scroll_x_value_blue_layer_E1C2	| [$18c0: ld   (scroll_x_value_blue_layer_E1C2),a]
	jbsr	compute_jeep_y_1533                            	| [$18c3: call $1533]
	cmp.b	#0xC4,d0                         	| [$18c6: cp   $C4]
	jcc	l_18cc                             	| [$18c8: jr   nc,$18CC]
	move.b	#0xC4,d0                        	| [$18ca: ld   a,$C4]
l_18cc:
	add.b	#0x28,d0                         	| [$18cc: add  a,$28] -  * J18C8
	jcc	l_18d1                             	| [$18ce: jr   nc,$18D1]
	clr.b	d0                               	| [$18d0: xor  a]
l_18d1:
	move.b	d0,d1                           	| [$18d1: ld   b,a] -  * J18CE
	add.b	#0x94,d0                         	| [$18d2: add  a,$94]
	move.b	d0,green_layer_y_pos_E1C3                 	| [$18d4: ld   (green_layer_y_pos_E1C3),a]
	asr.b	#1,d1                            	| [$18d7: sra  b]
	move.b	d1,d0                           	| [$18d9: ld   a,b]
	add.b	#0x72,d0                         	| [$18da: add  a,$72]
	move.b	d0,blue_layer_y_pos_E1C4                 	| [$18dc: ld   (blue_layer_y_pos_E1C4),a]
	rts                                    	| [$18df: ret]
update_yellow_tank_18e0:
	jbsr	update_surface_object_0831                            	| [$18e0: call $0831]
	jbsr	ground_objects_collision_checks_1699                            	| [$18e3: call $1699]
	subq.b	#1,(obj_next_frame_timeout,a2)                    	| [$18e6: dec  (ix+$0a)]
	bmi.b	0f                               	| [...]
	rts                                    	| [$18e9: ret  p] [...]
0:
	addq.b	#1,(obj_next_frame_timeout,a2)                    	| [$18ea: inc  (ix+$0a)]
	move.b	(obj_x,a2),d0                    	| [$18ed: ld   a,(ix+$03)]
	cmp.b	#0xE0,d0                         	| [$18f0: cp   $E0]
	bcs.b	0f                               	| [...]
	rts                                    	| [$18f2: ret  nc] [...]
0:
	move.b	(0x0c,a2),d0                    	| [$18f3: ld   a,(ix+$0c)]
	rol.b	#1,d0                           	| [$18f6: rla]
	bcc.b	0f                               	| [...]
	rts                                    	| [$18f7: ret  c] [...]
0:
	* yellow tank starts shooting
	move.b	objectC_e3c0,d0                 	| [$18f8: ld   a,(objectC_e3c0)]
	                               	| [$18fb: and  a]
	beq.b	0f                               	| [...]
	rts                                    	| [$18fc: ret  nz] [...]
0:
	lea	ufo_objects_e370,a3                	| [$18fd: ld   iy,ufo_objects_e370]
	move.w	#0x0010,d3                      	| [$1901: ld   de,$0010] 16
	move.b	#MAX_NB_UFOS_1,d1                        	| [$1904: ld   b,$05]
l_1906:
	move.b	(a3),d0                    	| [$1906: ld   a,(iy+$00)] -  * J191C
	cmp.b	#0x1D,d0                         	| [$1909: cp   $1D]
	jne	l_191a                             	| [$190b: jr   nz,$191A]
	SET_X_FROM_C
	move.b	(0x0c,a3),d0                    	| [$190d: ld   a,(iy+$0c)]
	roxl.b	#1,d0                           	| [$1910: rla]
	jcs	l_191a                             	| [$1911: jr   c,$191A]
	move.b	(obj_x,a2),d0                    	| [$1913: ld   a,(ix+$03)]
	sub.b	(obj_x,a3),d0                     	| [$1916: sub  (iy+$03)]
	bcc.b	0f                               	| [...]
	rts                                    	| [$1919: ret  c] [...]
0:
l_191a:
	add.w	d3,a3                            	| [$191a: add  iy,de] -  * J190B,J1911
	subq.b	#1,d1                           	| [...]
	jne	l_1906                             	| [$191c: djnz $1906]
	move.b	(obj_y,a2),d0                    	| [$191e: ld   a,(ix+$07)]
	move.b	d0,(obj_y,a3)                    	| [$1921: ld   (iy+$07),a]
	move.b	(obj_timeout,a2),d0                    	| [$1924: ld   a,(ix+$0f)]
	subq.b	#0x04,d0                        	| [$1927: sub  $04]
	move.b	d0,(0x0f,a3)                    	| [$1929: ld   (iy+$0f),a]
	move.b	#0x11,(a3)                 	| [$192c: ld   (iy+$00),$11]
	move.b	#0x22,(obj_type,a3)                 	| [$1930: ld   (iy+$0d),$22]
	move.b	#0x0C,(0x0c,a3)                 	| [$1934: ld   (iy+$0c),$0C]
	move.b	#0x43,(obj_next_frame_timeout,a2)                 	| [$1938: ld   (ix+$0a),$43]
	rts                                    	| [$193c: ret]
	
update_yellow_tank_shot_193d:
	move.b	jeep_params_E300,d0                 	| [$193d: ld   a,(jeep_params_E300)]
	cmp.b	#STATE_FALL_IN_HOLE_06,d0                         	| [$1940: cp   $06]
	bcs.b	0f                               	| [...]
	rts                                    	| [$1942: ret  nc] [...]
0:
	move.b	(0x04,a2),d0                    	| [$1943: ld   a,(ix+$04)]
	add.b	#0xDD,d0                         	| [$1946: add  a,$DD]
	jcc	l_1950                             	| [$194b: jr   nc,$1950]
 	subq.b	#1,(obj_timeout,a2)                    	| [$194d: dec  (ix+$0f)]
l_1950:
	move.b	d0,(0x04,a2)                    	| [$1948: ld   (ix+$04),a]
	jbsr	update_surface_object_0838                            	| [$1950: call $0838] -  * J194B
	jbsr	ground_objects_collision_checks_1699                            	| [$1953: call $1699]
	rts                                    	| [$1956: ret]
update_rock_1957:
	* reaches here when needs to display surface objects like rocks
	jbsr	update_surface_object_0831                            	| [$1957: call $0831]
	jbsr	ground_objects_collision_checks_1699                            	| [$195a: call $1699]
	rts                                    	| [$195d: ret]
check_if_fall_in_hole_195e:
	jbsr	update_surface_object_0831                            	| [$195e: call $0831]
	move.b	(0x0c,a2),d0                    	| [$1961: ld   a,(ix+$0c)]
	                               	| [$1964: and  a]
	beq.b	0f                               	| [...]
	rts                                    	| [$1965: ret  nz] [...]
0:
	move.b	(obj_type,a2),d0                    	| [$1966: ld   a,(ix+$0d)]
	rol.b	#2,d0                            	| [$1969: rlca] * 2
	and.b	#0x1C,d0                         	| [$196b: and  $1C]
	lea	game_rom+0x2E00,a0                      	| [$196d: ld   hl,$2E00]
	and.w	#0xFF,d0
	add.w	d0,a0
                	| [$1970: add  a,l]
					| [$1971: ld   l,a]
	move.b	jeep_x_E303,d0                 	| [$1972: ld   a,(buggy_x_e303)]
	sub.b	(obj_x,a2),d0                     	| [$1975: sub  (ix+$03)]
	add.b	(a0)+,d0                          	| [$1978: add  a,(hl)]
	                           	| [$1979: inc  hl]
	cmp.b	(a0),d0                          	| [$197a: cp   (hl)]
	jcc	l_19c2                             	| [$197b: jr   nc,$19C2]
	* reached when jeep is next to a hole
	move.b	d0,d1                           	| [$197d: ld   b,a]
	move.b	jeep_params_E300,d0                 	| [$197e: ld   a,(jeep_params_E300)]
	cmp.b	#START_JUMPING_04,d0                         	| [$1981: cp   $04]
	bne.b	0f                               	| [...]
	* jeep was jumping: no problem!
	rts                                    	| [$1983: ret  z] [...]
0:
	jbsr	osd_read_dsw_2                       	| [$1984: ld   a,($D004)]
	btst.b	#6,d0                           	| [$1987: bit  6,a]
	bne.b	0f                               	| [...]
	* cheat mode activated: don't die!
	rts                                    	| [$1989: ret  z] [...]
0:
	* jeep falls into hole
	move.b	d1,d0                           	| [$198a: ld   a,b]
	move.b	(a0),d1                         	| [$198b: ld   b,(hl)]
	move.b	#0x02,d2                        	| [$198c: ld   c,$02]
	lsr.b	#1,d1                            	| [$198e: srl  b]
	move.b	d1,d3                           	| [$1990: ld   d,b]
	lsr.b	#1,d1                            	| [$1991: srl  b]
	cmp.b	d3,d0                            	| [$1993: cp   d]
	jcs	l_199a                             	| [$1994: jr   c,$199A]
	move.b	d1,d0                           	| [$1996: ld   a,b]
	add.b	d3,d0                            	| [$1997: add  a,d]
	move.b	d0,d1                           	| [$1998: ld   b,a]
	subq.b	#1,d2                           	| [$1999: dec  c]
l_199a:
	move.b	(obj_x,a2),d0                    	| [$199a: ld   a,(ix+$03)] -  * J1994
	add.b	d1,d0                            	| [$199d: add  a,b]
	sub.b	#0x1C,d0                         	| [$199e: sub  $1C]
	move.b	d0,jeep_x_E303                 	| [$19a0: ld   (buggy_x_e303),a]
	move.b	d2,d0                           	| [$19a3: ld   a,c]
	move.b	d0,unknown_E30D                 	| [$19a4: ld   (unknown_E30D),a]
	subq.b	#2,d0                           	| [$19a7: dec  a] * 2
	* change lower part of counter
	move.b	d0,jeep_damping_force_16bit_E304+1                 	| [$19a9: ld   (unknown_E305),a]
	* change higher part of counter
	move.b	#0x80,d0                        	| [$19ac: ld   a,$80]
	move.b	d0,jeep_damping_force_16bit_E304                 	| [$19ae: ld   (jeep_damping_force_16bit_E304),a]
	addq.w	#1,a0                           	| [$19b1: inc  hl]
	move.b	(a0),d0                         	| [$19b2: ld   a,(hl)]
	move.b	d0,unknown_E30A                 	| [$19b3: ld   (unknown_E30A),a]
	move.w	#0x200,d5                      	| [$19b6: ld   hl,$0200]
	
	STORE_LEW	d5,unknown_16bit_E308                 	| [$19b9: ld   (unknown_16bit_E308),hl]
	* change state to: fall in hole
	move.b	#STATE_FALL_IN_HOLE_06,d0                        	| [$19bc: ld   a,$06]
	move.b	d0,jeep_params_E300                 	| [$19be: ld   (jeep_params_E300),a]
	rts                                    	| [$19c1: ret]
l_19c2:
	sub.b	(a0),d0                          	| [$19c2: sub  (hl)] -  * J197B
	cmp.b	#0x04,d0                         	| [$19c3: cp   $04]
	bcs.b	0f                               	| [...]
	rts                                    	| [$19c5: ret  nc] [...]
0:
	addq.b	#1,(0x0c,a2)                    	| [$19c6: inc  (ix+$0c)]
	addq.w	#2,a0                           	| [$19c9: inc  hl] * 2
	move.b	(a0),d0                         	| [$19cb: ld   a,(hl)]
	move.b	#0x01,d2                        	| [$19cc: ld   c,$01]
	jra	store_special_event_02c2                             	| [$19ce: jp   $02C2]
update_volcano_19d1:
	subq.b	#1,(obj_next_frame_timeout,a2)                    	| [$19d1: dec  (ix+$0a)]
	jpl	l_1a0d                             	| [$19d4: jp   p,$1A0D]
	move.b	(0x0e,a2),d0                    	| [$19d7: ld   a,(ix+$0e)]
	move.b	d0,d1                           	| [$19da: ld   b,a]
	addq.b	#1,d0                           	| [$19db: inc  a]
	move.b	#0x07,d2                        	| [$19dc: ld   c,$07]
	cmp.b	#0x06,d0                         	| [$19de: cp   $06]
	jcs	l_19ed                             	| [$19e0: jr   c,$19ED]
	move.b	timer_8bit_E04E,d0                 	| [$19e2: ld   a,(timer_8bit_E04E)]
	and.b	#0x30,d0                         	| [$19e5: and  $30]
	jne	l_19eb                             	| [$19e7: jr   nz,$19EB]
	move.b	#0x30,d0                        	| [$19e9: ld   a,$30]
l_19eb:
	move.b	d0,d2                           	| [$19eb: ld   c,a] -  * J19E7
	clr.b	d0                               	| [$19ec: xor  a]
l_19ed:
	move.b	d0,(0x0e,a2)                    	| [$19ed: ld   (ix+$0e),a] -  * J19E0
	move.b	d2,(obj_next_frame_timeout,a2)                    	| [$19f0: ld   (ix+$0a),c]
	move.b	d1,d0                           	| [$19f3: ld   a,b]
	cmp.b	#0x04,d0                         	| [$19f4: cp   $04]
	jcs	l_19fc                             	| [$19f6: jr   c,$19FC]
	eor.b	#0x07,d0                         	| [$19f8: xor  $07]
	subq.b	#1,d0                           	| [$19fa: dec  a]
	move.b	d0,d1                           	| [$19fb: ld   b,a]
l_19fc:
	addq.b	#0x06,d0                        	| [$19fc: add  a,$06] -  * J19F6
	move.b	(0x0c,a2),d1                    	| [$19fe: ld   b,(ix+$0c)]
	addq.b	#1,d1                           	| [$1a01: inc  b]
	jmi	l_1a08                             	| [$1a02: jp   m,$1A08]
	move.b	d0,(0x0c,a2)                    	| [$1a05: ld   (ix+$0c),a]
l_1a08:
	add.b	#0x45,d0                         	| [$1a08: add  a,$45] -  * J1A02
	move.b	d0,(obj_type,a2)                    	| [$1a0a: ld   (ix+$0d),a]
l_1a0d:
	move.b	forward_shot_indicator_E320,d0                 	| [$1a0d: ld   a,(forward_shot_indicator_E320)] -  * J19D4
	cmp.b	#0x0F,d0                         	| [$1a10: cp   $0F]
	jcs	l_1a22                             	| [$1a12: jr   c,$1A22]
	beq.b	0f                               	| [...]
	rts                                    	| [$1a14: ret  nz] [...]
0:
	move.b	jeep_x_E303,d0                 	| [$1a15: ld   a,(buggy_x_e303)]
	sub.b	(obj_x,a2),d0                     	| [$1a18: sub  (ix+$03)]
	add.b	#0x10,d0                         	| [$1a1b: add  a,$10]
	cmp.b	#0x30,d0                         	| [$1a1d: cp   $30]
	jcs	jeep_killed_16fd                             	| [$1a1f: jp   c,$16FD]
l_1a22:
	jbsr	update_surface_object_0838                            	| [$1a22: call $0838] -  * J1A12
	move.b	(0x0c,a2),d0                    	| [$1a25: ld   a,(ix+$0c)]
	cmp.b	#0x06,d0                         	| [$1a28: cp   $06]
	bne.b	0f                               	| [...]
	rts                                    	| [$1a2a: ret  z] [...]
0:
	jbsr	ground_objects_collision_checks_1699                            	| [$1a2b: call $1699]
	rts                                    	| [$1a2e: ret]
exploding_volcano_1a2f:
	jbsr	update_surface_object_0831                            	| [$1a2f: call $0831]
	subq.b	#1,(obj_next_frame_timeout,a2)                    	| [$1a32: dec  (ix+$0a)]
	bmi.b	0f                               	| [...]
	rts                                    	| [$1a35: ret  p] [...]
0:
	move.b	(obj_type,a2),d0                    	| [$1a36: ld   a,(ix+$0d)]
	cmp.b	#0x4A,d0                         	| [$1a39: cp   $4A]
	bne.b	0f                               	| [...]
	rts                                    	| [$1a3b: ret  z] [...]
0:
	subq.b	#1,(obj_type,a2)                    	| [$1a3c: dec  (ix+$0d)]
	move.b	#0x07,(obj_next_frame_timeout,a2)                 	| [$1a3f: ld   (ix+$0a),$07]
	rts                                    	| [$1a43: ret]
update_rolling_rock_1a44:
	move.b	jeep_params_E300,d0                 	| [$1a44: ld   a,(jeep_params_E300)]
	cmp.b	#0x06,d0                         	| [$1a47: cp   $06]
	bcs.b	0f                               	| [...]
	rts                                    	| [$1a49: ret  nc] [...]
0:
	subq.b	#1,(0x0e,a2)                    	| [$1a4a: dec  (ix+$0e)]
	jpl	l_1a66                             	| [$1a4d: jp   p,$1A66]
	move.b	#0x06,(0x0e,a2)                 	| [$1a50: ld   (ix+$0e),$06]
	move.b	(obj_type,a2),d0                    	| [$1a54: ld   a,(ix+$0d)]
	subq.b	#1,d0                           	| [$1a57: dec  a]
	move.w	#0x03,d1                        	| [$1a58: ld   bc,$0003] 3
	lea	game_rom+0x1A8E,a0                      	| [$1a5b: ld   hl,$1A8E]
	jbsr	cpir                              	| [$1a5e: cpir]
	jne	l_1a63                             	| [$1a60: jr   nz,$1A63]
	move.b	(a0),d0                         	| [$1a62: ld   a,(hl)]
l_1a63:
	move.b	d0,(obj_type,a2)                    	| [$1a63: ld   (ix+$0d),a] -  * J1A60
l_1a66:
	move.b	(0x04,a2),d0                    	| [$1a66: ld   a,(ix+$04)] -  * J1A4D
	add.b	#0xC0,d0                         	| [$1a69: add  a,$C0]
	jcc	l_1a73                             	| [$1a6e: jr   nc,$1A73]
l_1a70:
	subq.b	#1,(obj_absolute_x,a2)                    	| [$1a70: dec  (ix+$0f)] -  * J1A91
l_1a73:
	move.b	d0,(0x04,a2)                    	| [$1a6b: ld   (ix+$04),a]
	jbsr	update_surface_object_0838                            	| [$1a73: call $0838] -  * J1A6E
	move.b	(0x0c,a2),d0                    	| [$1a76: ld   a,(ix+$0c)]
	subq.b	#0x04,d0                        	| [$1a79: sub  $04]
	asl.b	#1,d0                            	| [$1a7b: sla  a]
	add.b	#0x0C,d0                         	| [$1a7d: add  a,$0C]
	move.b	d0,d2                           	| [$1a7f: ld   c,a]
	move.b	(obj_x,a2),d0                    	| [$1a80: ld   a,(ix+$03)]
	jbsr	compute_ground_object_y_from_x_1538                            	| [$1a83: call $1538]
	sub.b	d2,d0                            	| [$1a86: sub  c]
	move.b	d0,(obj_y,a2)                    	| [$1a87: ld   (ix+$07),a]
	jbsr	ground_objects_collision_checks_1699                            	| [$1a8a: call $1699]
	rts                                    	| [$1a8d: ret]
	
rear_missile_following_1a92:
	move.b	#0x01,(0x0b,a2)                 	| [$1a92: ld   (ix+$0b),$01]
	move.b	jeep_params_E300,d0                       	| [$1a96: ld   a,($E300)]
	cmp.b	#0x06,d0                         	| [$1a99: cp   $06]
	bcs.b	0f                               	| [...]
	rts                                    	| [$1a9b: ret  nc] [...]
0:
	LOAD_LEW	unknown_16bit_E372,d5             	| [$1a9c: ld   hl,(unknown_16bit_E372)]
	move.w	d5,d0                           	| [$1a9f: ld   a,h]
	lsr.w	#8,d0
	cmp.b	#0x08,d0                         	| [$1aa0: cp   $08]
	jeq	l_1aad                             	| [$1aa2: jr   z,$1AAD]
	move.w	#0x0070,d3                      	| [$1aa4: ld   de,$0070] 112
	add.w	d3,d5                            	| [$1aa7: add  hl,de]
	STORE_LEW	d5,unknown_16bit_E372                 	| [$1aa8: ld   (unknown_16bit_E372),hl]
	jra	l_1ad9                             	| [$1aab: jr   $1AD9]
l_1aad:
	clr.b	(obj_next_frame_timeout,a2)                        	| [$1aad: ld   (ix+$0a),$00] -  * J1AA2
	addq.b	#1,(a2)                    	| [$1ab1: inc  (ix+$00)]
	move.b	#0x80,(0x0e,a2)                 	| [$1ab4: ld   (ix+$0e),$80]
	rts                                    	| [$1ab8: ret]
rear_missile_following_1ab9:
	move.b	timer_8bit_E04E,d0                 	| [$1ab9: ld   a,(timer_8bit_E04E)]
	ror.b	#1,d0                           	| [$1abc: rra]
	bcc.b	0f                               	| [...]
	rts                                    	| [$1abd: ret  c] [...]
0:
	move.b	jeep_params_E300,d0                 	| [$1abe: ld   a,(jeep_params_E300)]
	cmp.b	#0x06,d0                         	| [$1ac1: cp   $06]
	bcs.b	0f                               	| [...]
	rts                                    	| [$1ac3: ret  nc] [...]
0:
l_1ac4:
	move.b	timer_8bit_E04E,d0                 	| [$1ac4: ld   a,(timer_8bit_E04E)] -  * J1AF3,J1B2D
	move.b	d0,d1                           	| [$1ac7: ld   b,a]
	and.b	#0x03,d0                         	| [$1ac8: and  $03]
	jne	l_1ad9                             	| [$1aca: jr   nz,$1AD9]
	addq.b	#1,(obj_x,a2)                    	| [$1acc: inc  (ix+$03)]
	btst.b	#5,d1                           	| [$1acf: bit  5,b]
	jeq	l_1ad9                             	| [$1ad1: jr   z,$1AD9]
	subq.b	#2,(obj_x,a2)                    	| [$1ad3: dec  (ix+$03)] * 2
l_1ad9:
	move.b	timer_8bit_E04E,d0                 	| [$1ad9: ld   a,(timer_8bit_E04E)] -  * J1AAB,J1ACA,J1AD1,J1B19
	and.b	#0x07,d0                         	| [$1adc: and  $07]
	jne	l_1aed                             	| [$1ade: jr   nz,$1AED]
	move.b	(obj_x,a2),d0                    	| [$1ae0: ld   a,(ix+$03)]
	add.b	#0x18,d0                         	| [$1ae3: add  a,$18]
	jbsr	compute_ground_object_y_from_x_1538                            	| [$1ae5: call $1538]
	sub.b	#0x10,d0                         	| [$1ae8: sub  $10]
	move.b	d0,(obj_y,a2)                    	| [$1aea: ld   (ix+$07),a]
l_1aed:
	jra	draw_object_08b8                             	| [$1aed: jp   $08B8] -  * J1ADE
rear_missile_following_1af0:
	subq.b	#1,(0x0e,a2)                    	| [$1af0: dec  (ix+$0e)]
	jne	l_1ac4                             	| [$1af3: jr   nz,$1AC4]
	move.b	#0x58,(obj_next_frame_timeout,a2)                 	| [$1af5: ld   (ix+$0a),$58]
	addq.b	#1,(a2)                    	| [$1af9: inc  (ix+$00)]
	move.b	#0x52,(obj_type,a2)                 	| [$1afc: ld   (ix+$0d),$52]
	rts                                    	| [$1b00: ret]
rear_missile_attacking_1b01:
	subq.b	#1,(obj_next_frame_timeout,a2)                    	| [$1b01: dec  (ix+$0a)]
	jeq	l_1b1b                             	| [$1b04: jr   z,$1B1B]
	LOAD_LEW	unknown_16bit_E372,d5             	| [$1b06: ld   hl,(unknown_16bit_E372)]
	                      	| [$1b09: ld   de,$0180]
	add.w	#0x180,d5                            	| [$1b0c: add  hl,de]
	STORE_LEW	d5,unknown_16bit_E372                 	| [$1b0d: ld   (unknown_16bit_E372),hl]
	move.w	d5,d0                           	| [$1b10: ld   a,h]
	lsr.w	#8,d0
	cmp.b	#0xF0,d0                         	| [$1b11: cp   $F0]
	jcc	l_0852                             	| [$1b13: jp   nc,$0852]
	jbsr	ground_objects_collision_checks_1699                            	| [$1b16: call $1699]
	jra	l_1ad9                             	| [$1b19: jr   $1AD9]
l_1b1b:
	addq.b	#1,(a2)                    	| [$1b1b: inc  (ix+$00)] -  * J1B04
	move.b	#0x6E,(obj_next_frame_timeout,a2)                 	| [$1b1e: ld   (ix+$0a),$6E]
	move.b	#0x23,(obj_type,a2)                 	| [$1b22: ld   (ix+$0d),$23]
	rts                                    	| [$1b26: ret]
rear_missile_sitting_duck_1b27:
	jbsr	ground_objects_collision_checks_1699                            	| [$1b27: call $1699]
	subq.b	#1,(obj_next_frame_timeout,a2)                    	| [$1b2a: dec  (ix+$0a)]
	jne	l_1ac4                             	| [$1b2d: jr   nz,$1AC4]
	subq.b	#1,(a2)                    	| [$1b2f: dec  (ix+$00)]
	subq.b	#1,(0x0b,a2)                    	| [$1b32: dec  (ix+$0b)]
	move.b	#0x52,(obj_type,a2)                 	| [$1b35: ld   (ix+$0d),$52]
	rts                                    	| [$1b39: ret]
	
handle_ufo_shots_1b3a:
	lea	unknown_E0EE,a0                	| [$1b3a: ld   hl,unknown_E0EE] -  * C0274
	move.b	timer_8bit_E04E,d0                 	| [$1b3d: ld   a,(timer_8bit_E04E)]
	sub.b	(a0),d0                          	| [$1b40: sub  (hl)]
	bpl.b	0f                               	| [...]
	rts                                    	| [$1b41: ret  m] [...]
0:
	move.b	#0x10,d1                        	| [$1b42: ld   bc,$1000] 4096
	move.b	#0x00,d2                        	| [$1b42: ld   bc,$1000] 4096
	* pick one of the positions 0-15
	jbsr	osd_get_random                           	| [$1b45: ld   a,r]
	and.b	#0xF0,d0                         	| [$1b47: and  $F0]
	lea		unknown_E400,a0                        	| [$1b49: ld   h,$E4]
	move.b	d2,d3                           	| [$1b4b: ld   d,c]
	move.b	d2,d4                           	| [$1b4c: ld   e,c]
	moveq	#0,d7
l_1b4d:
	move.b	d0,d7                           	| [$1b4d: ld   l,a] -  * J1B62
	move.b	(a0,d7.w),d0                         	| [$1b4e: ld   a,(hl)]
	sub.b	#0x1E,d0                         	| [$1b4f: sub  $1E]
	cmp.b	#0x0A,d0                         	| [$1b51: cp   $0A]
	jcc	l_1b5f                             	| [$1b53: jr   nc,$1B5F]
	btst.b	#1,d0                           	| [$1b55: bit  1,a]
	jne	l_1b5f                             	| [$1b57: jr   nz,$1B5F]
	cmp.b	#0x04,d0                         	| [$1b59: cp   $04]
	jcs	l_1bc0                             	| [$1b5b: jr   c,$1BC0]
	addq.b	#1,d2                           	| [$1b5d: inc  c]
	move.b	d7,d4                           	| [$1b5e: ld   e,l]
l_1b5f:
	move.b	d7,d0                           	| [$1b5f: ld   a,l] -  * J1B53,J1B57,J1BC2
	add.b	#0x10,d0                         	| [$1b60: add  a,$10] next slot
	subq.b	#1,d1                           	| [...]
	jne	l_1b4d                             	| [$1b62: djnz $1B4D]
	move.b	d4,unknown_E1D4
	* is this required? doesn't seem read anywhere
	move.b	d3,unknown_E1D4+1                 	| [$1b64: ld   (unknown_E1D4),de]
	subq.b	#1,d2                           	| [$1b68: dec  c]
	bpl.b	0f                               	| [...]
	rts                                    	| [$1b69: ret  m] [...]
0:
	move.b	current_level_E510,d0                	| [$1b6a: ld   a,(current_level_E510)] -  Course number
	and.b	#0x03,d0                         	| [$1b6d: and  $03]
	cmp.b	#0x01,d0                         	| [$1b6f: cp   $01]
	SET_X_FROM_C
	addx.b	D2,d0								| adc  a,c
	move.b	d0,d2                           	| [$1b72: ld   c,a]
	cmp.b	#0x09,d0                         	| [$1b73: cp   $09]
	jcs	l_1b7a                             	| [$1b75: jp   c,$1B7A]
	move.b	#0x08,d2                        	| [$1b78: ld   c,$08]
l_1b7a:
	lea	game_rom+0x2FFF,a0                      	| [$1b7a: ld   hl,$2FFF] -  * J1B75
	LOAD_D1_16_FROM_D1D2
	add.w	d1,a0                            	| [$1b7d: add  hl,bc]
	move.b	(a0),d2                         	| [$1b7e: ld   c,(hl)]
	move.b	#MAX_NB_UFOS_1,d1                        	| [$1b7f: ld   b,$05] max 5 flying saucer ufos
	lea	ufo_objects_e370,a0                	| [$1b81: ld   hl,ufo_objects_e370]
	moveq	#0,d3                      	| [$1b84: ld   de,$0000] 0
	* d4 is used as an index which links data from E370 to E300 (jeep params)
	moveq	#0,d4                      	| [$1b84: ld   de,$0000] 0
	* search of a "slot" of some kind
l_1b87:
	move.b	(a0),d0                         	| [$1b87: ld   a,(hl)] -  * J1B94
	                               	| [$1b88: and  a]
	jeq	store_e370_offset_1bc4                             	| [$1b89: jr   z,$1BC4] zero? store offset vs ufo_objects_e370
	sub.b	#0x2F,d0                         	| [$1b8b: sub  $2F]
	jne	l_1b90                             	| [$1b8d: jr   nz,$1B90] 
	addq.b	#1,d3                           	| [$1b8f: inc  d]
l_1b90:
												| [$1b90: ld   a,l] -  * J1B8D,J1BC5
	add.w	#0x10,a0                         	| [$1b91: add  a,$10] next object
												| [$1b93: ld   l,a]
	subq.b	#1,d1                           	| [...]
	jne	l_1b87                             	| [$1b94: djnz $1B87]
	
	move.b	d3,d0                           	| [$1b96: ld   a,d]
	cmp.b	d2,d0                            	| [$1b97: cp   c]
	bcs.b	0f                               	| [...]
	rts                                    	| [$1b98: ret  nc] [...]
0:
	tst.b	d4                           	| [$1b99: inc  e]
											| [$1b9a: dec  e]
	bne.b	0f                               	| [...]
	rts                                    	| [$1b9b: ret  z] [...]
0:
	* reaches here if bombing is decided
	jbsr	osd_get_random                           	| [$1b9c: ld   a,r]
	and.b	#0x0F,d0                         	| [$1b9e: and  $0F]
	add.b	#0x19,d0                         	| [$1ba0: add  a,$19]
	lea	timer_8bit_E04E,a0                	| [$1ba2: ld   hl,timer_8bit_E04E]
	add.b	(a0),d0                          	| [$1ba5: add  a,(hl)]
	move.b	d0,unknown_E0EE                 	| [$1ba6: ld   (unknown_E0EE),a]
	clr.w	d3                               	| [$1ba9: ld   d,$00]
	move.b	d4,d3
	lea	jeep_params_E300,a2                	| [$1bab: ld   ix,jeep_params_E300]
	add.w	d3,a2                            	| [$1baf: add  ix,de]
	lea	unknown_E1D4,a0                	| [$1bb1: ld   hl,unknown_E1D4]
	move.b	(a0),d4                         	| [$1bb4: ld   e,(hl)]
	move.b	d4,d3
	* start of shooting ufos in E400
	lea	unknown_E400,a3                	| [$1bb5: ld   iy,unknown_E400]
	add.w	d3,a3                            	| [$1bb9: add  iy,de]
	move.b	#0x3B,d2                        	| [$1bbb: ld   c,$3B]
	jra	initialize_ufo_shot_1064                             	| [$1bbd: jp   $1064]
l_1bc0:
	move.b	d7,d3                           	| [$1bc0: ld   d,l] -  * J1B5B
	addq.b	#1,d3                           	| [$1bc1: inc  d]
	jra	l_1b5f                             	| [$1bc2: jr   $1B5F]
store_e370_offset_1bc4:
	* memorize index lsb!
	move.l	a0,d4
	sub.l	#jeep_params_E300,d4
	* and return to loop (spaghetti code!) | [$1bc4: ld   e,l] -  * J1B89
	jra	l_1b90                             		  | [$1bc5: jr   $1B90]
handle_flying_enemies_1bc7:
	move.b	timer_8bit_E04E,d0                 	| [$1bc7: ld   a,(timer_8bit_E04E)] -  * C0277
	lea	unknown_E052,a0                	| [$1bca: ld   hl,unknown_E052]
	move.b	(a0),d7
	eor.b	d7,d0                            	| [$1bcd: xor  (hl)]
	and.b	#0x1F,d0                         	| [$1bce: and  $1F]
	beq.b	0f                               	| [...]
	rts                                    	| [$1bd0: ret  nz] [...]
0:
	jbsr	osd_get_random                           	| [$1bd1: ld   a,r]
	move.b	d0,(a0)                         	| [$1bd3: ld   (hl),a]
	lea	unknown_E1C6,a0                	| [$1bd4: ld   hl,unknown_E1C6]
	move.b	#0x03,d1                        	| [$1bd7: ld   b,$03]
l_1bd9:
	move.b	(a0),d0                         	| [$1bd9: ld   a,(hl)] -  * J1BDE
	                               	| [$1bda: and  a]
	jne	l_1be1                             	| [$1bdb: jr   nz,$1BE1]
	addq.w	#1,a0                           	| [$1bdd: inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_1bd9                             	| [$1bde: djnz $1BD9]
	rts                                    	| [$1be0: ret]
l_1be1:
	lea	unknown_E400,a2                	| [$1be1: ld   ix,unknown_E400] -  * J1BDB
	addq.b	#1,d1                           	| [$1be5: inc  b]
	move.b	d1,d0                           	| [$1be6: ld   a,b]
	move.b	d1,d2                           	| [$1be7: ld   c,b]
	move.b	#0x10,d1                        	| [$1be8: ld   b,$10]
	cmp.b	#0x04,d0                         	| [$1bea: cp   $04]
	jeq	l_1bfd                             	| [$1bec: jr   z,$1BFD]
	move.b	unknown_E1D6,d0                 	| [$1bee: ld   a,(unknown_E1D6)]
	subq.b	#1,d0                           	| [$1bf1: dec  a]
	jmi	l_1bfd                             	| [$1bf2: jp   m,$1BFD]
	subq.b	#2,d2                           	| [$1bf5: dec  c] * 2
	lea	ufo_objects_e370,a2                	| [$1bf7: ld   ix,ufo_objects_e370]
	move.b	#MAX_NB_UFOS_1,d1                        	| [$1bfb: ld   b,$05]
l_1bfd:
	move.w	#0x0010,d3                      	| [$1bfd: ld   de,$0010] 16 -  * J1BEC,J1BF2
l_1c00:
	move.b	(a2),d0                    	| [$1c00: ld   a,(ix+$00)] -  * J1C08
	                               	| [$1c03: and  a]
	jeq	l_1c0b                             	| [$1c04: jr   z,$1C0B]
	add.w	d3,a2                            	| [$1c06: add  ix,de]
	subq.b	#1,d1                           	| [...]
	jne	l_1c00                             	| [$1c08: djnz $1C00]
	rts                                    	| [$1c0a: ret]
l_1c0b:
	subq.b	#1,(a0)                         	| [$1c0b: dec  (hl)] -  * J1C04
	move.b	d2,d0                           	| [$1c0c: ld   a,c]
	cmp.b	#0x02,d0                         	| [$1c0d: cp   $02]
	jcc	l_1c54                             	| [$1c0f: jr   nc,$1C54]
	jbsr	osd_get_random                           	| [$1c11: ld   a,r]
	and.b	#0x1F,d0                         	| [$1c13: and  $1F]
	add.b	#0x20,d0                         	| [$1c15: add  a,$20]
	move.b	d0,(obj_timeout,a2)                    	| [$1c17: ld   (ix+$0f),a]
	lea	unknown_E1D6,a0                	| [$1c1a: ld   hl,unknown_E1D6]
	subq.b	#1,(a0)                         	| [$1c1d: dec  (hl)]
l_1c1e:
	jbsr	osd_get_random                           	| [$1c1e: ld   a,r] -  * J1C57
	and.b	#0x1E,d0                         	| [$1c20: and  $1E]
	clr.w	d3                               	| [$1c23: ld   d,$00]
	move.b	d0,d3                           	| [$1c22: ld   e,a]
	move.b	d0,d7
	move.b	#0x82,d0                        	| [$1c27: ld   a,$82]
	cmp.b	#0x0E,d7                         	| [$1c25: cp   $0E]
	jcs	l_1c2f                             	| [$1c29: jr   c,$1C2F]
	jbsr	osd_get_random                           	| [$1c2b: ld   a,r]
	and.b	#0x80,d0                         	| [$1c2d: and  $80]
l_1c2f:
	move.b	d0,(0x0c,a2)                    	| [$1c2f: ld   (ix+$0c),a] -  * J1C29
	lea	game_rom+0x3008,a0                      	| [$1c32: ld   hl,$3008]
	add.w	d3,a0                            	| [$1c35: add  hl,de]
	move.b	(a0),d0                         	| [$1c36: ld   a,(hl)]
	move.b	d0,(obj_y,a2)                    	| [$1c37: ld   (ix+$07),a]
	addq.w	#1,a0                           	| [$1c3a: inc  hl]
	move.b	(a0),d0                         	| [$1c3b: ld   a,(hl)]
	move.b	d0,(obj_x,a2)                    	| [$1c3c: ld   (ix+$03),a]
	clr.w	d1                               	| [$1c3f: ld   b,$00]
	move.b	d2,d1
	lea	game_rom+0x1C59,a0                      	| [$1c41: ld   hl,$1C59]
	add.w	d1,a0                            	| [$1c44: add  hl,bc]
	add.w	d1,a0                            	| [$1c45: add  hl,bc]
	move.b	(a0),d0                         	| [$1c46: ld   a,(hl)]
	move.b	d0,(obj_type,a2)                    	| [$1c47: ld   (ix+$0d),a]
	clr.b	(0x0e,a2)                        	| [$1c4a: ld   (ix+$0e),$00]
	addq.w	#1,a0                           	| [$1c4e: inc  hl]
	move.b	(a0),d0                         	| [$1c4f: ld   a,(hl)]
	move.b	d0,(a2)                    	| [$1c50: ld   (ix+$00),a]
	rts                                    	| [$1c53: ret]
l_1c54:
	jbsr	l_080a                            	| [$1c54: call $080A] -  * J1C0F
	jra	l_1c1e                             	| [$1c57: jr   $1C1E]
animate_ufo_frame_1c63:
	move.b	(obj_type,a2),d0                    	| [$1c63: ld   a,(ix+$0d)]
	subq.b	#1,d2                           	| [$1c65: dec  c]
	cmp.b	#0x2B,d0                         	| [$1c66: cp   $2B]
	bcc.b	0f                               	| [...]
	rts                                    	| [$1c68: ret  c] [...]
0:
	btst.b	#7,(0x0e,a2)                    	| [$1c69: bit  7,(ix+$0e)]
	jne	l_1c87                             	| [$1c6d: jr   nz,$1C87] negative? increase
	subq.b	#1,(0x0e,a2)                    	| [$1c6f: dec  (ix+$0e)]
	bmi.b	0f                               	| [...]
	rts                                    	| [$1c72: ret  p] [...]
0:
	addq.b	#1,(obj_type,a2)                    	| [$1c73: inc  (ix+$0d)]
	cmp.b	#0x2F,d0                         	| [$1c76: cp   $2F]
	jeq	l_1c96                             	| [$1c78: jr   z,$1C96]
	cmp.b	#0x34,d0                         	| [$1c7a: cp   $34]
	jne	l_1c82                             	| [$1c7c: jr   nz,$1C82]
	move.b	#0x31,(obj_type,a2)                 	| [$1c7e: ld   (ix+$0d),$31]
l_1c82:
	move.b	#0x08,(0x0e,a2)                 	| [$1c82: ld   (ix+$0e),$08] -  * J1C7C,J1C90,J1C94
	rts                                    	| [$1c86: ret]
l_1c87:
	addq.b	#1,(0x0e,a2)                    	| [$1c87: inc  (ix+$0e)] -  * J1C6D
	bpl.b	0f                               	| [...]
	rts                                    	| [$1c8a: ret  m] [...]
0:
	subq.b	#1,(obj_type,a2)                    	| [$1c8b: dec  (ix+$0d)]
	cmp.b	#0x2C,d0                         	| [$1c8e: cp   $2C]
	jeq	l_1c82                             	| [$1c90: jr   z,$1C82]
	cmp.b	#0x32,d0                         	| [$1c92: cp   $32]
	jeq	l_1c82                             	| [$1c94: jr   z,$1C82]
l_1c96:
	move.b	#0xF8,(0x0e,a2)                 	| [$1c96: ld   (ix+$0e),$F8] -  * J1C78
	rts                                    	| [$1c9a: ret]
	
init_standard_ufo_bomb_1c9b:
	move.b	(0x04,a2),d6                    	| [$1c9b: ld   l,(ix+$04)]
	move.b	(0x05,a2),d5                    	| [$1c9e: ld   h,(ix+$05)]
	LOAD_D5_16_FROM_D5D6
	lsr.w	#1,d5                            	| [$1ca1: srl  h]
												| [$1ca3: rr   l]
	btst.b	#0,(0x0c,a2)                    	| [$1ca5: bit  0,(ix+$0c)]
	jeq	l_1cb2                             	| [$1ca9: jr   z,$1CB2]
	                              	| [$1cab: ex   de,hl]
	* negate value
									| [$1cac: ld   hl,$0000] 0
	                               	| [$1caf: and  a]
	neg.w	d5                            	| [$1cb0: sbc  hl,de]
l_1cb2:
	LOAD_D5D6_FROM_D5_16	
	move.b	d6,(0x04,a2)                    	| [$1cb2: ld   (ix+$04),l] -  * J1CA9
	move.b	d5,(0x05,a2)                    	| [$1cb5: ld   (ix+$05),h]
	addq.b	#1,(a2)                    	| [$1cb8: inc  (ix+$00)]
	rts                                    	| [$1cbb: ret]
	
* called when bomb falls or explodes (not the same slot when bomb explodes)
update_standard_ufo_bomb_1cbc:
	move.b	#0x3D,d2                        	| [$1cbc: ld   c,$3D]
	move.b	(obj_y_speed,a2),d0                    	| [$1cbe: ld   a,(ix+$09)]
	                               	| [$1cc1: and  a]
	jne	l_1cd7                             	| [$1cc2: jr   nz,$1CD7]
	move.b	#0x3B,d2                        	| [$1cc4: ld   c,$3B]
	move.b	(0x05,a2),d1                    	| [$1cc6: ld   b,(ix+$05)]
	rol.b	#1,d1                           	| [$1cc9: rl   b]
	jcc	l_1ccf                             	| [$1ccb: jr   nc,$1CCF]
	move.b	#0x50,d2                        	| [$1ccd: ld   c,$50]
l_1ccf:
	move.b	(0x08,a2),d0                    	| [$1ccf: ld   a,(ix+$08)] -  * J1CCB
	cmp.b	#0x60,d0                         	| [$1cd2: cp   $60]
	jcs	l_1cd7                             	| [$1cd4: jr   c,$1CD7]
	addq.b	#1,d2                           	| [$1cd6: inc  c]
l_1cd7:
	move.b	d2,(obj_type,a2)                    	| [$1cd7: ld   (ix+$0d),c] -  * J1CC2,J1CD4
	jbsr	copy_object_to_temp_object_20fb                            	| [$1cda: call $20FB]
	move.w	d5,d0                           	| [$1cdd: ld   a,h]
	lsr.w	#8,d0
	cmp.b	#0x06,d0                         	| [$1cde: cp   $06]
	jcs	l_0852                             	| [$1ce0: jp   c,$0852]
	move.w	#0x05,d1                        	| [$1ce3: ld   bc,$0005] 5
l_1ce6:
	STORE_LEW	d5,temp_16bit_x_E0D6                 	| [$1ce6: ld   (temp_16bit_x_E0D6),hl] -  * J1D38
	move.w	d5,d0                           	| [$1ce9: ld   a,h]
	lsr.w	#8,d0
	LOAD_LEW	temp_16bit_y_E0DC,d5             	| [$1cea: ld   hl,(temp_16bit_y_E0DC)]
	add.w	d1,d5                            	| [$1ced: add  hl,bc]
	STORE_LEW	d5,temp_16bit_y_E0DC                 	| [$1cee: ld   (temp_16bit_y_E0DC),hl]
l_1cf1:
	* here D0: ship X
	LOAD_LEW	temp_unknown_16bit_E0DA,d3             	| [$1cf1: ld   de,(temp_unknown_16bit_E0DA)] -  * J20A9
	add.w	d3,d5                            	| [$1cf5: add  hl,de]
	STORE_LEW	d5,temp_unknown_16bit_E0DA                 	| [$1cf6: ld   (temp_unknown_16bit_E0DA),hl]
	rol.w	#8,d5			| get msb
	move.b	d5,d3                           	| [$1cf9: ld   d,h]
	jbsr	compute_ground_object_y_from_x_1538                            	| [$1cfa: call $1538]
	sub.b	#0x08,d0                         	| [$1cfd: sub  $08]
	cmp.b	d3,d0                            	| [$1cff: cp   d]
	jcc	check_if_jeep_vertical_shot_kills_object_1d3a       	| [$1d03: jr   nc,$1D3A]
	jbsr	copy_temp_object_structure_to_object_20ef                            	| [$1d00: call $20EF] inverted jcc and jbsr!
	move.b	d0,(obj_y,a2)                    	| [$1d05: ld   (ix+$07),a]
	addq.b	#1,(obj_command,a2)                    	| [$1d08: inc  (ix+$00)]
	clr.b	(0x0b,a2)                        	| [$1d0b: ld   (ix+$0b),$00]
	move.b	(obj_command,a2),d0                    	| [$1d0f: ld   a,(ix+$00)]
	cmp.b	#0x2A,d0                         	| [$1d12: cp   $2A]
	jne	l_1d1d                             	| [$1d16: jr   nz,$1D1D]
	move.b	#0x02,d0                        	| [$1d14: ld   a,$03] -  Sound effect 3 ... ?? played right after sound effect 2
	move.b	#0x30,(a2)                 	| [$1d18: ld   (ix+$00),$30]
											| [$1d1c: dec  a] -  Sound effect 2 ... missile hitting ground
	bra.b	l_1d1d_2
l_1d1d:
	move.b	#0x03,d0                        	| [$1d14: ld   a,$03] -  Sound effect 3 ... ?? played right after sound effect 2
l_1d1d_2:
	jbsr	queue_sound_effect_if_game_playing_0d75       	| [$1d1d: call $0D75] -  Play missile hitting ground or effect played after that * J1D16
	jra	l_0856                             	| [$1d20: jp   $0856]

	* handle the shots of the blue UFOs that create holes
handle_hole_making_bombs_1d23:
	jbsr	copy_object_to_temp_object_add_x_speed_20db                            	| [$1d23: call $20DB]
	LOAD_LEW	jeep_x_speed_E314,d3             	| [$1d26: ld   de,(jeep_x_speed_E314)]
	* divide value by 2
	asr.w	#1,d3                            	| [$1d2a: sra  d]
	                           	| [$1d2c: rr   e]
	sub.w	d3,d5                            	| [$1d2e: sbc  hl,de]
	                      	| [$1d30: ld   de,$008E]
	sub.w	#0x8E,d5                            	| [$1d33: sbc  hl,de]
												| [$1d35: ld   bc,$0010] 16
	move.w	#0x10,d1                        	| [$1d35: ld   bc,$0010] 16
	jra	l_1ce6                             	| [$1d38: jr   $1CE6]
	
* < a2: UFO structure
check_if_jeep_vertical_shot_kills_object_1d3a:
	jbsr	copy_temp_object_structure_to_object_20ef                            	| [$1d00: call $20EF] (duplicated because of comparison)
	move.b	jeep_params_E300,d0                 	| [$1d3a: ld   a,(jeep_params_E300)] -  * J1D03
	cmp.b	#STATE_FALL_IN_HOLE_06,d0                         	| [$1d3d: cp   $06]
	jcc	draw_object_08b8                             	| [$1d3f: jp   nc,$08B8]
	* dimensions of enemy
	move.b	#6,d5                      	| [$1d42: ld   hl,$0605]
	move.b	#5,d6                      	| [$1d42: ld   hl,$0605]
	move.b	(obj_command,a2),d0                    	| [$1d45: ld   a,(ix+$00)]
	cmp.b	#0x2A,d0                         	| [$1d48: cp   $2A]
	jcc	l_1d4f                             	| [$1d4a: jr   nc,$1D4F]
l_1d4c:
	* different dimension of enemy?
	move.b	#2,d5                      	| [$1d4c: ld   hl,$020B] -  * J1F7B
	move.b	#0xB,d6                      	| [$1d4c: ld   hl,$020B] -  * J1F7B
l_1d4f:
	lea	player_air_shots_E330,a3                | [$1d4f: ld   iy,player_air_shots_E330] -  Start of player air-shots (4 of them, 16 bytes each) * J1D4A
	move.w	#0x0010,d3                      	| [$1d53: ld   de,$0010] 16 -  Each structure is 16 bytes
	move.b	#0x04,d1                        	| [$1d56: ld   b,$04] -  There are 4 structures
l_1d58:
	move.b	(a3),d0                    	| [$1d58: ld   a,(iy+$00)] -  * J1D75
	cmp.b	#0x0F,d0                         	| [$1d5b: cp   $0F]
	jne	l_1d73                             	| [$1d5d: jr   nz,$1D73] -  Not a shot ... move on
	* compare enemy & shot bounding boxes
	move.b	(obj_y,a3),d0                    	| [$1d5f: ld   a,(iy+$07)]
	sub.b	(obj_y,a2),d0                     	| [$1d62: sub  (ix+$07)]
	cmp.b	#0x0A,d0                         	| [$1d65: cp   $0A]
	jcc	l_1d73                             	| [$1d67: jr   nc,$1D73]
	move.b	(obj_x,a3),d0                    	| [$1d69: ld   a,(iy+$03)]
	sub.b	(obj_x,a2),d0                     	| [$1d6c: sub  (ix+$03)]
	sub.b	d5,d0                            	| [$1d6f: sub  h]
	cmp.b	d6,d0                            	| [$1d70: cp   l]
	jcs	ufo_shot_1d9e                             	| [$1d71: jr   c,$1D9E]
l_1d73:
	add.w	d3,a3                            	| [$1d73: add  iy,de] -  Bump to next structure * J1D5D,J1D67
	subq.b	#1,d1                           	| [...]
	jne	l_1d58                             	| [$1d75: djnz $1D58] -  Do all structures
	move.b	jeep_y_offset_E307,d0                 	| [$1d77: ld   a,(buggy_y_e307)]
	sub.b	(obj_y,a2),d0                     	| [$1d7a: sub  (ix+$07)]
	cmp.b	#0xF0,d0                         	| [$1d7d: cp   $F0]
	jcs	draw_object_08b8                             	| [$1d7f: jp   c,$08B8]
	move.b	d0,d3                           	| [$1d82: ld   d,a]
	move.b	jeep_x_E303,d0                 	| [$1d83: ld   a,(buggy_x_e303)]
	sub.b	(obj_x,a2),d0                     	| [$1d86: sub  (ix+$03)]
	subq.b	#0x04,d0                        	| [$1d89: sub  $04]
	cmp.b	#0xEA,d0                         	| [$1d8b: cp   $EA]
	jcs	draw_object_08b8                             	| [$1d8d: jp   c,$08B8]
	jbsr	osd_read_dsw_2                       	| [$1d90: ld   a,($D004)]
	btst.b	#6,d0                           	| [$1d93: bit  6,a] invincibility cheat DSW?
	jeq	draw_object_08b8                             	| [$1d95: jp   z,$08B8]
	jbsr	l_0852                            	| [$1d98: call $0852]
	jra	jeep_killed_16fd                             	| [$1d9b: jp   $16FD]
ufo_shot_1d9e:
	addq.b	#1,(obj_command,a3)                    	| [$1d9e: inc  (iy+$00)] -  ?? From E (initial) to F (moved above) * J1D71
	move.b	(obj_type,a2),d0                    	| [$1da1: ld   a,(ix+$0d)]
	cmp.b	#0x37,d0                         	| [$1da4: cp   $37]
	jcs	l_1db9                             	| [$1da6: jr   c,$1DB9]
	clr.b	(0x0c,a2)                        	| [$1da8: ld   (ix+$0c),$00]
	move.b	#0x2D,(a2)                 	| [$1dac: ld   (ix+$00),$2D]
	move.b	#0x0A,(obj_next_frame_timeout,a2)                 	| [$1db0: ld   (ix+$0a),$0A]
	move.b	#0x4F,(obj_type,a2)                 	| [$1db4: ld   (ix+$0d),$4F]
	rts                                    	| [$1db8: ret]
l_1db9:
	lea	unknown_E1C9,a0                	| [$1db9: ld   hl,unknown_E1C9] -  * J1DA6
	move.b	#0x05,d1                        	| [$1dbc: ld   bc,$0501] 1281
	move.b	#0x01,d2                        	| [$1dbc: ld   bc,$0501] 1281
	cmp.b	#0x31,d0                         	| [$1dbf: cp   $31]
	jcc	l_1dca                             	| [$1dc1: jr   nc,$1DCA]
	addq.w	#1,a0                           	| [$1dc3: inc  hl]
	subq.b	#1,d1                           	| [$1dc4: dec  b]
	cmp.b	#0x2A,d0                         	| [$1dc5: cp   $2A]
	jeq	l_1dca                             	| [$1dc7: jr   z,$1DCA]
	addq.w	#1,a0                           	| [$1dc9: inc  hl]
l_1dca:
	move.b	#0x11,d0                        	| [$1dca: ld   a,$11] -  Play ... * J1DC1,J1DC7
	jbsr	queue_sound_effect_if_game_playing_0d75                            	| [$1dcc: call $0D75] -  ... UFO explosion
	subq.b	#1,(a0)                         	| [$1dcf: dec  (hl)]
	jne	l_1dda                             	| [$1dd0: jr   nz,$1DDA]
	addq.w	#3,a0                           	| [$1dd2: inc  hl] * 3
	move.b	(a0),d0                         	| [$1dd5: ld   a,(hl)]
	cmp.b	#0x03,d0                         	| [$1dd6: cp   $03]
	jcc	l_1deb                             	| [$1dd8: jr   nc,$1DEB]
l_1dda:
	move.b	#0x20,(a2)                 	| [$1dda: ld   (ix+$00),$20] -  * J1DD0
	move.b	#0x06,(obj_next_frame_timeout,a2)                 	| [$1dde: ld   (ix+$0a),$06]
	move.b	#0x37,(obj_type,a2)                 	| [$1de2: ld   (ix+$0d),$37]
	move.b	d1,d0                           	| [$1de6: ld   a,b]
	jbsr	store_special_event_02c2                            	| [$1de7: call $02C2]
	rts                                    	| [$1dea: ret]
l_1deb:
	move.w	#-0x400,d5                      	| [$1deb: ld   hl,-$400] -  * J1DD8
	subq.b	#0x02,d0                        	| [$1dee: sub  $02]
	jra	l_179d                             	| [$1df0: jp   $179D]
hole_making_bomb_explodes_1df3:
	move.b	#0x3E,(obj_type,a2)                 	| [$1df3: ld   (ix+$0d),$3E]
	jbsr	l_1623                            	| [$1df7: call $1623]
	subq.b	#0x03,d0                        	| [$1dfa: sub  $03]
	and.b	#0xF8,d0                         	| [$1dfc: and  $F8]
	addq.b	#0x06,d0                        	| [$1dfe: add  a,$06]
	move.b	d0,(0x0f,a2)                    	| [$1e00: ld   (ix+$0f),a]
l_1e03:
	lea	unknown_E1D1,a0                	| [$1e03: ld   hl,unknown_E1D1] -  * J1E1B
	move.b	(a0),d0                         	| [$1e06: ld   a,(hl)]
	                               	| [$1e07: and  a]
	jeq	l_1e1d                             	| [$1e08: jr   z,$1E1D]
	addq.w	#1,a0                           	| [$1e0a: inc  hl]
	move.b	#0x01,(a0)                      	| [$1e0b: ld   (hl),$01]
	addq.w	#1,a0                           	| [$1e0d: inc  hl]
	move.b	(a0),d0                         	| [$1e0e: ld   a,(hl)]
	                               	| [$1e0f: and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [$1e10: ret  z] [...]
0:
	jra	l_0852                             	| [$1e11: jp   $0852]
init_ground_explosion_1e14:
	move.b	#0x43,(obj_type,a2)                 	| [$1e14: ld   (ix+$0d),$43]
	jbsr	l_1623                            	| [$1e18: call $1623]
	jra	l_1e03                             	| [$1e1b: jr   $1E03]
l_1e1d:
	addq.b	#1,(a0)                         	| [$1e1d: inc  (hl)] -  * J1E08
	addq.b	#1,(a2)                    	| [$1e1e: inc  (ix+$00)]
	move.b	#0x04,(obj_next_frame_timeout,a2)                 	| [$1e21: ld   (ix+$0a),$04]
l_1e25:
	jbsr	update_surface_object_0831                            	| [$1e25: call $0831] -  * J1E3E,J1E4F,J1E5B,J1E81
	rts                                    	| [$1e28: ret]
update_ground_explosion_1e29:
	lea	unknown_E1D2,a0                	| [$1e29: ld   hl,unknown_E1D2]
	move.b	(a0),d0                         	| [$1e2c: ld   a,(hl)]
	addq.w	#1,a0                           	| [$1e2d: inc  hl]
	or.b	(a0),d0                           	| [$1e2e: or   (hl)]
	                               	| [$1e2f: and  a]
	jne	l_0852                             	| [$1e30: jp   nz,$0852]
	move.b	(obj_x,a2),d0                    	| [$1e33: ld   a,(ix+$03)]
	cmp.b	#0xF8,d0                         	| [$1e36: cp   $F8]
	jcc	l_0852                             	| [$1e38: jp   nc,$0852]
	subq.b	#1,(obj_next_frame_timeout,a2)                    	| [$1e3b: dec  (ix+$0a)]
	jne	l_1e25                             	| [$1e3e: jr   nz,$1E25]
	move.b	(obj_type,a2),d0                    	| [$1e40: ld   a,(ix+$0d)]
	cmp.b	#0x49,d0                         	| [$1e43: cp   $49]
	jeq	l_0852                             	| [$1e45: jp   z,$0852]
	addq.b	#1,(obj_type,a2)                    	| [$1e48: inc  (ix+$0d)]
	move.b	#0x05,(obj_next_frame_timeout,a2)                 	| [$1e4b: ld   (ix+$0a),$05]
	jra	l_1e25                             	| [$1e4f: jr   $1E25]
bomb_creates_hole_1e51:
	move.b	unknown_E1D3,d0                 	| [$1e51: ld   a,(unknown_E1D3)]
	                               	| [$1e54: and  a]
	jne	l_0852                             	| [$1e55: jp   nz,$0852]
	subq.b	#1,(obj_next_frame_timeout,a2)                    	| [$1e58: dec  (ix+$0a)]
	jne	l_1e25                             	| [$1e5b: jr   nz,$1E25]
	move.b	(obj_type,a2),d0                    	| [$1e5d: ld   a,(ix+$0d)]
	cmp.b	#0x42,d0                         	| [$1e60: cp   $42]
	jcc	l_1e83                             	| [$1e62: jr   nc,$1E83]
	addq.b	#1,(obj_type,a2)                    	| [$1e64: inc  (ix+$0d)]
	cmp.b	#0x3F,d0                         	| [$1e67: cp   $3F]
	jne	l_1e7d                             	| [$1e69: jr   nz,$1E7D]
	move.b	(0x0f,a2),d0                    	| [$1e6b: ld   a,(ix+$0f)]
	ror.b	#3,d0                           	| [$1e6e: rra] * 3
	and.b	#0x1F,d0                         	| [$1e71: and  $1F]
	move.b	d0,d4                           	| [$1e73: ld   e,a]
	move.b	#0x83,d3                        	| [$1e74: ld   d,$83]
	move.b	#0x09,d2                        	| [$1e76: ld   c,$09]
	move.b	#0x01,d0                        	| [$1e78: ld   a,$01]
	jbsr	store_special_event_02c2                            	| [$1e7a: call $02C2]
l_1e7d:
	move.b	#0x02,(obj_next_frame_timeout,a2)                 	| [$1e7d: ld   (ix+$0a),$02] -  * J1E69
	jra	l_1e25                             	| [$1e81: jr   $1E25]
l_1e83:
	move.b	(obj_y,a2),d0                    	| [$1e83: ld   a,(ix+$07)] -  * J1E62
	add.b	#0x08,d0                         	| [$1e86: add  a,$08]
	move.b	d0,(obj_y,a2)                    	| [$1e88: ld   (ix+$07),a]
	jbsr	l_0856                            	| [$1e8b: call $0856]
	clr.b	(0x0c,a2)                        	| [$1e8e: ld   (ix+$0c),$00]
	move.b	#0x81,(obj_type,a2)                 	| [$1e92: ld   (ix+$0d),$81]
	move.b	#0x13,(a2)                 	| [$1e96: ld   (ix+$00),$13]
	rts                                    	| [$1e9a: ret]
bomb_shot_1e9b:
	subq.b	#1,(obj_next_frame_timeout,a2)                    	| [$1e9b: dec  (ix+$0a)]
	jeq	l_0852                             	| [$1e9e: jp   z,$0852]
	jra	draw_object_08b8                             	| [$1ea1: jp   $08B8]
	
ufo_appearing_1ea4:
	subq.b	#1,(obj_timeout,a2)                    	| [$1ea4: dec  (ix+$0f)]
	* probably never happens, as timeout is very slow
	jeq	ufo_init_crash_on_player_204d                             	| [$1ea7: jp   z,$204D]
	
ufo_appearing_1eaa:
	addq.b	#1,(a2)                    	| [$1eaa: inc  (ix+$00)] -  * J2016 change state to "flying"
	move.b	(0x0c,a2),d0                    	| [$1ead: ld   a,(ix+$0c)]
	asl.b	#1,d0                            	| [$1eb0: sla  a]
	jeq	l_1ef1                             	| [$1eb2: jr   z,$1EF1]

	INVERT_XC_FLAGS                            	| [$1eb4: ccf]
	roxr.b	#1,d0                           	| [$1eb5: rra]
	and.b	#0x80,d0                         	| [$1eb6: and  $80]
	move.b	d0,(0x0c,a2)                    	| [$1eb8: ld   (ix+$0c),a] direction?
	move.b	d0,d2                           	| [$1ebb: ld   c,a]
	jbsr	osd_get_random                           	| [$1ebc: ld   a,r]
	and.b	#0x3F,d0                         	| [$1ebe: and  $3F]
	clr.w	d3                               	| [$1ec1: ld   d,$00]
	move.b	d0,d3                           	| [$1ec0: ld   e,a]
	move.w	#0x0126,d5                      	| [$1ec3: ld   hl,$0126] base x speed
	add.w	d3,d5                            	| [$1ec6: add  hl,de] plus random extra speed
	addq.b	#1,d2                           	| [$1ec7: inc  c]
	jpl	l_1ed2                             	| [$1ec8: jp   p,$1ED2]
												| [$1ecb: ex   de,hl]
										| [$1ecc: and  a]
											| [$1ecd: ld   hl,$0000] 0
	neg.w	d5                            	| [$1ed0: sbc  hl,de]
l_1ed2:
    LOAD_D5D6_FROM_D5_16
	move.b	d5,(obj_x_speed,a2)                    	| [$1ed2: ld   (ix+$05),h] -  * J1EC8
	move.b	d6,(obj_x_speed_decimal,a2)                    	| [$1ed5: ld   (ix+$04),l]
	eor.b	#0x3F,d0                         	| [$1ed8: xor  $3F]
	sub.b	#0x20,d0                         	| [$1eda: sub  $20]
	add.b	d0,d0                            	| [$1edc: add  a,a]
	move.b	d0,(obj_y_speed_decimal,a2)                    	| [$1edd: ld   (ix+$08),a]
	clr.b	d0                               	| [$1ee0: ld   a,$00]
	subx.b	d0,d0                        	| [$1ee2: sbc  a,$00]
	move.b	d0,(obj_y_speed,a2)                    	| [$1ee4: ld   (ix+$09),a]
	jbsr	osd_get_random                           	| [$1ee7: ld   a,r]
	and.b	#0x7F,d0                         	| [$1ee9: and  $7F]
	add.b	#0x20,d0                         	| [$1eeb: add  a,$20]
	move.b	d0,(obj_next_frame_timeout,a2)                    	| [$1eed: ld   (ix+$0a),a]
	rts                                    	| [$1ef0: ret]
	* ufo appears from left
l_1ef1:
	move.b	#0x01,d1                        	| [$1ef1: ld   b,$01] -  * J1EB2
	move.b	(obj_y,a2),d0                    	| [$1ef3: ld   a,(ix+$07)]
	cmp.b	#0x44,d0                         	| [$1ef6: cp   $44]
	jcs	l_1f06                             	| [$1ef8: jr   c,$1F06]
	move.b	#0x03,d1                        	| [$1efa: ld   b,$03]
	cmp.b	#0x58,d0                         	| [$1efc: cp   $58]
	jcc	l_1f06                             	| [$1efe: jr   nc,$1F06]
	jbsr	osd_get_random                           	| [$1f00: ld   a,r]
	and.b	#0x02,d0                         	| [$1f02: and  $02]
	addq.b	#1,d0                           	| [$1f04: inc  a]
	move.b	d0,d1                           	| [$1f05: ld   b,a]
l_1f06:
	move.b	d1,d0                           	| [$1f06: ld   a,b] -  * J1EF8,J1EFE
	add.b	(0x0c,a2),d0                     	| [$1f07: add  a,(ix+$0c)]
	move.b	d0,(0x0c,a2)                    	| [$1f0a: ld   (ix+$0c),a]
	jbsr	osd_get_random                           	| [$1f0d: ld   a,r]
	and.b	#0x0F,d0                         	| [$1f0f: and  $0F]
	add.b	#0x24,d0                         	| [$1f11: add  a,$24]
	move.b	d0,(0x0b,a2)                    	| [$1f13: ld   (ix+$0b),a]
	                      	| [$1f16: ld   hl,$0166]
	move.b	#0x66,(obj_x_speed_decimal,a2)                    	| [$1f19: ld   (ix+$04),l]
	move.b	#0x01,(obj_x_speed,a2)                    	| [$1f1c: ld   (ix+$05),h]
	clr.b	(obj_y_speed_decimal,a2)                        	| [$1f1f: ld   (ix+$08),$00]
	clr.b	(obj_y_speed,a2)                        	| [$1f23: ld   (ix+$09),$00]
	rts                                    	| [$1f27: ret]
	
* used for UFOs (any kind) when attacking player
* one of the slots used can be E370 (7th slot)
animate_ufo_1f28:
	jbsr	animate_ufo_frame_1c63                            	| [$1f28: call $1C63] -  * C2009
	jbsr	copy_object_to_temp_object_add_x_speed_20db                            	| [$1f2b: call $20DB]
	move.b	(0x0c,a2),d0                    	| [$1f2e: ld   a,(ix+$0c)]
	asl.b	#1,d0                            	| [$1f31: sla  a]
	jne	l_1f87                             	| [$1f33: jr   nz,$1F87]
	subq.b	#1,(obj_next_frame_timeout,a2)                    	| [$1f35: dec  (ix+$0a)]
	jeq	l_1f83                             	| [$1f38: jr   z,$1F83]
	LOAD_LEW	temp_16bit_x_E0D6,d5             	| [$1f3a: ld   hl,(temp_16bit_x_E0D6)]
	LOAD_LEW	temp_16bit_x_speed_E0D8,d3             	| [$1f3d: ld   de,(temp_16bit_x_speed_E0D8)]
 	add.w	d3,d5                            	| [$1f41: add  hl,de]
	move.w	d3,d0                           	| [$1f42: ld   a,d]
	lsr.w	#8,d0
	LOAD_LEW	jeep_damping_force_16bit_E304,d3             	| [$1f43: ld   de,(jeep_damping_force_16bit_E304)]
	sub.w	d3,d5                            	| [$1f47: sbc  hl,de]
	STORE_LEW	d5,temp_16bit_x_E0D6                 	| [$1f49: ld   (temp_16bit_x_E0D6),hl]
	roxl.b	#1,d0                           	| [$1f4c: rla]
	jcs	l_1f7e                             	| [$1f4d: jr   c,$1F7E]
	move.b	(obj_type,a2),d0                    	| [$1f4f: ld   a,(ix+$0d)]
	move.b	#0xA0,d1                        	| [$1f52: ld   b,$A0]
	sub.b	#0x2A,d0                         	| [$1f54: sub  $2A]
	jeq	l_1f60                             	| [$1f56: jr   z,$1F60]
	move.b	#0x80,d1                        	| [$1f58: ld   b,$80]
	subq.b	#0x07,d0                        	| [$1f5a: sub  $07]
	jcs	l_1f60                             	| [$1f5c: jr   c,$1F60]
	move.b	#0xD0,d1                        	| [$1f5e: ld   b,$D0]
l_1f60:
	move.w	d5,d0                           	| [$1f60: ld   a,h] -  * J1F56,J1F5C
	lsr.w	#8,d0
	cmp.b	d1,d0                            	| [$1f61: cp   b]
	jcc	l_1f83                             	| [$1f62: jr   nc,$1F83]
l_1f64:
	LOAD_LEW	temp_unknown_16bit_E0DA,d5             	| [$1f64: ld   hl,(temp_unknown_16bit_E0DA)] -  * J1F81
	LOAD_LEW	temp_16bit_y_E0DC,d3             	| [$1f67: ld   de,(temp_16bit_y_E0DC)]
	add.w	d3,d5                            	| [$1f6b: add  hl,de]
	STORE_LEW	d5,temp_unknown_16bit_E0DA                 	| [$1f6c: ld   (temp_unknown_16bit_E0DA),hl]
	move.w	d5,d0                           	| [$1f6f: ld   a,h]
	lsr.w	#8,d0
	cmp.b	#0x38,d0                         	| [$1f70: cp   $38]
	jcs	l_1f83                             	| [$1f72: jr   c,$1F83]
	cmp.b	#0x70,d0                         	| [$1f74: cp   $70]
	jcc	l_1f83                             	| [$1f76: jr   nc,$1F83]
l_1f78:
	jbsr	copy_temp_object_structure_to_object_20ef                            	| [$1f78: call $20EF] -  * J1FE8,J203E,J204A
	jra	l_1d4c                             	| [$1f7b: jp   $1D4C]
l_1f7e:
	move.w	d5,d0                           	| [$1f7e: ld   a,h] -  * J1F4D
	lsr.w	#8,d0
	cmp.b	#0x16,d0                         	| [$1f7f: cp   $16]
	jcc	l_1f64                             	| [$1f81: jr   nc,$1F64]
l_1f83:
	subq.b	#1,(a2)                    	| [$1f83: dec  (ix+$00)] -  * J1F38,J1F62,J1F72,J1F76,J1FD4,J2011
	rts                                    	| [$1f86: ret]
l_1f87:
	LOAD_LEW	temp_16bit_x_speed_E0D8,d5             	| [$1f87: ld   hl,(temp_16bit_x_speed_E0D8)] -  * J1F33
	clr.w	d3                               	| [$1f8d: ld   d,$00]
	move.b	(0x0b,a2),d3                    	| [$1f8a: ld   e,(ix+$0b)]
	move.w	d5,d7                               	| [$1f8f: and  a]
	sub.w	d3,d7                            	| [$1f90: sbc  hl,de]
	STORE_LEW	d7,temp_16bit_x_speed_E0D8                 	| [$1f92: ld   (temp_16bit_x_speed_E0D8),hl]
	
	
	* redo sub to get flags as move clears carry
	sub.w	d3,d5                            	| [$1f90: sbc  hl,de]
	jcc	l_1fad                             	| [$1f95: jr   nc,$1FAD]
	move.b	(0x03,a2),d0                    	| [$1f97: ld   a,(ix+$03)]
	sub.b	#0x30,d0                         	| [$1f9a: sub  $30]
	cmp.b	#0x40,d0                         	| [$1f9c: cp   $40]
	jcc	l_1fa6                             	| [$1fa0: jr   nc,$1FA6]
	jbsr	osd_get_random                           	| [$1fa2: ld   a,r]
	and.b	#0x80,d0                         	| [$1fa4: and  $80]
	jra		l_1fa6_2
l_1fa6:
	clr.b	d0                               	| [$1f9e: ld   a,$00]
l_1fa6_2:
	add.b	(0x0c,a2),d0                     	| [$1fa6: add  a,(ix+$0c)] -  * J1FA0
	addq.b	#1,d0                           	| [$1fa9: inc  a]
	move.b	d0,(0x0c,a2)                    	| [$1faa: ld   (ix+$0c),a]
l_1fad:
	* apply X speed
	exg	d3,d5                              	| [$1fad: ex   de,hl] -  * J1F95
	LOAD_LEW	temp_16bit_x_E0D6,d5             	| [$1fae: ld   hl,(temp_16bit_x_E0D6)]
	sub.w	d3,d5                            	| [$1fb1: sbc  hl,de] sub
	move.b	(0x0c,a2),d0                    	| [$1fb3: ld   a,(ix+$0c)]
	rol.b	#1,d0                            	| [$1fb6: rlca]
	jcs	l_1fbb                             	| [$1fb7: jr   c,$1FBB] not that direction
	add.w	d3,d5                            	| [$1fb9: add  hl,de] cancel previous sub
	add.w	d3,d5                            	| [$1fba: add  hl,de] and add
l_1fbb:
	LOAD_LEW	jeep_damping_force_16bit_E304,d3             	| [$1fbb: ld   de,(jeep_damping_force_16bit_E304)] -  * J1FB7
	sub.w	d3,d5                            	| [$1fbf: sbc  hl,de]
	STORE_LEW	d5,temp_16bit_x_E0D6                 	| [$1fc1: ld   (temp_16bit_x_E0D6),hl]
	LOAD_LEW	temp_16bit_y_E0DC,d5             	| [$1fc4: ld   hl,(temp_16bit_y_E0DC)]
	clr.w	d3                               	| [$1fca: ld   d,$00]
	move.b	(0x0b,a2),d3                    	| [$1fc7: ld   e,(ix+$0b)]
	ror.b	#1,d0                            	| [$1fcc: rrca]
	subq.b	#1,d0                           	| [$1fcd: dec  a]
	ror.b	#1,d0                            	| [$1fce: rrca]
	jcc	l_1feb                             	| [$1fcf: jr   nc,$1FEB]
											| [$1fd1: and  a]
	sub.w	d3,d5                            	| [$1fd2: sbc  hl,de]
	jcs	l_1f83                             	| [$1fd4: jr   c,$1F83]
l_1fd6:
	* apply Y speed
	STORE_LEW	d5,temp_16bit_y_E0DC                 	| [$1fd6: ld   (temp_16bit_y_E0DC),hl] -  * J1FEC
	exg	d3,d5                              	| [$1fd9: ex   de,hl]
	LOAD_LEW	temp_unknown_16bit_E0DA,d5             	| [$1fda: ld   hl,(temp_unknown_16bit_E0DA)]
											| [$1fdd: and  a]
	sub.w	d3,d5                            	| [$1fde: sbc  hl,de] sub then
	ror.b	#1,d0                            	| [$1fe0: rrca]		test add or sub
	jcs	l_1fe5                             	| [$1fe1: jr   c,$1FE5]
	add.w	d3,d5                            	| [$1fe3: add  hl,de] make up for sub
	add.w	d3,d5                            	| [$1fe4: add  hl,de] add
l_1fe5:
	* change ?? (seems not used) and Y
	STORE_LEW	d5,temp_unknown_16bit_E0DA                 	| [$1fe5: ld   (temp_unknown_16bit_E0DA),hl] -  * J1FE1
	jra	l_1f78                             	| [$1fe8: jp   $1F78]
l_1feb:
	add.w	d3,d5                            	| [$1feb: add  hl,de] -  * J1FCF
	jra	l_1fd6                             	| [$1fec: jr   $1FD6]

ufo_appearing_2000:
	addq.b	#1,(a2)                    	| [$2000: inc  (ix+$00)]
	move.b	(0x0c,a2),d0                    	| [$2003: ld   a,(ix+$0c)]
	and.b	#0x7F,d0                         	| [$2006: and  $7F]
	bne.b	0f                               	| [...]
	rts                                    	| [$2008: ret  z] [...]
0:
	jbsr	animate_ufo_1f28                            	| [$2009: call $1F28]
	move.b	(a2),d0                    	| [$200c: ld   a,(ix+$00)]
	cmp.b	#0x25,d0                         	| [$200f: cp   $25]
	jeq	l_1f83                             	| [$2011: jp   z,$1F83]
	cmp.b	#0x24,d0                         	| [$2014: cp   $24]
	jeq	ufo_appearing_1eaa                             	| [$2016: jp   z,$1EAA]
	rts                                    	| [$2019: ret]
animate_ufo_201a:
	jbsr	animate_ufo_frame_1c63                            	| [$201a: call $1C63]
	jbsr	copy_object_to_temp_object_add_x_speed_20db                            	| [$201d: call $20DB]
	STORE_LEW	d5,temp_16bit_x_E0D6                 	| [$2020: ld   (temp_16bit_x_E0D6),hl]
	move.w	d5,d0                           	| [$2023: ld   a,h]
	lsr.w	#8,d0
	sub.w	#0x08,d0                         	| [$2024: sub  $08]
	cmp.w	#0xF0,d0                         	| [$2026: cp   $F0]
	jcc	l_0852                             	| [$2028: jp   nc,$0852]
	LOAD_LEW	temp_16bit_y_E0DC,d3             	| [$202b: ld   de,(temp_16bit_y_E0DC)]
	LOAD_LEW	temp_unknown_16bit_E0DA,d5             	| [$202f: ld   hl,(temp_unknown_16bit_E0DA)]
	add.w	d3,d5                            	| [$2032: add  hl,de]
	STORE_LEW	d5,temp_unknown_16bit_E0DA                 	| [$2033: ld   (temp_unknown_16bit_E0DA),hl]
	move.w	d5,d0                           	| [$2036: ld   a,h]
	cmp.w	#0x3000,d0                         	| [$2037: cp   $30]
	jcs	l_0852                             	| [$2039: jp   c,$0852]
	tst.w	d3                           	| [$203c: ld   a,d]
	                               	| [$203d: and  a]
	jmi	l_1f78                             	| [$203e: jp   m,$1F78]
	move.w	#0x0000,d5                      	| [$2041: ld   hl,$0000] 0
	                               	| [$2044: and  a]
	sub.w	d3,d5                            	| [$2045: sbc  hl,de]
	STORE_LEW	d5,temp_16bit_y_E0DC                 	| [$2047: ld   (temp_16bit_y_E0DC),hl]
	jra	l_1f78                             	| [$204a: jp   $1F78]
	
ufo_init_crash_on_player_204d:
	* compute x speed to try to aim the player with a constant x speed
	move.b	jeep_x_E303,d0                 	| [$204d: ld   a,(buggy_x_e303)] -  * J1EA7
	clr.b	d3                               	| [$2050: ld   d,$00]
	add.b	#0x10,d0                         	| [$2052: add  a,$10]
	sub.b	(obj_x,a2),d0                     	| [$2054: sub  (ix+$03)]
	jcc	l_205c                             	| [$2057: jr   nc,$205C]
	neg.b	d0                               	| [$2059: neg]
	subq.b	#1,d3                           	| [$205b: dec  d]
	SET_XC_FLAGS
l_205c:
	roxr.b	#3,d0                           	| [$205c: rra] -  * J2057
												| [$205d: rra] * 2
	and.b	#0x1E,d0                         	| [$205f: and  $1E]
	clr.w	d1                               	| [$2062: ld   b,$00]
	move.b	d0,d1                           	| [$2061: ld   c,a]
	* load slope table / tangent whatever
	* probably assuming average ufo y pos
	lea	game_rom+0x2D24,a0                      	| [$2064: ld   hl,$2D24]
	add.w	d1,a0                            	| [$2067: add  hl,bc]
	cmp.b	#0x12,d0                         	| [$2068: cp   $12]
	jcs	l_206d                             	| [$206a: jr   c,$206D]
	add.w	#0x100,d1                           	| [$206c: inc  b]
l_206d:
	rol.w	#8,d1			| we need b not bc from now on, else x speed is wrong, damn bug!!!
	move.b	(a0),d0                         	| [$206d: ld   a,(hl)] -  * J206A
	btst.b	#7,d3                           	| [$206e: bit  7,d]
	jeq	l_2078                             	| [$2070: jr   z,$2078]
	not.b	d0                               	| [$2072: cpl]
	move.b	d0,d4                           	| [$2073: ld   e,a]
	move.b	d1,d0                           	| [$2074: ld   a,b]
	not.b	d0                               	| [$2075: cpl]
	move.b	d0,d1                           	| [$2076: ld   b,a]
	move.b	d4,d0                           	| [$2077: ld   a,e]
l_2078:
	move.b	d0,(obj_x_speed_decimal,a2)                    	| [$2078: ld   (ix+$04),a] -  * J2070
	move.b	d1,(obj_x_speed,a2)                    	| [$207b: ld   (ix+$05),b]
	addq.w	#1,a0                           	| [$207e: inc  hl]
	move.b	(a0),d4                         	| [$207f: ld   e,(hl)]
	clr.b	d3                               	| [$2080: ld   d,$00]
	move.b	d2,d0                           	| [$2082: ld   a,c]
	cmp.b	#0x0A,d0                         	| [$2083: cp   $0A]
	jcc	l_2088                             	| [$2085: jr   nc,$2088]
	addq.b	#1,d3                           	| [$2087: inc  d]
l_2088:
	move.b	d3,(obj_y_speed,a2)                    	| [$2088: ld   (ix+$09),d] -  * J2085
	move.b	d4,(obj_y_speed_decimal,a2)                    	| [$208b: ld   (ix+$08),e]
	* change UFO state to "crashing on player", will trigger ufo_crashing_on_player_209c
	move.b	#0x29,(a2)                 	| [$208e: ld   (ix+$00),$29]
	
l_2092:
	LOAD_LEW	jeep_x_speed_E31A,d5             	| [$2092: ld   hl,(jeep_x_speed_E31A)] -  * C108D
	LOAD_D5D6_FROM_D5_16
	* store 2 value nibbles
	move.b	d6,(0x0b,a2)                    	| [$2095: ld   (ix+$0b),l]
	move.b	d5,(obj_timeout,a2)                    	| [$2098: ld   (ix+$0f),h]
	rts                                    	| [$209b: ret]
	
ufo_crashing_on_player_209c:
	jbsr	animate_ufo_frame_1c63                            	| [$209c: call $1C63]
	jbsr	copy_object_to_temp_object_20fb                            	| [$209f: call $20FB]
	STORE_LEW	d5,temp_16bit_x_E0D6                 	| [$20a2: ld   (temp_16bit_x_E0D6),hl]
	move.w	d5,d0                           	| [$20a5: ld   a,h]
	lsr.w	#8,d0								| D0 = ship X
	LOAD_LEW	temp_16bit_y_E0DC,d5             	| [$20a6: ld   hl,(temp_16bit_y_E0DC)]
	jra	l_1cf1                             	| [$20a9: jp   $1CF1]
	
ufo_shot_20ac:
	subq.b	#1,(obj_next_frame_timeout,a2)                    	| [$20ac: dec  (ix+$0a)]
	jne	draw_object_08b8                             	| [$20af: jp   nz,$08B8]
	move.b	#0x06,(obj_next_frame_timeout,a2)                 	| [$20b2: ld   (ix+$0a),$06]
	move.b	(obj_type,a2),d0                    	| [$20b6: ld   a,(ix+$0d)]
	cmp.b	#0x39,d0                         	| [$20b9: cp   $39]
	jcc	l_0852                             	| [$20bb: jp   nc,$0852]
	addq.b	#1,(obj_type,a2)                    	| [$20be: inc  (ix+$0d)]
	jra	draw_object_08b8                             	| [$20c1: jp   $08B8]
	
show_kill_score_20c4:
	subq.b	#1,(obj_next_frame_timeout,a2)                    	| [$20c4: dec  (ix+$0a)]
	jne	draw_object_08b8                             	| [$20c7: jp   nz,$08B8]
	move.b	(obj_y,a2),d0                    	| [$20ca: ld   a,(ix+$07)]
	cmp.b	#0x80,d0                         	| [$20cd: cp   $80]
	jcc	l_0852                             	| [$20cf: jp   nc,$0852]
	move.b	#0x80,d1                        	| [$20d2: ld   b,$80]
	clr.b	(a2)                        	| [$20d4: ld   (ix+$00),$00]
	jra	l_0869                             	| [$20d8: jp   $0869]
	
* > D5: 16 bit value of ??
copy_object_to_temp_object_add_x_speed_20db:
	move.l	a2,a0                        	| [$20db: push ix] -  * C1433,C1D23,C1F2B,C201D,C20FB
											| [$20dd: pop  hl]
	lea	temp_object_structure_E0D4,a1                	| [$20de: ld   de,temp_object_structure_E0D4]
	move.w	#0x0a,d1                        	| [$20e1: ld   bc,$000A] 10
	jbsr	ldir                              	| [$20e4: ldir]
	* contains fine X (offset 3: msb, displayed, offset 2: lsb, "decimals" of value)
	LOAD_LEW	temp_16bit_x_E0D6,d3             	| [$20e6: ld   de,(temp_16bit_x_E0D6)]
	LOAD_LEW	temp_16bit_x_speed_E0D8,d5             	| [$20ea: ld   hl,(temp_16bit_x_speed_E0D8)]
	add.w	d3,d5                            	| [$20ed: add  hl,de]
	rts                                    	| [$20ee: ret]
	
* after game fiddles with temp object structure
* called to copy data into actual object struct in a2 (10 first bytes only)
copy_temp_object_structure_to_object_20ef:
	move.l	a2,a1                        	| [$20ef: push ix] -  * J1487,C1D00,C1F78
	                        	| [$20f1: pop  de]
	lea	temp_object_structure_E0D4,a0                	| [$20f2: ld   hl,temp_object_structure_E0D4]
	move.w	#0x0a,d1                        	| [$20f5: ld   bc,$000A] 10
	jbsr	ldir                              	| [$20f8: ldir]
	rts                                    	| [$20fa: ret]
	
copy_object_to_temp_object_20fb:
	jbsr	copy_object_to_temp_object_add_x_speed_20db                            	| [$20fb: call $20DB] -  * C1CDA,C209F
	exg	d3,d5                              	| [$20fe: ex   de,hl]
	* recompose 2 value nibbles of stored jeep speed when copied
	* (then jeep speed may change)
	move.b	(0x0f,a2),d5                    	| [$2102: ld   h,(ix+$0f)]
	lsl.w	#8,d5
	move.b	(0x0b,a2),d5                    	| [$20ff: ld   l,(ix+$0b)]
	LOAD_LEW	jeep_x_speed_E31A,d1            	| [$2105: ld   bc,(jeep_x_speed_E31A)] None
	sub.w	d1,d5                            	| [$2109: sbc  hl,bc]
 	add.w	d3,d5                            	| [$210b: add  hl,de]
	rts                                    	| [$210c: ret]
	
handle_time_210d:
	lea	isr_count4_e051,a0                	| [$210d: ld   hl,isr_count4_e051]
	move.b	jeep_params_E300,d0                 	| [$2110: ld   a,(jeep_params_E300)]
	subq.b	#1,d0                           	| [$2113: dec  a]
	jeq	l_2127                             	| [$2114: jr   z,$2127]
	move.b	(a0),d0                         	| [$2116: ld   a,(hl)]
	                               	| [$2117: and  a]
	bmi.b	0f                               	| [...]
	rts                                    	| [$2118: ret  p] [...]
0:
	lea	time_bcd_E511,a0               	| [$2119: ld   hl,time_bcd_E511]
	move.b	#0x01,d0                        	| [$211c: ld   a,$01]
	CLEAR_XC_FLAGS
	move.b	(a0),d7
	abcd	d7,d0                          	| [$211e: add  a,(hl) + daa]
	move.b	d0,(a0)+                         	| [$2120: ld   (hl),a]
	                           	| [$2121: inc  hl]
	move.b	(a0),d0                         	| [$2122: ld   a,(hl)]
	moveq	#0,d7
	abcd	d7,d0				| [adc  a,$00 + daa]
	move.b	d0,(a0)                         	| [$2126: ld   (hl),a]
l_2127:
	move.b	#0x37,d0                        	| [$2127: ld   a,$37] -  * J2114
	move.b	d0,isr_count4_e051                 	| [$2129: ld   (isr_count4_e051),a]
display_time_212c:
	lea	0x8090,a1                      	| [$212c: ld   de,$8090] -  * C0D0C
	lea	0x8490,a3                      	| [$212f: ld   iy,$8490]
	move.b	#0x02,d2                        	| [$2133: ld   c,$02]
	jbsr	trans_color_03e7                            	| [$2135: call $03E7]
	move.b	unknown_E512,d0                 	| [$2138: ld   a,(unknown_E512)]
	jbsr	print_digit_03bd                            	| [$213b: call $03BD]
	move.b	time_bcd_E511,d0                	| [$213e: ld   a,(time_bcd_E511)]
	jra	set_character_at_address_03ae                             	| [$2141: jp   $03AE]

section_completed_27c0:
	* section or course completed
	lea	game_status_bits_E046,a0                	| [$27c0: ld   hl,game_status_bits_E046] -  * J1516,J151D
	subq.b	#1,(a0)                         	| [$27c3: dec  (hl)]
    jbsr  osd_enable_interrupts  | [ei]
	move.b	d1,d0                           	| [$27c5: ld   a,b]
	move.b	d0,unknown_E513                 	| [$27c6: ld   (unknown_E513),a]
	tst.b	section_completed_flag
	jne		l_285e
	clr.b	section_completed_flag
	clr.b	course_completed_flag

	cmp.b	#0x05,d0                         	| [$27c9: cp   $05]
	jeq	l_27d2                             	| [$27cb: jp   z,$27D2]
	tst.b	d0                               	| [$27ce: and  a]
	jne	l_285e                             	| [$27cf: jp   nz,$285E]
l_27d2:
	jbsr	fill_done_section_in_map_29fa                            	| [$27d2: call $29FA] -  * J27CB
	move.b	#0x1E,d0                        	| [$27d5: ld   a,$1E] -  Play end of level sound
	jbsr	queue_sound_effect_if_game_playing_0d75                            	| [$27d7: call $0D75] -  ... congratulations music
	lea	moonbase_already_displayed_E50F,a0                	| [$27da: ld   hl,moonbase_already_displayed_E50F]
	clr.b	(a0)+                             	| [$27dd: ld   (hl),$00]
	                           	| [$27df: inc  hl] -  Now E510
	addq.b	#1,(a0)                         	| [$27e0: inc  (hl)] -  Increment the course number
	jbsr	l_2948                            	| [$27e1: call $2948]
	jbsr	delay3_sec_05e8                            	| [$27e4: call $05E8]
	lea	game_rom+0x2C24,a0                      	| [$27e7: ld   hl,$2C24] -  "CONGRATULATIONS" script
	jbsr	write_to_screen_possible_typing_effect_300                            	| [$27ea: call $0300]
	jbsr	display_section_results_28ba                            	| [$27ed: call $28BA]
	lea	game_rom+0x2C0C,a0                      	| [$27f0: ld   hl,$2C0C] -  "SPECIAL BOUNS POINTS" script
	jbsr	write_to_screen_possible_typing_effect_300                            	| [$27f3: call $0300]
	move.b	unknown_E513,d0                 	| [$27f6: ld   a,(unknown_E513)]
l_27f9:
	rol.b	#4,d0                           	| [$27f9: rla] 4 -  * J2880
	clr.w	d5                               	| [$27fd: ld   h,$00]
	and.b	#0xF0,d0                         	| [$27ff: and  $F0]
	move.b	d0,d5                           	| [$2801: ld   l,a]
	tst.b	d0
	jne	l_2805                             	| [$2802: jr   nz,$2805]
	add.w	#0x100,d5                           	| [$2804: inc  h]
l_2805:
	STORE_LEW	d5,unknown_16bit_E098                 	| [$2805: ld   (unknown_16bit_E098),hl] -  * J2802
	jbsr	display_good_bonus_points_2971                            	| [$2808: call $2971]
	move.l	unknown_pointer_E096,a0             	| [$280b: ld   hl,(unknown_pointer_E096)]
	move.b	(a0),d3                         	| [$280e: ld   d,(hl)]
	                           	| [$280f: dec  hl]
	move.b	-(a0),d4                         	| [$2810: ld   e,(hl)]
	LOAD_D3_16_FROM_D3D4
	LOAD_LEW	time_bcd_E511,d5            	| [$2811: ld   hl,(time_bcd_E511)]
	                               	| [$2814: and  a]
	sub.w	d3,d5                            	| [$2815: sbc  hl,de]
	jcc	l_2827                             	| [$2817: jr   nc,$2827]
	add.w	d3,d5                            	| [$2819: add  hl,de]
	exg	d3,d5                             	| [$281a: ex   de,hl]
	move.l	unknown_pointer_E096,a0             	| [$281b: ld   hl,(unknown_pointer_E096)]
	LOAD_D3D4_FROM_D3_16
	move.b	d3,(a0)                         	| [$281e: ld   (hl),d]
	                           	| [$281f: dec  hl]
	move.b	d4,-(a0)                         	| [$2820: ld   (hl),e]
	lea	game_rom+0x2C39,a0                      	| [$2821: ld   hl,$2C39] -  "YOU HAVE BROKEN A RECORD" script
	jbsr	write_text_to_screen_at_xy_with_delay_034e                            	| [$2824: call $034E]
l_2827:
	LOAD_LEW	course_section_record_E094,d5             	| [$2827: ld   hl,(course_section_record_E094)] -  * J2817,J285C
	LOAD_LEW	time_bcd_E511,d3            	| [$282a: ld   de,(time_bcd_E511)]
	CLEAR_XC_FLAGS
	move.b	#1,d0                           	| [$282e: ld   a,l]
	sbcd	d0,d5                        	| [$282f: sub  $01 + daa]

	                           	| [$2832: ld   l,a]
	jcc	l_2836                             	| [$2833: jr   nc,$2836]
	sub.w	#0x100,d5                           	| [$2835: dec  h]
l_2836:
	STORE_LEW	d5,course_section_record_E094                 	| [$2836: ld   (course_section_record_E094),hl] -  * J2833
	                               	| [$2839: and  a]
	sub.w	d3,d5                            	| [$283a: sbc  hl,de]
	jcs	l_288e                             	| [$283c: jr   c,$288E]
	jbsr	write_course_section_record_2968                            	| [$283e: call $2968]
	LOAD_LEW	unknown_16bit_E098,d5             	| [$2841: ld   hl,(unknown_16bit_E098)]
	CLEAR_XC_FLAGS
	move.b	#1,d0                           	| [$2844: ld   a,l]
	abcd	d0,d5                        	| [$2845: add  a,$01 + daa]
	                           	| [$2848: ld   l,a]
	jcc	l_284c                             	| [$2849: jr   nc,$284C]
	add.w	#0x100,d5                           	| [$284b: inc  h]
l_284c:
	STORE_LEW	d5,unknown_16bit_E098                 	| [$284c: ld   (unknown_16bit_E098),hl] -  * J2849
	jbsr	display_good_bonus_points_2971                            	| [$284f: call $2971]
	move.b	#0x10,d0                        	| [$2852: ld   a,$10] -  Play
	jbsr	queue_sound_effect_if_game_playing_0d75                            	| [$2854: call $0D75] -  ... passing point
	move.b	#0x0C,d0                        	| [$2857: ld   a,$0C]
	jbsr	wait_for_sync_05ea                            	| [$2859: call $05EA]
	jra	l_2827                             	| [$285c: jr   $2827]
l_285e:
	clr.b	section_completed_flag
	clr.b	course_completed_flag
	move.b	#0x1D,d0                        	| [$285e: ld   a,$1D] -  Play ... * J27CF
	jbsr	queue_sound_effect_if_game_playing_0d75                            	| [$2860: call $0D75] -  ... reached goal
	jbsr	l_29d6                            	| [$2863: call $29D6]
	jbsr	l_0d12                            	| [$2866: call $0D12]
	jbsr	l_2948                            	| [$2869: call $2948]
	move.b	#0x30,d0                        	| [$286c: ld   a,$30]
	jbsr	wait_for_sync_05ea                            	| [$286e: call $05EA]
	jbsr	display_section_results_28ba                            	| [$2871: call $28BA]
	jcs	l_2883                             	| [$2874: jr   c,$2883]
	* better than section best time
	lea	game_rom+0x2BE4,a0                      	| [$2876: ld   hl,$2BE4] -  "GOOD BONUS POINTS" script
	jbsr	write_text_to_screen_at_xy_with_delay_034e                            	| [$2879: call $034E]
	move.b	champ_colors_e0f9,d0                 	| [$287c: ld   a,(champ_colors_e0f9)]
	addq.b	#1,d0                           	| [$287f: inc  a]
	jra	l_27f9                             	| [$2880: jp   $27F9]
l_2883:
	* not better than section best time
	lea	game_rom+0x2BF9,a0                      	| [$2883: ld   hl,$2BF9] -  "SORRY NO BONUS" script * J2874
	jbsr	write_text_to_screen_at_xy_with_delay_034e                            	| [$2886: call $034E]
	jbsr	delay3_sec_05e8                            	| [$2889: call $05E8]
	jra	l_289c                             	| [$288c: jr   $289C]
l_288e:
	jbsr	delay3_sec_05e8                            	| [$288e: call $05E8] -  * J283C
	lea	cur_score1_e501,a1                	| [$2891: ld   de,cur_score1_e501]
	lea	unknown_16bit_E098,a0                	| [$2894: ld   hl,unknown_16bit_E098]
	move.b	#0x02,d1                        	| [$2897: ld   b,$02]
	jbsr	l_0636                            	| [$2899: call $0636]
l_289c:
										| [$289c: ld   hl,$0000] 0 -  * J288C
	CLR_W	time_bcd_E511                	| [$289f: ld   (time_bcd_E511),hl]
	lea	unknown_E513,a0                	| [$28a2: ld   hl,unknown_E513]
	move.b	(a0),d0                         	| [$28a5: ld   a,(hl)]
	                               	| [$28a6: and  a]
	jne	start_new_section_0bb7                             	| [$28a7: jp   nz,$0BB7]
	move.b	#0x05,(a0)                      	| [$28aa: ld   (hl),$05]
	* champion track data
	lea	game_rom+0x23A2,a0                      	| [$28ac: ld   hl,$23A2]
	move.l	a0,track_events_data_pointer_E516                 	| [$28af: ld   (track_events_data_pointer_E516),hl]
	move.b	#0x1A,d0                        	| [$28b2: ld   a,$1A]
	move.b	d0,cur_point_e50e                 	| [$28b4: ld   (cur_point_e50e),a]
	jra	start_new_section_0bb7                             	| [$28b7: jp   $0BB7]
display_section_results_28ba:
	jbsr	delay3_sec_05e8                            	| [$28ba: call $05E8] -  * C27ED,C2871
	jbsr	l_295a                            	| [$28bd: call $295A]
	move.b	current_level_E510,d0                	| [$28c0: ld   a,(current_level_E510)] -  Course number
	subq.b	#0x02,d0                        	| [$28c3: sub  $02]
	jeq	l_28ce                             	| [$28c5: jr   z,$28CE]
	jmi	l_28ce                             	| [$28c9: jp   m,$28CE]
	move.b	#0x05,d0                        	| [$28cc: ld   a,$05]
	bra.b	l_28ce_2
l_28ce:
	move.b	#0x0A,d0                        	| [$28c7: ld   a,$0A]
l_28ce_2:
	move.b	d0,d4                           	| [$28ce: ld   e,a] -  * J28C5,J28C9
	move.b	unknown_E513,d0                 	| [$28cf: ld   a,(unknown_E513)]
	move.b	#0x00,d1                        	| [$28d2: ld   bc,$0080] 128
	move.b	#0x80,d2                        	| [$28d2: ld   bc,$0080] 128
	cmp.b	#0x08,d0                         	| [$28d5: cp   $08]
	jcc	l_28e2                             	| [$28d7: jr   nc,$28E2]
	move.b	#0x01,d1                        	| [$28d9: ld   bc,$0100] 256
	move.b	#0x00,d2                        	| [$28d9: ld   bc,$0100] 256
	cmp.b	#0x03,d0                         	| [$28dc: cp   $03]
	jcc	l_28e2                             	| [$28de: jr   nc,$28E2]
	move.b	#0x20,d2                        	| [$28e0: ld   c,$20]
l_28e2:
	LOAD_D1_16_FROM_D1D2
	STORE_LEW	d1,course_section_record_E094                 	| [$28e2: ld   (course_section_record_E094),bc] -  * J28D7,J28DE
	add.b	d4,d0                            	| [$28e6: add  a,e]
	add.b	d0,d0                            	| [$28e7: add  a,a]
	move.b	d0,d4                           	| [$28e8: ld   e,a]
	cmp.b	#0x0A,d0                         	| [$28e9: cp   $0A]
	jne	l_28f6                             	| [$28eb: jr   nz,$28F6]
	move.b	current_level_E510,d0                	| [$28ed: ld   a,(current_level_E510)] -  Course number
	cmp.b	#0x03,d0                         	| [$28f0: cp   $03]
	jeq	l_28f6                             	| [$28f2: jr   z,$28F6]
	move.b	#0x14,d4                        	| [$28f4: ld   e,$14]
l_28f6:
	clr.w	d3                               	| [$28f6: ld   d,$00] -  * J28EB,J28F2
	move.b	d4,d3
	lea	unknown_E00C,a0                	| [$28f8: ld   hl,unknown_E00C]
	add.w	d3,a0                            	| [$28fb: add  hl,de]
	move.b	(a0)+,d0                         	| [$28fc: ld   a,(hl)]
	                          	| [$28fd: inc  hl]
	move.l	a0,unknown_pointer_E096                 	| [$28fe: ld   (unknown_pointer_E096),hl]
	LOAD_D1D2_FROM_D1_16
	or.b	(a0),d0                           	| [$2901: or   (hl)]
	jne	l_2907                             	| [$2902: jr   nz,$2907]
	move.b	d1,(a0)                         	| [$2904: ld   (hl),b]
	                           	| [$2905: dec  hl]
	move.b	d2,-(a0)                         	| [$2906: ld   (hl),c]
l_2907:
	lea	game_rom+0x2B79,a0                      	| [$2907: ld   hl,$2B79] -  "TIME TO REACH POINT " script * J2902
	jbsr	write_text_to_screen_at_xy_with_delay_034e                            	| [$290a: call $034E]
	jbsr	current_point_modulus_26_2981                            	| [$290d: call $2981]
	tst.b	d0                               	| [$2910: and  a]
	jne	l_2915                             	| [$2911: jr   nz,$2915]
	* point Z!
	move.b	#0x1A,d0                        	| [$2913: ld   a,$1A]
l_2915:
	add.b	#0x40,d0                         	| [$2915: add  a,$40] -  * J2911
	* write point reached to screen
	subq.w	#2,a1                           	| [$2917: dec  de] * 2
	exg		d7,a1
	jbsr	osd_w_videoram					| [$2919: ld   (de),a]
	exg		a1,d7                      	
	lea	game_rom+0x2B94,a0                      	| [$291a: ld   hl,$2B94]   "YOUR TIME"
	jbsr	write_text_to_screen_at_xy_with_delay_034e                            	| [$291d: call $034E]
	lea	unknown_E512,a0                	| [$2920: ld   hl,unknown_E512]
	addq.w	#1,a1                           	| [$2923: inc  de]
	jbsr	write_2_digits_to_screen_039a                            	| [$2924: call $039A]
	lea	game_rom+0x2BB0,a0                      	| [$2927: ld   hl,$2BB0] -  "THE AVERAGE TIME " script
	jbsr	write_text_to_screen_at_xy_with_delay_034e                            	| [$292a: call $034E]
	jbsr	write_course_section_record_2968                            	| [$292d: call $2968]
	lea	game_rom+0x2BCC,a0                      	| [$2930: ld   hl,$2BCC] -  "TOP RECORD " script
	jbsr	write_text_to_screen_at_xy_with_delay_034e                            	| [$2933: call $034E]
	move.l	unknown_pointer_E096,a0             	| [$2936: ld   hl,(unknown_pointer_E096)]
	addq.w	#1,a1                           	| [$2939: inc  de]
	jbsr	write_2_digits_to_screen_039a                            	| [$293a: call $039A]
	LOAD_LEW	course_section_record_E094,d5             	| [$293d: ld   hl,(course_section_record_E094)]
	LOAD_LEW	time_bcd_E511,d3            	| [$2940: ld   de,(time_bcd_E511)]
	                              	| [$2944: and  a]
	sub.w	d3,d5                            	| [$2945: sbc  hl,de]
	rts                                    	| [$2947: ret]
l_2948:
	lea	sprite_shadow_E100,a0          	| [$2948: ld   hl,sprite_shadow_E100] -  * C0D8D,C27E1,C2869
	move.w	#0xa4,d1                        	| [$294b: ld   bc,$00A4] 164
	jbsr	clear_area_05fa                   	| [$294e: call clear_area_05fa]
	move.w	#0x220,d1                        	| [$2951: ld   bc,$0220] 544
l_2954:
	move.w	#0x80E0,d7                      	| [$2954: ld   hl,$80E0] -  * J2966
	jra	clear_video_area                    	| [$2957: jp   clear_area_05fa]
l_295a:
	lea	sprite_shadow_E100,a0          	| [$295a: ld   hl,sprite_shadow_E100] -  * C28BD
	move.w	#0xc6,d1                        	| [$295d: ld   bc,$00C6] 198
	jbsr	clear_area_05fa                   	| [$2960: call clear_area_05fa]
	move.w	#0x320,d1                        	| [$2963: ld   bc,$0320]
	jra	l_2954                             	| [$2966: jr   $2954]
write_course_section_record_2968:
	move.w	#0x81D9,a1                      	| [$2968: ld   de,$81D9] -  * C283E,C292D
	lea	course_section_record_E094+1,a0                	| [$296b: ld   hl,unknown_E095]
	jra	write_2_digits_to_screen_039a                             	| [$296e: jp   $039A]
display_good_bonus_points_2971:
	lea	unknown_E099,a0                	| [$2971: ld   hl,unknown_E099] -  * C2808,C284F
	move.w	#0x8297,a1                      	| [$2974: ld   de,$8297]
	jbsr	write_2_digits_to_screen_0393                            	| [$2977: call $0393]
	exg	a1,d7                              	| [$297a: ex   de,hl]
	move.b	#0x30,d0
	jbsr	osd_w_videoram
	addq.w	#1,d7
	jbsr	osd_w_videoram
	                    	| [$297b: ld   (hl),$30]
	      	| [$297d: inc  hl]
	                   	| [$297e: ld   (hl),$30]
	rts                                    	| [$2980: ret]
current_point_modulus_26_2981:
	move.b	cur_point_e50e,d0                 	| [$2981: ld   a,(cur_point_e50e)] -  * C0C1A,C0E73,C290D,C29AB
	cmp.b	#0x1A,d0                         	| [$2984: cp   $1A] point 26 aka Z ?
	bcc.b	0f                               	| [...]
	rts                                    	| [$2986: ret  c] [...]
0:
	sub.b	#0x1A,d0                         	| [$2987: sub  $1A]
	rts                                    	| [$2989: ret]
	
display_position_in_map_298a:
	* first write map background (pale blue)
	LOAD_VIDEORAM_ADDRESS	0x80CC                      	| [$298a: ld   hl,$80CC] -  * C0D0F
	move.w	#0x84CC,d3                      	| [$298d: ld   de,$84CC]
	move.b	#0x10,d1                        	| [$2990: ld   bc,$1002] 4098
	move.b	#0x02,d2                        	| [$2990: ld   bc,$1002] 4098
	jbsr	trans_color_03e7                            	| [$2993: call $03E7]
	move.b	d2,d0                           	| [$2996: ld   a,c]
l_2997:
	WRITE_VIDEORAM	#0x21                      	| [$2997: ld   (hl),$21] -  * J299C
	exg		d3,d7
	jbsr	osd_w_colorram                         	| [$2999: ld   (de),a]
	exg		d3,d7
	addq.w	#1,d7                           	| [$299a: inc  hl]
	addq.w	#1,d3                           	| [$299b: inc  de]
	subq.b	#1,d1                           	| [...]
	jne	l_2997                             	| [$299c: djnz $2997]
	LOAD_VIDEORAM_ADDRESS	0x80CC                      	| [$299e: ld   hl,$80CC]
	* now sections, character 0x22 (vertical separator)
	move.b	#0x05,d1                        	| [$29a1: ld   b,$05]
l_29a3:
	jbsr	osd_r_videoram                         	| [$29a3: inc  (hl)] -  * J29A7
	addq.b	#1,d0
	jbsr	osd_w_videoram
	addq.w	#3,d7                           	| [$29a4: inc  hl] * 3
	subq.b	#1,d1                           	| [...]
	jne	l_29a3                             	| [$29a7: djnz $29A3]
	* the end
	WRITE_VIDEORAM	#0x1B                      	| [$29a9: ld   (hl),$1B]
	* now the current point to fill with red until current point

	jbsr	current_point_modulus_26_2981                            	| [$29ab: call $2981]

	LOAD_VIDEORAM_ADDRESS	0x80CC                      	| [$29ae: ld   hl,$80CC]
	move.b	#0x05,d1                        	| [$29b1: ld   b,$05]
l_29b3:
	cmp.b	#0x05,d0                         	| [$29b3: cp   $05] -  * J29C1
	jcs	l_29c3                             	| [$29b5: jr   c,$29C3]
	move.b	#0x03,d3                        	| [$29b7: ld   d,$03]
l_29b9:
	* fully filled
	WRITE_VIDEORAM	#0x29                      	| [$29b9: ld   (hl),$29] -  * J29BD
	addq.w	#1,d7                           	| [$29bb: inc  hl]
	subq.b	#1,d3                           	| [$29bc: dec  d]
	jne	l_29b9                             	| [$29bd: jr   nz,$29B9]
	subq.b	#0x05,d0                        	| [$29bf: sub  $05]
	subq.b	#1,d1                           	| [...]
	jne	l_29b3                             	| [$29c1: djnz $29B3]
l_29c3:
	* d0 <- d0 * 5
	move.b	d0,d3                           	| [$29c3: ld   d,a] -  * J29B5
	add.b	d0,d0                            	| [$29c4: add  a,a]
	add.b	d0,d0                            	| [$29c5: add  a,a]
	add.b	d3,d0                            	| [$29c6: add  a,d]
	* what's the use??? d4 is never read again...
	move.b	d0,d4                           	| [$29c7: ld   e,a]
l_29c8:
	cmp.b	#0x08,d0                         	| [$29c8: cp   $08] -  * J29D4
	jcs	l_29dc                             	| [$29ca: jr   c,$29DC]
	jeq	l_29cf                             	| [$29cc: jr   z,$29CF]
	subq.b	#1,d0                           	| [$29ce: dec  a]
l_29cf:
	* fully filled
	WRITE_VIDEORAM	#0x29                      	| [$29cf: ld   (hl),$29] -  * J29CC
	addq.w	#1,d7                           	| [$29d1: inc  hl]
	sub.b	#0x08,d0                         	| [$29d2: sub  $08]
	jra	l_29c8                             	| [$29d4: jr   $29C8]
l_29d6:
	move.w	progress_map_next_char_address_E0F4,d7             	| [$29d6: ld   hl,(progress_map_next_char_address_E0F4)] -  * C0E03,C2863
	move.b	progress_map_fine_increment_E0F6,d0                 	| [$29d9: ld   a,(progress_map_fine_increment_E0F6)]
l_29dc:
	addq.b	#1,d0                           	| [$29dc: inc  a] -  * J29CA
	move.b	d0,d3                           	| [$29dd: ld   d,a]
	add.b	#0x21,d0                         	| [$29de: add  a,$21] character for map
	move.w	d0,-(a7)
	jbsr	osd_r_videoram					| read current character at current position
	btst.b	#4,d0                         	| [$29e0: bit  4,(hl)]
	movem.w	(a7)+,d0
	jeq	l_29eb                             	| [$29e2: jr   z,$29EB]
	subq.b	#0x06,d0                        	| [$29e4: sub  $06]
	cmp.b	#0x20,d0                         	| [$29e6: cp   $20]
	jne	l_29eb                             	| [$29e8: jr   nz,$29EB]
	subq.b	#1,d0                           	| [$29ea: dec  a]
l_29eb:
	jbsr	osd_w_videoram                         	| [$29eb: ld   (hl),a] -  * J29E2,J29E8
	move.b	d3,d0                           	| [$29ec: ld   a,d]
	cmp.b	#0x08,d0                         	| [$29ed: cp   $08]
	jcs	l_29f3                             	| [$29ef: jr   c,$29F3]
	clr.b	d0                               	| [$29f1: xor  a]
	addq.w	#1,d7                           	| [$29f2: inc  l]
l_29f3:
	move.b	d0,progress_map_fine_increment_E0F6                 	| [$29f3: ld   (progress_map_fine_increment_E0F6),a] -  * J29EF
	move.w	d7,progress_map_next_char_address_E0F4     	| [$29f6: ld   (progress_map_next_char_address_E0F4),hl]
	rts                                    	| [$29f9: ret]
	
fill_done_section_in_map_29fa:
	LOAD_VIDEORAM_ADDRESS 0x80CC                      	| [$29fa: ld   hl,$80CC] -  * C27D2
	move.b	#0x0F,d1                        	| [$29fd: ld   b,$0F]
l_29ff:
	move.b	#0x29,d0                      	| [$29ff: ld   (hl),$29] -  * J2A02 full rectangle
	jbsr	osd_w_videoram
	addq.w	#1,d7                           	| [$2a01: inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_29ff                             	| [$2a02: djnz $29FF]
	move.b	#0x1F,d0                      	| [$2a04: ld   (hl),$1F]
	jbsr	osd_w_videoram
	move.b	#0x5A,d0                        	| [$2a06: ld   a,$5A]
	LOAD_VIDEORAM_ADDRESS	0x8052
	jbsr	osd_w_videoram                     	| [$2a08: ld   ($8052),a]
	rts                                    	| [$2a0b: ret]



* < A0: source (HL)
* < A1: destination (DE)
* < D1: decremented (16 bit)
lddr:
    subq.w    #1,d1
    addq.w  #1,a0
    addq.w  #1,a1
0:
    move.b    -(a0),-(a1)
    dbf        d1,0b

    subq.w  #1,a0
    subq.w  #1,a1
    clr.w    d1
    rts
	
* < A0: source (HL)
* < A1: destination (DE)
* < D1: length (16 bit)
ldir:
    subq.w    #1,d1
0:
    move.b    (a0)+,(a1)+
    dbf        d1,0b
    clr.w    d1
    rts

* < A0: source (HL)
* < D1: length to search
* > D0.B value searched for (A)
* > Z flag if found
cpir:
    subq.w    #1,d1
0:
    cmp.b    (a0)+,d0
    beq.b    1f
    dbf        d1,0b
    clr.w    d1
    * not found: unset Z
    cmp.b   #1,d1
1:
    rts

* < all registers d1-d4/a0/a1/a4
* > all registers swapped
*: note regscopy must be defined somewhere in RAM
*: with a size of 56
exx:
    lea     regscopy+28,a6
    * save current regs in region 1
    movem.l d1-d4/a0/a1/a4,-(a6)
    * restore old regs from region 2
    lea     regscopy+28,a6
    movem.l (a6),d1-d4/a0/a1/a4
    * now copy region 1 to region 2
    movem.l d1-d4/a0/a1/a4,-(a7)
    lea     regscopy,a6
    movem.l (a6)+,d1-d4/a0/a1/a4
    movem.l d1-d4/a0/a1/a4,(a6)
    movem.l (a7)+,d1-d4/a0/a1/a4
    rts
